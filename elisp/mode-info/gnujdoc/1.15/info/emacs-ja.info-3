Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999
Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU General
Public License" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU General Public License" may be included in a translation
approved by the Free Software Foundation instead of in the original
English.





File: emacs-ja.info, Node: Apropos, Next: Library Keywords, Prev: Name Help, Up: Help

アプロポス
==========

より洗練された質問方法としては、『ファイルを扱うコマンドは？』というのが
あります。このように質問するには、`C-h a file RET'と打ちます。すると、
`copy-file'や`find-file'といった、`file'を名前に含むすべてのコマンドの一
覧が表示されます。各コマンドには、使い方の簡単な説明やそのコマンドを起動
するキーが表示されます。たとえば、`find-file'を起動するには`C-x C-f'と打
つ、といった具合です。`C-h a'の`a'は「Apropos」（「適切な」の意味）を表
していて、`C-h a'はコマンド`apropos-command'を実行します。このコマンドは、
通常、コマンド（対話的な関数）のみを調べます。前置引数を指定すれば、非対
話的な関数も調べます。

`C-h a'は指定した文字列を名前に含む関数しか調べませんので、文字列の指定
には工夫が必要です。後向きに文字をキルするコマンドを探そうとして、`C-h a
kill-backwards RET'で何も表示されなくてもあきらめないでください。`kill'
のみ、あるいは`backwards'のみ、もしくは`back'のみを試して、続けてくださ
い。柔軟性を増すために、引数として正規表現も使えます（*Note Regexps::）。

以下に、`C-h a'に指定する引数のうち、Emacsコマンドの多くの種類を網羅する
ものをあげておきます。というのは、Emacsコマンドの標準の命名法には強い慣
行があるからです。命名法の慣行を理解してもらえば、適切な（`apropos'）文
字列を拾い出す技法の向上の手助けにもなるでしょう。

     char、line、word、sentence、paragraph、region、page、sexp、list、
     defun、rect、buffer、frame、window、face、file、dir、register、mode、
     beginning、end、forward、backward、next、previous、up、down、search、
     goto、kill、delete、mark、insert、yank、fill、indent、case、change、
     set、what、list、find、view、describe、default。

正規表現に一致するすべてのユーザー変数を表示するには、コマンド`M-x
apropos-variable'を使います。このコマンドは、デフォルトでは、ユーザー変
数とカスタマイズオプションだけを表示します。すべての変数を調べるには、前
置引数を指定します。

コマンドとして定義されているものだけでなく、正規表現に一致するすべての
Lispシンボルを表示するには、`C-h a'のかわりに`M-x apropos'を使います。こ
のコマンドは、デフォルトでは、キーバインドを調べません。キーバインドを調
べるには、前置引数を指定します。

`apropos-documentation'コマンドは`apropos'に似ていますが、指定した正規表
現に一致するシンボル名だけでなく、説明文字列も探索する点が異なります。

`apropos-value'コマンドは`apropos'に似ていますが、指定した正規表現に一致
するシンボルの値を探す点が異なります。このコマンドは、デフォルトでは、関
数定義や属性リストを調べません。それらも調べるには、前置引数を指定します。

変数`apropos-do-all'が`nil'以外ならば、上に述べたコマンドはすべて、前置
引数を指定したものとして動作します。

アプロポス（apropos）バッファに表示された関数定義、変数、属性リストにつ
いて詳しく知りたいときには、`Mouse-2'ボタンでクリックするか、その箇所へ
移動してRETを打ちます。



File: emacs-ja.info, Node: Library Keywords, Next: Language Help, Prev: Apropos, Up: Help

Lispライブラリに対するキーワード探索
====================================

`C-h p'コマンドで、標準Emacs Lispライブラリをトピックのキーワードで検索
できます。利用可能なキーワードの一部を以下に示します。

     abbrev -- 略語操作、短縮入力、マクロ。
     bib -- 参考、参照プロセッサ支援`bib'。
     c -- C言語あるいはC++支援。
     calendar -- 日付および時間管理支援。
     comm -- 通信、ネットワーク、ファイルのリモートアクセス。
     data -- データファイルの編集支援。
     docs -- Emacsドキュメントに関する支援。
     emulations -- 他のエディタのエミュレーション。
     extensions -- Emacs Lisp言語の拡張。
     faces -- フェイス（フォントや表示色、*Note Faces::）に関する支援。
     frames -- Emacsフレームやウィンドウシステムに対する支援。
     games -- ゲーム、ジョーク、娯楽。
     hardware -- 外部ハードウェアとのインターフェイス支援。
     help -- オンラインヘルプシステム支援。
     hypermedia -- テキストあるいは他メディア内でのリンク支援。
     i18n -- 国際化、代替文字集合支援。
     internal -- Emacs内部コード、構築手順、デフォルト。
     languages -- プログラム言語編集用の特殊モード。
     lisp -- Lisp利用支援（Emacs Lispも含む）。
     local -- サイトにローカルなライブラリ。
     maint -- Emacs開発グループ向けの管理用。
     mail -- 電子メイル操作用のモード。
     matching -- 探索、一致。
     news -- ネットニュースの購読、投稿支援。
     non-text -- 非テキストファイル編集支援。
     oop -- オブジェクト指向プログラミング支援。
     outlines -- 階層アウトライン。
     processes -- プロセス、サブシェル、コンパイル、ジョブ制御支援。
     terminals -- 端末タイプ支援。
     tex -- TeXによる文書整形支援。
     tools -- プログラミングツール。
     unix -- UNIX機能のフロントエンド／アシスタントあるいはエミュレーション。
     vms -- VMS支援コード。
     wp -- ワープロ。



File: emacs-ja.info, Node: Language Help, Next: Help Mode, Prev: Library Keywords, Up: Help

多言語支援に関するヘルプ
========================

コマンド`C-h L'（`describe-language-environment'）を使うと、特定の言語環
境向けに、どのような支援があるかを把握できます。*Note Language
Environments::。このコマンドは、今の言語環境がどの言語向けなのかを示し、
一緒に使われる文字集合、コーディングシステム、入力方式も表示します。また、
字体を例示するためのサンプルテキストもいくつか表示します。

コマンド`C-h h'（`view-hello-file'）は、ファイル`etc/HELLO'を表示します。
このファイルには、いろいろな国の言葉で書いた『hello』を収めてあります。

コマンド`C-h I'（`describe-input-method'）は、指定した入力方式、あるいは、
デフォルトとして今使っている入力方式についての情報を表示します。*Note
Input Methods::。

コマンド`C-h C'（`describe-coding-system'）は、指定したコーディングシス
テム、あるいは、デフォルトとして今使っているコーディングシステムについて
の情報を表示します。*Note Coding Systems::。



File: emacs-ja.info, Node: Help Mode, Next: Misc Help, Prev: Language Help, Up: Help

ヘルプモードのコマンド
======================

ヘルプバッファには、閲覧（view）モード（*Note Misc File Ops::）のコマン
ドに加えて、独自の特別なコマンドもいくつかあります。

`SPC'
     前向きにスクロールする。
`DEL'
     後向きにスクロールする。
`RET'
     ポイント位置の相互参照を辿る。
`TAB'
     つぎの相互参照へ進む。
`S-TAB'
     まえの相互参照へ戻る。
`Mouse-2'
     クリックした相互参照を辿る。

説明文に現れるコマンド名（*Note M-x::）や変数名（*Note Variables::）は通
常、引用符（`''）で囲まれています。その名前を`Mouse-2'でクリックしたり、
あるいは、そこへポイントを移動してRETを打つと、そのコマンドや変数の説明
文字列を表示できます。もとの場所に戻るには`C-c C-b'を使います。

ヘルプテキスト内の相互参照にポイントを移動する便利なコマンドがあります。
TAB（`help-next-ref'）は、ポイントをつぎの相互参照箇所へ進めます。ポイン
トをまえの相互参照箇所へ戻すには`S-TAB'（`help-previous-ref'）を使います。



File: emacs-ja.info, Node: Misc Help, Prev: Help Mode, Up: Help

その他のヘルプコマンド
======================

`C-h i'（`info'）はinfoプログラムを実行します。infoは構造化されたドキュ
メントファイルを閲覧するプログラムです。Emacsの完全なマニュアルもinfoで
読むことができます。将来的には、GNUシステムのすべてのドキュメントが読め
るようになるでしょう。infoの使い方についてのチュートリアルを起動するには、
infoに入ってから`h'と打ちます。

数引数を指定すると、`C-h i'はドキュメントファイルの名前を聞いてきます。
こうすれば、トップレベルのinfoメニューに記載されていないファイルでも閲覧
できます。

infoを介してEmacsドキュメントを参照するための特別なヘルプコマンドが2つあ
ります。`C-h C-f FUNCTION RET'は、infoに入ってただちにEmacsの関数
FUNCTIONのドキュメントに移動します。`C-h C-k KEY'は、infoに入ってただち
にキーKEYのドキュメントに移動します。これら2つのキーは、それぞれ、
`Info-goto-emacs-command-node'、`Info-goto-emacs-key-command-node'を実行
します。

プログラム言語のinfo版のマニュアルがあれば、プログラムの編集中にコマンド
`C-h C-i'を使って、マニュアルドキュメントのシンボル（キーワード、関数、
変数）に関する箇所を参照できます。コマンドの細かい動作は、メジャーモード
に依存します。

予期しなかったことが起きたり、入力したコマンドがわからなくなってしまった
ときは、`C-h l'（`view-lossage'）を使ってください。`C-h l'は、それまでに
打鍵した最後の100個のコマンド文字を表示します。知らないコマンドが表示さ
れたら、`C-h c'でその機能を知ることができます。

Emacsには数多くのメジャーモードがあり、各メジャーモードでは、いくつかの
キーを再定義し、編集動作も少々変更しています。`C-h m'（`describe-mode'）
は、使用中のメジャーモードについての説明文を表示します。これには、通常、
モード内で変更してあるすべてのコマンドについての記述があります。

`C-h b'（`describe-bindings'）と`C-h s'（`describe-syntax'）は、Emacsの
現在のモードに関するその他の情報を与えてくれます。`C-h b'は、現在有効な
すべてのキーバインドの一覧を表示します。マイナモードで定義されているロー
カルバインディングから始めて、現在のメジャーモードで定義されているローカ
ルバインディング、最後にグローバルバインディングを表示します（*Note Key
Bindings::）。`C-h s'は、各文字の構文の説明を付けて構文テーブルの内容を
表示します（*Note Syntax::）。

プレフィックスキーに続けて`C-h'を打てば、特定のプレフィックスキーについ
て同様な一覧を表示できます。（この方法では表示できないプレフィックスキー
も存在する。それらのキーでは、`C-h'に対しては独自のバインディングがある。
ESCは、そのようなものの1つ。`ESC C-h'は、実際には`C-M-h'であり、関数定義
（defun）をマークする。）

`C-h'の他のオプションは、有益な情報を収めたさまざまなファイルを表示しま
す。`C-h C-w'は、GNU Emacsがまったく無保証であることに関する全詳細を表示
します。`C-h n'（`view-emacs-news'）は、ファイル`emacs/etc/NEWS'を表示し
ます。このファイルには、Emacsの変更に関する記述を時間順に収めてあります。
`C-h F'（`view-emacs-FAQ'）は、Emacsの「よくある質問集」を表示します。
`C-h t'（`help-with-tutorial'）は、「操作しながらEmacsを学ぶ」チュートリ
アルを表示します。`C-h C-c'（`describe-copying'）は、ファイル
`emacs/etc/COPYING'を表示します。このファイルには、Emacsを配布する場合に
従うべき条件を記述してあります。`C-h C-d'（`describe-distribution'）は、
ファイル`emacs/etc/DISTRIB'を表示します。このファイルには、Emacsの最新版
の注文方法を述べてあります。`C-h C-p'（`describe-project'）は、GNUプロジェ
クトに関する一般情報を表示します。


File: emacs-ja.info, Node: Mark, Next: Killing, Prev: Help, Up: Top

マークとリージョン
******************

Emacsの数多くのコマンドは、カレントバッファの任意の連続領域を操作します。
このようなコマンドに操作対象となるテキストを指定するには、その一方の端に
"マーク"（mark）を置き、もう一方の端にポイントを移動します。ポイントとマー
クに挟まれたテキストを"リージョン"（region）と呼びます。暫定マーク
（transient-mark）モードをオンにすると、リージョンが存在すればEmacsはつ
ねにそのリージョンを強調表示します（*Note Transient Mark::）。

リージョンの境界を調整するには、ポイントやマークを移動します。時間的にど
ちらを先に設定したとか、テキスト内でどちらが先にあるかとかは関係ありませ
ん。いったんマークを設定すると、他の箇所に再設定するまで、その位置情報は
そのまま変わりません。各Emacsバッファには個別にマークがありますから、以
前に選択したバッファへ戻ったときには、以前と同じままのマークが残っていま
す。

`C-y'（`yank'）や`M-x insert-buffer'などのテキストを挿入するコマンドの多
くは、挿入したテキストの両端にポイントとマークを置いて、挿入したテキスト
がリージョンに含まれるようにします。

リージョンの境界を定めること以外に、あとで戻る可能性のある箇所を覚えてお
くためにもマークを使えます。この機能をより使いやすくするために、各バッファ
では、それまでに設定した16個のマーク位置を"マークリング"（mark ring）に
記録しています。

* Menu:

* Setting Mark::	Commands to set the mark.
* Transient Mark::	How to make Emacs highlight the region--
			  when there is one.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::   	Previous mark positions saved so you can go back there.
* Global Mark Ring::    Previous mark positions in various buffers.



File: emacs-ja.info, Node: Setting Mark, Next: Transient Mark, Up: Mark

マークを設定する
================

マークを設定するコマンドはつぎのとおりです。

`C-SPC'
     ポイント位置にマークを置く（`set-mark-command'）。
`C-@'
     上と同様。
`C-x C-x'
     マークとポイントを入れ換える（`exchange-point-and-mark'）。
`Drag-Mouse-1'
     ドラッグしたテキストの周囲にポイントとマークを設定する。
`Mouse-3'
     ポイント位置にマークを設定し、クリックした箇所にポイントを移動する
     （`mouse-save-then-kill'）。

たとえば、コマンド`C-x C-u'（`upcase-region'）を使って、バッファのある部
分をすべて大文字に変換したいとしましょう。このコマンドは、リージョン中の
テキストに作用します。まず、大文字に変換したいテキストの先頭に移動し、
`C-SPC'と打ってマークを設定します。続いてテキストの終端に移動して`C-x
C-u'と打ちます。あるいは、先にテキストの終端にマークを設定して、テキスト
の始点に移動してから`C-x C-u'と打ちます。

マークを設定するもっとも一般的な方法は、`C-SPC'コマンド
（`set-mark-command'）を使うことです。このコマンドは、ポイント位置にマー
クを設定します。そうすれば、マークを置いたままで、ポイントを移動できます。

マウスを使ったマークの設定方法は2つあります。テキストのある範囲でマウス
ボタン1をドラッグします。マウスボタンを離した位置にポイントが置かれ、ド
ラッグを開始した箇所にマークが設定されます。あるいは、マウスボタン3をク
リックします。これは（`C-SPC'と同様に）ポイント位置にマークを設定してか
ら、ポイントを（`Mouse-1'のように）移動します。両者は、マークを設定する
だけでなく、リージョンをキルリングにコピーします。これは、他のウィンドウ
アプリケーションの動作と一貫性を持たせるためです。キルリングを変更したく
なければ、キーボードコマンドを使ってマークを設定する必要があります。
*Note Mouse Commands::。

普通の端末にはカーソルは1つしかありませんから、Emacsにはマークを置いた位
置を表示する術はありません。ユーザーがその位置を覚えておく必要があります。
この問題に対する通常の解決方法は、マークを設定したら、忘れてしまうまえに
ただちにそれを利用することです。あるいは、`C-x C-x'
（`exchange-point-and-mark'）コマンドを使って、マーク位置を確認します。
このコマンドは、ポイント位置にマークを置き、マークのあった位置にポイント
を置きます。リージョンの範囲は変わらずに、カーソルとポイントは以前マーク
のあった箇所に移動します。暫定マーク（transient-mark）モードでは、このコ
マンドはマークを再度活性にします。

ポイント位置を変えずに、リージョンのもう一方の端（マークの位置）を移動さ
せたい場合にも、`C-x C-x'は便利な方法です。まず、`C-x C-x'でポイントをリー
ジョンの一方の端に移して、その端を移動します。必要ならば、もう1度`C-x
C-x'を使って新しい位置にマークを置き、ポイントをもとの位置に戻します。

ASCIIには、`C-SPC'という文字は存在しません。CTRLを押し下げながらSPCを打
つと、ほとんどの普通の端末では文字`C-@'になります。このキーは、実際に
`set-mark-command'にバインドしてあります。ただし、幸運にも`C-SPC'で`C-@'
を送出する端末を使っているのであれば、`C-@'を`C-SPC'とみなしてかまいませ
ん。Xウィンドウシステムでは、`C-SPC'は実際には別の文字として認識されます
が、そのバインドはやはり`set-mark-command'です。



File: emacs-ja.info, Node: Transient Mark, Next: Using Region, Prev: Setting Mark, Up: Mark

暫定マークモード（transient-markモード）
========================================

Xウィンドウシステムを使っているのであれば、Emacsはカレントリージョンを強
調表示できます。ただし、通常はリージョンを強調表示しません。なぜでしょう
か？

実は、もともとのEmacsではリージョンの強調表示をうまくできないのです。いっ
たんマークを設定してしまうと、そのバッファ内には*つねに*リージョンが存在
することになるからです。リージョンを強調表示し続けても迷惑なだけでしょう。

暫定マーク（transient-mark）モードをオンにすると、リージョンの強調表示機
能をオンにできます。暫定マーク（transient-mark）モードは、リージョンが一
時的にしか『存続』しない、通常よりきびしい操作モードです。ユーザーは、リー
ジョンを使うコマンドごとにリージョンを設定する必要があります。暫定マーク
（transient-mark）モードでは、ほとんどの期間、リージョンは存在しません。
それゆえ、リージョンが存在するときにリージョンを強調表示しても邪魔になり
ません。

暫定マーク（transient-mark）モードをオンにするには、`M-x
transient-mark-mode'と打ちます。このコマンドはモードのオン／オフを切り替
えますから、モードをオフにしたいときにはコマンドをもう1度繰り返します。

暫定マーク（transient-mark）モードの詳細を以下に示します。

   * マークを設定するには、`C-SPC'（`set-mark-command'）と打つ。この操作
     はマークを活性にする。ポイントを移動するたびに、強調表示されたリー
     ジョンが広がったり狭まったりする。

   * マークを設定するマウスコマンドも、マークを活性にする。`M-@'、
     `C-M-@'、`M-h'、`C-M-h'、`C-x C-p'、`C-x h'などのリージョンを設定す
     るためのキーボードコマンドもマークを活性にする。

   * マークが活性ならば、キル、字下げ、ファイルへの書き出しなどのリージョ
     ンを操作するコマンドを実行できる。

   * 文字の挿入や削除といったバッファに対する変更は、マークを不活性にす
     る。つまり、これ以降にリージョンを操作するコマンドを実行するとエラー
     となり、実行は拒否される。リージョンを再度活性にするには、`C-x C-x'
     と打つ。

   * `M->'や`C-s'のような、本来の目的を達成したあとに『マークを残す』種
     類のコマンドは、新しいマークを活性にしない。このような新しいリージョ
     ンを活性にするには、`C-x C-x'（`exchange-point-and-mark'）を実行す
     る。

   * マークが活性であるときには、`C-s'はマークを変更しない。

   * `C-g'で中断すると、マークを不活性にする。

リージョンの強調表示には、`region'フェイスを使います。このフェイスを変更
すれば、リージョンの強調表示方法をカスタマイズできます。

複数のウィンドウで同じバッファを表示しているときには、それぞれのウィンド
ウで別の部分を表示できます。というのは、（マーク位置は共有されるが）各ウィ
ンドウごとに別々にポイントの値があるからです。通常、選択されたウィンドウ
でのみ、リージョンを強調表示します（*Note Windows::）。しかし、変数
`highlight-nonselected-windows'に`nil'以外を設定すると、（暫定マーク
（transient-mark）モードがオンであり、かつ、ウィンドウのバッファのマーク
が活性である場合に限り）各ウィンドウでそれぞれのリージョンを強調表示しま
す。

暫定マーク（transient-mark）モードがオフであると、マークを設定するすべて
のコマンドはマークを活性にし、マークを不活性にするものは何もありません。

暫定マーク（transient-mark）モードにおいて、変数`mark-even-if-inactive'
が`nil'以外であると、マークが不活性であってもコマンドはマークやリージョ
ンを利用できます。通常の暫定マーク（transient-mark）モードと同様に、リー
ジョンが強調表示されたりされなかったりしますが、強調表示されていなくても
マークが本当になくなることはありません。

暫定マーク（transient-mark）モードは『zmacsモード』としても知られていま
す。というのも、MITのLispマシン上で動作していたZmacsエディタが同じように
マークを扱っていたからです。



File: emacs-ja.info, Node: Using Region, Next: Marking Objects, Prev: Transient Mark, Up: Mark

リージョンに対する操作
======================

いったんリージョンを設定しマークを活性にすれば、以下のようにリージョンを
操作できます。

   * `C-w'コマンドでキルする（*Note Killing::）。
   * `C-x r s'でレジスタに保存する（*Note Registers::）。
   * バッファやファイルに保存する（*Note Accumulating Text::）。
   * `C-x C-l'や`C-x C-u'で大文字小文字を変換する（*Note Case::）。
   * `C-x TAB'や`C-M-\'で字下げする（*Note Indentation::）。
   * `M-x fill-region'でテキストを詰め込む（*Note Filling::）。
   * `M-x print-region'でハードコピーを印刷する（*Note Hardcopy::）。
   * `M-x eval-region'でLispコードとして評価する（*Note Lisp Eval::）。

リージョン内のテキストを操作するコマンドの多くは、その名前に`region'とい
う単語を含みます。



File: emacs-ja.info, Node: Marking Objects, Next: Mark Ring, Prev: Using Region, Up: Mark

テキストオブジェクトをマークするコマンド
========================================

単語、リスト、段落、ページといったテキストのまとまりにポイントやマークを
置くコマンドがあります。

`M-@'
     つぎの語の末尾にマークを設定する（`mark-word'）。このコマンドとつぎ
     のコマンドはポイントを移動しない。
`C-M-@'
     つぎのLisp式の末尾にマークを設定する（`mark-sexp'）。
`M-h'
     現在の段落を囲むリージョンを設定する（`mark-paragraph'）。
`C-M-h'
     現在のLisp関数定義（defun）を囲むリージョンを設定する（`mark-defu
     n'）。
`C-x h'
     バッファ全体をリージョンとする（`mark-whole-buffer'）。
`C-x C-p'
     現在のページを囲むリージョンを設定する（`mark-page'）。

`M-@'（`mark-word'）がつぎの語の末尾にマークを設定するのに対し、`C-M-@'
（`mark-sexp'）はつぎのLisp式の末尾にマークを設定します。これらのコマン
ドは、`M-f'や`C-M-f'と同様に引数を扱います。

その他のコマンドは、ポイントとマークの両方を設定して、バッファ内で対象物
を区切ります。たとえば、`M-h'（`mark-paragraph'）は、ポイントを囲むある
いはポイントに続く段落の先頭にポイントを移動し、その段落の末尾にマークを
置きます（*Note Paragraphs::）。このようにリージョンを設定するので、段落
全体を字下げしたり、大文字小文字を変換したり、キルしたりできます。

`C-M-h'（`mark-defun'）も同様に、現在の関数定義や後続の関数定義の先頭に
ポイントを置き、その末尾にマークを置きます（*Note Defuns::）。`C-x C-p'
（`mark-page'）は、現在のページの先頭にポイントを置き、その末尾にマーク
を置きます（`mark-page'）。マークはページ区切りの直後に設定され（リージョ
ンに含まれる）、一方、ポイントはページ区切りの直後に置かれます（リージョ
ンに含まれない）。数引数で、現在のページのかわりに（正ならば）後続のペー
ジや、（負ならば）先行するページを指定できます。

最後に紹介する`C-x h'（`mark-whole-buffer'）は、バッファ全体にリージョン
を設定します。つまり、ポイントをバッファの先頭に置き、マークをバッファの
末尾に置きます。

暫定マーク（transient-mark）モードでは、これらのコマンドはすべて、マーク
を活性にします。



File: emacs-ja.info, Node: Mark Ring, Next: Global Mark Ring, Prev: Marking Objects, Up: Mark

マークリング
============

マークには、リージョンを区切る以外にも、あとで戻る可能性のある箇所を記録
するという便利な使い方があります。この機能をより便利にするために、各バッ
ファでは以前の16箇所のマーク位置を"マークリング"（mark ring）に記録して
います。マークを設定するコマンドは、古いマークをこのマークリングに入れま
す。マークを設定していた箇所に戻るには、`C-u C-SPC'（または`C-u C-@'）を
使います。これは、`set-mark-command'コマンドに数引数を指定したものです。
このコマンドは、マークがあった箇所にポイントを移動し、それ以前のマークを
収めたマークリングからマークを復元します。したがって、このコマンドを繰り
返すと、マークリング上にある過去のマークのすべてを1つ1つ遡って移動できま
す。このように辿ったマーク位置は、マークリングのうしろに付け加えられるの
で、なくなってしまうことはありません。

各バッファには独自のマークリングがあります。すべての編集コマンドは、カレ
ントバッファのマークリングを使います。特に、`C-u C-SPC'は、つねに同じバッ
ファに留まります。

`M-<'（`beginning-of-buffer'）のような長距離を移動するコマンドの多くは、
まずマークを設定して、古いマークをマークリングに保存してから動作を開始し
ます。このようにして、あとで簡単に戻れるようにしておきます。探索コマンド
は、ポイントを移動するときにはマークを設定します。コマンドがマークを設定
したかどうかは、エコー領域に`Mark Set'と表示されるのでわかります。

何度も同じ場所に戻りたい場合には、マークリングでは不十分でしょう。このよ
うな場合には、あとで使うために位置情報をレジスタに記録できます（*Note
RegPos::）。

変数`mark-ring-max'は、マークリングに保存する最大項目数を指定します。す
でに多くの項目が存在していて、さらにもう1つ押し込むときには、リスト内の
最古の項目を捨てます。`C-u C-SPC'を繰り返し実行すると、いまマークリング
に入っている位置を巡回することになります。

変数`mark-ring'は、最新のマーカオブジェクトを先頭にして、マーカオブジェ
クトのリストとしてマークリングを保持します。この変数は各バッファにローカ
ルです。



File: emacs-ja.info, Node: Global Mark Ring, Prev: Mark Ring, Up: Mark

グローバルマークリング
======================

個々のバッファごとの普通のマークリングに加えて、Emacsには"グローバルマー
クリング"（global mark ring）が1つあります。グローバルマークリングは、最
近マークを設定したバッファの系列を記録しますから、それらのバッファに戻る
ことができます。

マークを設定すると、つねにカレントバッファのマークリングに項目を作ります。
マークを設定した以降にバッファを切り替えていると、新しくマークを設定する
とグローバルマークリングにも項目を作成します。その結果、グローバルマーク
リングには訪れていたバッファの系列が記録され、各バッファではマークを設定
した箇所が記録されます。

コマンド`C-x C-SPC'（`pop-global-mark'）は、グローバルマークリングの最新
の項目が示すバッファの位置に移動します。グローバルマークリングも巡回され
るので、`C-x C-SPC'を繰り返し使用すると、1つずつまえのバッファに移動でき
ます。




File: emacs-ja.info, Node: Killing, Next: Yanking, Prev: Mark, Up: Top

削除とキル
==========

バッファからテキストを消しさるコマンドのほとんどは、そのテキストをキルリ
ングにコピーしておくので、バッファの他の部分にそのテキストを移動したりコ
ピーしたりできます。これらのコマンドを、"キル"（kill）コマンドと呼びます。
それ以外の『テキストを消すコマンド』は、テキストをキルリングに保存しませ
ん。これらを"削除"（delete）コマンドと呼びます。（両者を区別するのは、バッ
ファ内のテキストを消す場合だけ。）キルコマンドや削除コマンドを誤って実行
してしまった場合には、`C-x u'（`undo'）コマンドを使って、もとに戻すこと
ができます。

削除コマンドには、一度に1つの文字だけを削除する`C-d'（`delete-char'）や
DEL（`delete-backward-char'）、空白や改行だけを削除するコマンドがありま
す。単純ではないデータをかなりの分量で破壊する可能性のあるコマンドは、一
般にキルを行います。コマンド名や個々の説明では、そのコマンドがどちらの働
きをするかによって、`キル'（kill）と`削除'（delete）を使い分けています。

* Menu:

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences. 



File: emacs-ja.info, Node: Deletion, Next: Killing by Lines, Up: Killing

削除
----

`C-d'
     つぎの文字を削除する（`delete-char'）。
`DEL'
     まえの文字を削除する（`delete-backward-char'）。
`M-\'
     ポイントの周りの空白とタブを削除する（`delete-horizontal-space'）。
`M-SPC'
     ポイントの周りの空白とタブを削除し、空白を1個だけ残す
     （`just-one-space'）。
`C-x C-o'
     現在行の周りの空行を削除する（`delete-blank-lines'）。
`M-^'
     行間の改行とそれに続く字下げを削除して2行を繋げる
     （`delete-indentation'）。

もっとも基本的な削除コマンドは、`C-d'（`delete-char'）とDEL
（`delete-backward-char'）です。`C-d'はポイントの直後の文字、つまり、カー
ソルが重なっている文字を削除します。このコマンドでは、ポイントは動きませ
ん。DELはカーソルの直前の文字を削除して、ポイントを1つまえに移動します。
バッファ内の他の文字と同様に、改行も削除できます。改行を削除すると、2つ
の行が繋がります。実際には、`C-d'とDELがつねに削除コマンドであるわけでは
ありません。引数を指定するとキルコマンドとなり、同じ方法で2文字以上を消
すことができます。

他の削除コマンドは、空白、タブ、改行といった白文字だけを削除します。
`M-\'（`delete-horizontal-space'）は、ポイントの前後にあるすべての空白と
タブ文字を削除します。`M-SPC'（`just-one-space'）も同様に削除しますが、
今ある空白の個数に関係なく（たとえ0個でも）、ポイントの直後に空白を1個だ
け残します。

`C-x C-o'（`delete-blank-lines'）は、現在行に続くすべての空行を削除しま
す。現在行が空行である場合には、（空行である現在行だけを残して）先行する
空行も同様にすべて削除します。

`M-^'（`delete-indentation'）は、改行とその周りの空白を削除して、通常は
空白を1個残して現在行と先行する行を繋げます。*Note M-^: Indentation。



File: emacs-ja.info, Node: Killing by Lines, Next: Other Kill Commands, Prev: Deletion, Up: Killing

行単位のキル
------------

`C-k'
     行の残りの部分、あるいは、行全体を1行以上キルする（`kill-line'）。

もっとも単純なキルコマンドは`C-k'です。行の先頭で使うと、その行のすべて
のテキストをキルして、空行にします。空行で使うと、改行を含めてその行を完
全にキルします。空行でない行を完全にキルするには、行頭で`C-k'を2回打ちま
す。

一般に、`C-k'は、行末でなければ、ポイントからその行の末尾までをキルしま
す。行末では、ポイントのうしろの改行をキルするので、現在行と後続の行が繋
がります。どちらの動作をするか決めるときには、行末にあって見にくい空白や
タブを無視しますから、ポイントが行末にあるように見えていれば、`C-k'で改
行がキルされると考えてください。

`C-k'に正の引数を指定すると、その個数の行とそれらに続く改行をキルします
（ただし、現在行のポイントよりまえのテキストは残す）。負の引数-Nを指定す
ると、`C-k'は現在行に先行するN行（と現在行のポイント位置よりまえのテキス
トを含めて）を削除します。つまり、ポイントが行頭にある状態で`C-u - 2
C-k'とすれば、先行する2行をキルします。

`C-k'に引数0を指定すると、現在行のポイントよりまえのテキストをキルします。

変数`kill-whole-line'が`nil'以外の場合、行頭で`C-k'を使うと、行末の改行
も含めて行全体をキルします。この変数は、通常、`nil'です。



File: emacs-ja.info, Node: Other Kill Commands, Prev: Killing by Lines, Up: Killing

他のキルコマンド
----------------

`C-w'
     リージョン（ポイントからマークまで）をキルする（`kill-region'）。
`M-d'
     単語をキルする（`kill-word'）。*Note Words::。
`M-DEL'
     単語を後向きにキルする（`backward-kill-word'）。
`C-x DEL'
     文の先頭までを後向きにキルする（`backward-kill-sentence'）。*Note
     Sentences::。
`M-k'
     文の末尾までをキルする（`kill-sentence'）。
`C-M-k'
     S式をキルする（`kill-sexp'）。*Note Lists::。
`M-z CHAR'
     つぎにCHARが現れる箇所までをキルする（`zap-to-char'）。

汎用的なキルコマンドといえば`C-w'（`kill-region'）です。このコマンドは、
あらかじめ連続領域をポイントとマークで囲んでおけば、どんな連続領域でもキ
ルできます。

探索と組み合わせた便利なキルの仕方もあります。`M-z'（`zap-to-char'）は1
文字を読み取り、ポイントからバッファ内でその文字がつぎに現れる箇所までを
（その文字も含めて）キルします。数引数を指定した場合は、反復回数を意味し
ます。負の引数の場合は、ポイント位置から逆方向に探索し、ポイントの直前ま
でをキルします。

他の構文単位でもキルできます。`M-DEL'や`M-d'（*Note Words::）で単語を、
`C-M-k'（*Note Lists::）でS式を、`C-x DEL'や`M-k'（*Note Sentences::）で
文をキルできます。

読み出し専用のバッファでもキルできます。実際にはバッファに変更を加えるこ
とはありませんし、ベルを鳴らしてその旨警告を発しますが、キルしようとした
テキストはキルリングにコピーされます。ですから、別のバッファにそのテキス
トをヤンクできます。ほとんどのキルコマンドは、このようにコピーするテキス
トを越えてポイントを進めますから、連続してキルコマンドを実行してもキルリ
ングに入る項目は通常どおり1個だけです。



File: emacs-ja.info, Node: Yanking, Next: Accumulating Text, Prev: Killing, Up: Top

ヤンク
======

"ヤンク"（yank）とは、以前にキルしたテキストをバッファにふたたび挿入する
ことです。他のシステムでは『ペースト』と呼ぶこともあります。テキストを移
動したりコピーしたりする普通の方法は、そのテキストをいったんキルしてから、
別の場所に（1回以上）ヤンクすることです。

`C-y'
     最後にキルしたテキストをヤンクする（`yank'）。
`M-y'
     たった今ヤンクしたテキストをそれより以前にキルした一塊のテキストで
     置き換える（`yank-pop'）。
`M-w'
     リージョンを実際にはキルせずに、最後にキルしたテキストとして保存す
     る（`kill-ring-save'）。
`C-M-w'
     つぎのキルを、最後にキルした一塊のテキストに付け加える
     （`append-next-kill'）。

* Menu:

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.



File: emacs-ja.info, Node: Kill Ring, Next: Appending Kills, Up: Yanking

キルリング
----------

すべてのキルされたテキストは、キルされたテキストの塊をリストとする"キル
リング"（kill ring）に記録されています。キルリングはたった1つしかなくて、
すべてのバッファで共有しています。ですから、あるバッファでキルしたテキス
トは、別のバッファでヤンクできます。普通、このようにして、あるファイルか
ら別のファイルへテキストを移動します。（別の方法については、*Note
Accumulating Text::。）

コマンド`C-y'（`yank'）は、最後にキルしたテキストをふたたび挿入します。
カーソルは挿入したテキストの末尾に置かれます。マークは挿入したテキストの
先頭に置かれます。*Note Mark::。

`C-u C-y'は、テキストのまえにカーソルを置き、うしろにマークを置きます。
引数として`C-u'だけを指定した場合に限り、こうなります。`C-u'と数字を含め
た他の引数を指定すると、いくつまえのキル内容をヤンクするかを意味します
（*Note Earlier Kills::）。

一塊のテキストをコピーする場合は、`M-w'（`kill-ring-save'）を使うとよい
でしょう。このコマンドは、バッファからリージョンをキルせずに、リージョン
をキルリングにコピーします。このコマンドは、`C-w'に続けて`C-x u'を実行す
るのとほぼ同等ですが、`M-w'はアンドゥ履歴を変更しませんし、一時的にせよ
画面表示も変わりません。



File: emacs-ja.info, Node: Appending Kills, Next: Earlier Kills, Prev: Kill Ring, Up: Yanking

キルしたテキストの追加
----------------------

通常、各キルコマンドは、キルリングに新たな項目を押し込みます。しかし、連
続したキルコマンドでは、それぞれでキルしたテキストを1つの項目にまとめま
す。そのため、1回の`C-y'で、キルするまえの状態に、それらのテキストをひと
まとめにヤンクできます。

したがって、テキストを一塊でヤンクしたい場合でも、1つのコマンドでそれら
をキルする必要はありません。すべてをキルするまで、1行ずつ、あるいは、1単
語ずつキルしていっても、一括してもとに戻すことができます。

ポイント位置から前向きにキルするコマンドでは、
直前にキルしたテキストの末尾に付け加えます。
ポイント位置から後向きにキルするコマンドでは、
テキストの先頭に付け加えます。
このように、前向き／後向きの両方のキルコマンドをどのように混ぜて実行しても、
キルしたテキストの順番を崩すことなく
1つの項目としてキルリングに記録されます。
数引数を指定しても、このような追加系列が途切れることはありません。
たとえば、バッファにつぎのテキストが入っていて、
-!-の位置にポイントがあるとしましょう。

     This is a line -!-of sample text.

`M-d M-DEL M-d M-DEL'と打って、前向き／後向きと交互にキルしても、キルリ
ングには1つの項目として`a line of sample'が入り、バッファには`This is
text.'が残ります。（空白が2個残っていることに注意。これらは`M-SPC'や
`M-q'で一掃できる。）

同じようにテキストをキルするもう1つの方法は、`M-b M-b'で後向きに2語移動
してから、`C-u M-d'で前向きに4語キルします。こうしても、バッファとキルリ
ングの中身は、先の例とまったく同じ結果になります。`M-f M-f C-u M-DEL'と
しても、後向きに同じテキストをキルします。これでもやはり同じ結果が得られ
ます。キルリングの項目内のテキストの順序は、キルするまえのバッファ内での
順序と同じです。

キルコマンドと最後のキルコマンドのあいだに（単なる数引数ではない）他のコ
マンドが入ると、キルリングには新たな項目が作られます。しかし、キルコマン
ドを打つ直前にコマンド`C-M-w'（`append-next-kill'）を打っておけば、既存
の項目へ追加するように強制できます。`C-M-w'は、つぎがキルコマンドであれ
ば、新たな項目を作成するかわりにキルしたテキストを以前にキルしたテキスト
に付け加えるよう指示します。`C-M-w'を使うことで、まとめて1か所にヤンクで
きるように、離れた場所にあるいくつかのテキスト断片をキルして集めておけま
す。

`M-w'に続くキルコマンドでは、`M-w'がキルリングにコピーしたテキストには付
け加えません。



File: emacs-ja.info, Node: Earlier Kills, Prev: Appending Kills, Up: Yanking

以前にキルしたテキストのヤンク
------------------------------

直前にキルしたものではないテキストを取り出すには、`M-y'コマンド
（`yank-pop'）を使います。`M-y'は、直前にヤンクしたテキストをそれ以前に
キルしたテキストで置き換えます。たとえば、最後から2つめのキルテキストを
取り出すには、まず`C-y'で最後にキルしたテキストをヤンクしてから、`M-y'で
1つまえのものに置き換えます。`M-y'は`C-y'や他の`M-y'の直後でしか使えませ
ん。

キルリング内の項目を指す『最終ヤンク』ポインタを考えると、`M-y'の動作を
理解しやすいでしょう。キルするたびに、『最終ヤンク』ポインタは、リングの
先頭に新たに作られた項目を指します。`C-y'は、『最終ヤンク』ポインタが指
す項目をヤンクします。`M-y'は、『最終ヤンク』ポインタを別の項目へ移動し、
それに合わせてバッファのテキストを変更します。`M-y'コマンドを繰り返せば
リング内のどの項目へもポインタを移動できるので、どの項目でもバッファに取
り込めます。ポインタがリングの最後に達すると、つぎの`M-y'はポインタをふ
たたびリングの先頭の項目に移動します。

`M-y'は、リング内で『最終ヤンク』ポインタを移動しますが、リング内の項目
の順番を変えることはありません。つねに、最後にキルしたものが先頭にあり、
記録に残っている最古のものが最後尾にあります。

`M-y'には数引数を指定できて、『最終ヤンク』ポインタをいくつ進めるかを指
定します。負の引数では、ポインタをリングの先頭に向けて移動します。リング
の先頭からは最後の項目へ移動し、そこから先頭に向けて移動します。

目的のテキストがバッファに入ったならば、`M-y'コマンドの繰り返しを止めれ
ば、みつけたテキストが残ります。そのテキストはキルリングの項目のコピーな
ので、バッファ内で編集してもリング内の項目は変わりません。新たにキルしな
い限り、『最終ヤンク』ポインタはキルリング内の同じ場所を指していますから、
`C-y'を繰り返すと、直前に取り込んだものと同じキル内容のコピーをヤンクで
きます。

目的のテキストを引き出すのに`M-y'コマンドを何回使えばよいのかわかってい
る場合には、数引数を指定して`C-y'を使えば、一発で目的のテキストをヤンク
できます。`C-y'に数引数を指定すると、キルリング内でその個数分だけ遡った
項目のテキストを取り込みます。たとえば、`C-u 2 C-y'は最後から2番目にキル
したテキストを取り込みます。つまり、`C-y M-y'とするのと等価です。数引数
を指定した`C-y'は、『最終ヤンク』ポインタの場所から数え始め、ヤンクする
項目にポイントを移動します。

キルリングの長さは、変数`kill-ring-max'で制御します。この個数以上のキル
テキストは保存しません。

キルリングの実際の内容は、`kill-ring'という名前の変数に入っています。キ
ルリングの全内容は、コマンド`C-h v kill-ring'で見ることができます。



File: emacs-ja.info, Node: Accumulating Text, Next: Rectangles, Prev: Yanking, Up: Top

テキストの蓄積
==============

通常、テキストをコピーしたり移動したりするにはキルとヤンクで行います。し
かし、一塊のテキストを何か所にもコピーしたり、多くの箇所に分散したテキス
トを1か所にコピーしたりするのに便利な方法が他にもあります。一塊のテキス
トを何か所にもコピーするには、そのテキストをレジスタに保存します（*Note
Registers::）。ここでは、何か所かに分散したテキストをバッファやファイル
に蓄積するためのコマンドを説明します。

`M-x append-to-buffer'
     リージョンを指定したバッファの内容の末尾に付加する。
`M-x prepend-to-buffer'
     リージョンを指定したバッファの内容の先頭に付加する。
`M-x copy-to-buffer'
     リージョンを指定したバッファにコピーするが、そのバッファの古い内容
     は削除する。
`M-x insert-buffer'
     指定したバッファの内容をカレントバッファのポイント位置に挿入する。
`M-x append-to-file'
     リージョンを指定したファイルの内容の末尾に付加する。

テキストをバッファに蓄積するには、`M-x append-to-buffer'を使います。これ
は、バッファ名を読み取り、リージョンのコピーを指定したバッファに挿入しま
す。存在しないバッファを指定した場合、`append-to-buffer'はバッファを作成
します。テキストは、そのバッファ内のポイント位置に挿入されます。バッファ
を編集用に使っている場合には、そのバッファ内のテキストのあいだ、その時点
のポイント位置にコピーしたテキストを挿入します。

コピー先のバッファ内では、ポイントはコピーされたテキストの末尾に置かれま
す。したがって、連続して`append-to-buffer'を使うと、コピーした順序でバッ
ファにテキストが蓄積されます。厳密には、`append-to-buffer'は、バッファ内
の既存のテキストに追加するとは限りません。そのバッファの末尾にポイントが
ある場合に限り、追加します。しかし、バッファを変更するコマンドが
`append-to-buffer'だけならば、ポイントはつねに末尾に置かれています。

`M-x prepend-to-buffer'は`append-to-buffer'にとてもよく似ていますが、コ
ピー先のバッファ内のポイントは、コピーしたテキストの直前に置かれる点が異
なります。つまり、続けてこのコマンドを使うと、テキストは逆順に追加されて
いきます。`M-x copy-to-buffer'も同様ですが、指定したバッファ内の既存のテ
キストを削除します。したがって、バッファには新たにコピーしたテキストだけ
が残ります。

別のバッファに蓄積したテキストを取り出すには、コマンド`M-x
insert-buffer'を使います。このコマンドも引数としてBUFFERNAMEを必要としま
す。バッファBUFFERNAME内のテキストのコピーを選択しているバッファに挿入し
ます。あるいは、そのバッファを選択して編集し、場合によってはキルしてその
バッファからテキストを移動することもできます。バッファに関する背景情報は、
*Note Buffers::。

テキストをEmacsのバッファに蓄積するかわりに、`M-x append-to-file'を使っ
て、テキストを直接ファイルに追加できます。このコマンドは引数として
FILENAMEを必要とします。リージョンのテキストを指定したファイルの末尾に追
加します。ファイルはディスク上でただちに更新されます。

このコマンドに指定するファイルは、Emacsで訪問して*いない*ファイルだけに
限るべきです。Emacsで編集中のファイルを指定すると、Emacsに隠れてファイル
を変更することになり、編集内容の一部を失うことにもなりかねません。



File: emacs-ja.info, Node: Rectangles, Next: Registers, Prev: Accumulating Text, Up: Top

矩形領域
========

矩形領域コマンドはテキストの矩形領域を操作します。矩形領域のテキストとは、
2つの行の範囲内にある2つの桁位置のあいだにある文字すべてを指します。矩形
領域をキルする、キルした矩形領域をヤンクする、矩形領域をクリアする、矩形
領域を空白やテキストで充填する、矩形領域を削除する、といったコマンドがあ
ります。矩形領域コマンドは、複数段に組んだテキストを操作したり、テキスト
をそのように組んだり戻したりする場合に便利です。

コマンドで操作する矩形領域を指定するには、一方の隅にマークを設定し、その
対角にポイントを置きます。このように設定した矩形領域を"矩形リージョン" 
（region-rectangle）と呼びます。というのも、リージョンの制御と似た方法で
矩形領域を制御できるからです。しかし、ポイントとマークの組は、それを使う
コマンドに依存して、リージョンとして解釈される、あるいは、矩形領域として
解釈されることに注意してください。

ポイントとマークが同じ桁位置にある場合、それらが切り分ける矩形領域は空で
す。同じ行上にある場合は、矩形領域の高さは1行です。桁と行の扱い方が非対
称であるのは、ポイント（同様にマーク）は2つの桁のあいだにあるのに対し、
行ではその中にあるからです。

`C-x r k'
     矩形リージョンのテキストをキルし、その内容を『最後にキルした矩形領
     域』として保存する（`kill-rectangle'）。
`C-x r d'
     矩形リージョンのテキストを削除する（`delete-rectangle'）。
`C-x r y'
     最後にキルした矩形領域をポイント位置を左上隅としてヤンクする
     （`yank-rectangle'）。
`C-x r o'
     空白で埋めた矩形リージョンを挿入する（`open-rectangle'）。矩形リー
     ジョンの直前の内容は右に押しやられる。
`M-x clear-rectangle'
     矩形リージョンのすべてのテキストを空白で置き換えて、内容をクリアす
     る。
`M-x delete-whitespace-rectangle'
     指定した矩形領域の各行において、矩形領域の左端から白文字を削除する。
`C-x r t STRING RET'
     指定した矩形領域の各行にSTRINGを挿入する（`string-rectangle'）。

矩形操作は2種類に分類できます。矩形領域を削除したり挿入したりするコマン
ドと、空白の矩形領域を扱うコマンドです。

矩形領域内のテキストを消すには、2つの方法があります。テキストを捨てる
（削除する）か、『最後にキルした』矩形領域として保存するかです。これらの
機能を実現するコマンドは、`C-x r d'（`delete-rectangle'）と`C-x r k'
（`kill-rectangle'）です。どちらも、矩形領域の内側にある各行の部分を削除
し、それより右側にテキストがあれば、隙間を埋めるようにそれらを左へ移動し
ます。

矩形領域の『キル』は普通の意味でのキルではない、ということに注意してくだ
さい。矩形領域はキルリングには保存されませんが、最後にキルした矩形領域を
1つだけ記録できる特別な場所に保存されます。というのは、矩形領域をヤンク
することは、線形のテキストのヤンクとは大きく異なり、特別なヤンクコマンド
が必要だったり、ヤンクしたテキストの入れ換え操作が意味をなさなかったりす
るからです。

最後にキルした矩形領域をヤンクするには、`C-x r y'（`yank-rectangle'）と
打ちます。矩形領域のヤンクは矩形領域のキルの逆です。ポイントは矩形領域の
左上隅の位置を指定します。その場所には矩形領域の1行目が挿入され、矩形領
域の2行目はそのつぎの行にというように挿入されます。影響される行数は、保
存されている矩形領域の高さで決まります。

矩形領域のキルとヤンクを使うと、1段組みの一覧表を2段組の一覧表に変換でき
ます。一覧表の後半を矩形領域としてキルして、一覧表の第1行の隣にヤンクす
ればよいのです。

また、`C-x r r R'や`C-x r i R'を使えば、矩形領域をレジスタにコピーしたり、
レジスタから矩形領域をコピーしたりできます。*Note Rectangle Registers:
RegRect。

空白の矩形領域を作るコマンドは2つあります。`M-x clear-rectangle'は既存の
テキストを空白で置き換え、`C-x r o'（`open-rectangle'）は空白の矩形領域
を挿入します。矩形領域をクリアすることは、矩形領域を削除してから同じ大き
さの空白の矩形領域を挿入するのと同じことです。

コマンド`M-x delete-whitespace-rectangle'は、特定の桁位置から始まる横に
並んだ白文字を削除します。矩形領域内の各行に作用し、桁位置は矩形領域の左
端です。矩形領域の右端はこのコマンドには関係ありません。

コマンド`C-x r t'（`M-x string-rectangle'）は、矩形領域を指定した文字列
で置き換えます。文字列の幅は、矩形領域の幅と同じである必要はありません。
文字列の幅が足りなければ、矩形領域の右側にあるテキストは左へ移動します。
文字列の幅が広ければ、矩形領域の右側にあるテキストは右へ移動します。


File: emacs-ja.info, Node: Registers, Next: Display, Prev: Rectangles, Up: Top

レジスタ
********

Emacsの"レジスタ"（registers）は、あとで使うためにテキストやポイント位置
を保存するための場所です。テキストや矩形領域をレジスタにいったん保存すれ
ば、何度でもバッファにコピーできます。また、レジスタに保存した位置には何
度でもポイントを移動できます。

各レジスタには1文字の名前が付いています。レジスタには、テキストの一部、
矩形領域、位置、ウィンドウの構成情報、ファイル名を保存できますが、1度に
はそのうちの1つしか保存できません。レジスタに保存した内容は、そのレジス
タに他のものを保存するまでは保持され続けます。レジスタRに何が入っている
か調べるには、`M-x view-register'を使います。

`M-x view-register RET R'
     レジスタRの内容を表示する。

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.



File: emacs-ja.info, Node: RegPos, Next: RegText, Up: Registers

レジスタに位置を保存する
========================

位置を保存するとは、あとで戻ってこられるようにバッファ中の位置を記録する
ことです。保存した位置に移動すると、そのバッファに切り替えてからポイント
をその位置に移動します。

`C-x r SPC R'
     ポイント位置をレジスタRに保存する（`point-to-register'）。
`C-x r j R'
     レジスタRに保存した位置に移動する（`jump-to-register'）。

ポイントの現在位置をレジスタに保存するには、名前Rを選んでから、`C-x r
SPC R'と打ちます。他のものを保存するまで、レジスタRはこうして保存した位
置を保持し続けます。

コマンド`C-x r j R'は、レジスタRに記録した位置にポイントを移動します。レ
ジスタは変わらず、同じ位置を記録し続けます。何度でも保存した位置に移動で
きます。

`C-x r j'を使って保存位置に移動しようとしたとき、その対象となるバッファ
がすでに消去されていた場合には、`C-x r j'は同じファイルを訪問するバッファ
を作成し直そうとします。もちろん、これはファイルを訪問したバッファに対し
てのみ働きます。



File: emacs-ja.info, Node: RegText, Next: RegRect, Prev: RegPos, Up: Registers

レジスタにテキストを保存する
============================

テキストの同じ部分のコピーを頻繁に挿入する場合、キルリングからヤンクする
のは便利ではないでしょう。というのは、キルするごとに、必要な部分がリング
の下方に徐々に移動してしまうからです。別の手段としては、レジスタにテキス
トを保存しておき、レジスタから取り込むという方法があります。

`C-x r s R'
     レジスタRにリージョンをコピーする（`copy-to-register'）。
`C-x r i R'
     レジスタRからテキストを挿入する（`insert-register'）。

`C-x r s R'は、リージョンのテキストのコピーをRという名前のレジスタに保存
します。`C-x r s R'に数引数を指定すると、保存すると同時にバッファからテ
キストを削除します。

`C-x r i R'はレジスタRからテキストをバッファに挿入します。通常、テキスト
の直前にポイントを置き、直後にマークを置きます。しかし、数引数（`C-u'）
を指定すると、テキストの直後にポイントを置き、直前にマークを置きます。



File: emacs-ja.info, Node: RegRect, Next: RegConfig, Prev: RegText, Up: Registers

レジスタに矩形領域を保存する
============================

レジスタには、連続したテキスト以外にも、矩形領域を保持できます。矩形領域
は、文字列のリストとして表されます。バッファ内での矩形領域の指定方法に関
する基礎情報については、*Note Rectangles::。

`C-x r r R'
     矩形領域をレジスタRにコピーする（`copy-rectangle-to-register'）。数
     引数を指定すると、コピー後に矩形領域を削除する。
`C-x r i R'
     レジスタRに保存した矩形領域（が存在すればそれ）を挿入する
     （`insert-register'）。

`C-x r i R'コマンドは、レジスタにテキストが入っていれば、そのテキストの
文字列を挿入しますし、矩形領域があれば矩形領域を挿入します。

コマンド`sort-columns'も参照してください。このコマンドは矩形領域をソート
すると考えられます。*Note Sorting::。



File: emacs-ja.info, Node: RegConfig, Next: RegNumbers, Prev: RegRect, Up: Registers

レジスタにウィンドウ構成を保存する
==================================

選択したフレームのウィンドウ構成をレジスタに保存したり、すべてのフレーム
のすべてのウィンドウ構成を保存したりできて、しかも、あとでその構成に戻せ
ます。

`C-x r w R'
     選択したフレームのウィンドウの状態をレジスタRに保存する
     （`window-configuration-to-register'）。
`C-x r f R'
     全フレームの状態を、各フレームのすべてのウィンドウを含めて、レジス
     タRに保存する（`frame-configuration-to-register'）。

ウィンドウやフレームの構成をもとに戻すには、`C-x r j R'を使います。これ
は、カーソル位置を復元するコマンドと同じです。フレームの構成を復元すると、
構成情報に含まれていない既存のフレームは隠れた状態になります。これらのフ
レームを削除したければ、`C-u C-x r j R'を使います。



File: emacs-ja.info, Node: RegNumbers, Next: RegFiles, Prev: RegConfig, Up: Registers

レジスタに数値を保持する
========================

レジスタに数値を保存しておき、数値を10進数でバッファに挿入してから数値を
増やすコマンドがあります。これらのコマンドは、キーボードマクロで役立ちま
す（*Note Keyboard Macros::）。

`C-u NUMBER C-x r n REG'
     数値NUMBERをレジスタREGに保存する（`number-to-register'）。
`C-u NUMBER C-x r + REG'
     レジスタREG内の数値をNUMBERだけ増やす（`increment-register'）。
`C-x r g REG'
     レジスタREGの数値をバッファに挿入する。

`C-x r g'は、レジスタの数値以外の内容をバッファに挿入するために使うコマ
ンドと同じです。



File: emacs-ja.info, Node: RegFiles, Next: Bookmarks, Prev: RegNumbers, Up: Registers

レジスタにファイル名を保持する
==============================

特定のファイル名を頻繁に訪問する場合には、これらの名前をレジスタに置いて
おくと、より簡単にファイルを訪問できます。ファイル名をレジスタに置くLisp
コードをつぎに示します。

     (set-register ?R '(file . NAME))

たとえば、

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

とすると、上に示したファイル名をレジスタ`z'に保存します。

レジスタRに入れた名前のファイルを訪問するには、`C-x r j R'と打ちます。
（このコマンドは、保存位置に移動したりフレーム構成を復元するために使うコ
マンドと同じ。）



File: emacs-ja.info, Node: Bookmarks, Prev: RegFiles, Up: Registers

ブックマーク
============

"ブックマーク"（bookmarks）とは、移動先の位置を記録しておくためのレジス
タのようなものです。レジスタと違って、長い名前を付けることができて、自動
的につぎのEmacsセッションに引き継がれます。ブックマークの典型的な使い方
は、各ファイルの『どこを読んでいるか』を記録しておくことです。

`C-x r m RET'
     訪問先のファイルのポイント位置にブックマークを設定する。

`C-x r m BOOKMARK RET'
     ポイント位置に、BOOKMARKという名前のブックマークを設定する
     （`bookmark-set'）。

`C-x r b BOOKMARK RET'
     名前がBOOKMARKであるブックマークに移動する（`bookmark-jump'）。

`C-x r l'
     すべてのブックマークを一覧表示する（`list-bookmarks'）。

`M-x bookmark-save'
     現在のすべてのブックマークの値をデフォルトのブックマークファイルに
     保存する。

ブックマークの典型的な使い方は、各ファイルごとに現在のポイント位置を保存
しておくことです。ブックマークを設定するコマンド`C-x r m'は、訪問先のファ
イルの名前をブックマーク名のデフォルトとして使います。ブックマークが指す
ファイルをもとにブックマークの名前を付ければ、`C-x r b'で任意のファイル
を再訪問して、同時にブックマーク位置に移動するという操作を楽に行えます。

設定したすべてのブックマークの一覧を別のバッファに表示するには、`C-x r
l'（`list-bookmarks'）と打ちます。そのバッファに切り替えれば、ブックマー
クの定義を編集したり、ブックマークに注記を付けたりできます。このバッファ
で使える特別な編集コマンドについての情報を得るには、このバッファで`C-h
m'と打ちます。

内容を変更したブックマークがある場合、Emacsを終了する時点で、Emacsはブッ
クマークの値をデフォルトのブックマークファイル`~/.emacs.bmk'に保存するか
どうか聞いてきます。`M-x bookmark-save'コマンドを使っても、変更したブッ
クマークをいつでも保存できます。ブックマークコマンドは、個人のデフォルト
のブックマークファイルを自動的に読み込みます。これらの保存と読み込みによっ
て、ブックマークの内容をつぎのEmacsセッションに引き継げるのです。

変数`bookmark-save-flag'に1を設定しておくと、ブックマークを設定する各コ
マンドは、ブックマークの保存も行います。こうしておけば、Emacsがクラッシュ
した場合でも、ブックマークデータを失わなくてすみます。（この変数の値が数
値であれば、ブックマークを何回変更したら保存するという意味。）

ブックマークの位置情報は、その周辺の文脈情報と一緒に保存されるので、ファ
イルが少し変更されていたとしても、`bookmark-jump'は正しい位置をみつけだ
せます。変数`bookmark-search-size'で、ブックマーク位置の前後何文字分の内
容を保存するかを指定します。

ブックマークを用いるコマンドには、以下のものもあります。

`M-x bookmark-load RET FILENAME RET'
     ブックマークデータのリストを収めたFILENAMEという名前のファイルをロー
     ドする。デフォルトのブックマークファイル以外のブックマークデータを
     収めたファイルに対しても、コマンド`bookmark-write'と同じく、このコ
     マンドを使える。

`M-x bookmark-write RET FILENAME RET'
     現在設定されているブックマークデータをファイルFILENAMEに保存する。

`M-x bookmark-delete RET BOOKMARK RET'
     BOOKMARKという名前のブックマークを削除する。

`M-x bookmark-insert-location RET BOOKMARK RET'
     ブックマークBOOKMARKが指しているファイルの名前をバッファに挿入する。

`M-x bookmark-insert RET BOOKMARK RET'
     ブックマークBOOKMARKが指すファイルの*内容*をバッファに挿入する。


File: emacs-ja.info, Node: Display, Next: Search, Prev: Registers, Up: Top

画面の制御
**********

大きなバッファの一部しかウィンドウには収まりませんから、Emacsは必要そう
な部分を表示しようとします。画面制御コマンドを使って、テキストのどの部分
を表示したいのか、また、どのように表示するか指定できます。

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Display Vars::           Information on variables for customizing display.



File: emacs-ja.info, Node: Scrolling, Next: Horizontal Scrolling, Up: Display

スクロール
==========

バッファを表示しているウィンドウに全部を表示するには大きすぎるテキストが
入っているバッファでは、Emacsはテキストの連続する一部分を表示します。表
示する部分にはつねにポイントが入っています。

"スクロール"（scroll）とは、ウィンドウ内でテキストを上下に動かして、テキ
ストの異なる部分を表示することです。前向きのスクロールでは、テキストを上
へ移動して、新たなテキストがウィンドウの最下端から現れます。後向きのスク
ロールでは、テキストを下に移動して、新たなテキストがウィンドウの最上端か
ら現れます。

ポイントをウィンドウの下端や上端を超えて移動すると、自動的にスクロールし
ます。本節で紹介するコマンドを使って、明示的にスクロールすることもできま
す。

`C-l'
     画面をクリアして再表示し、選択されたウィンドウではポイントが縦方向
     の中央に位置するようにスクロールする（`recenter'）
`C-v'
     （ウィンドウ1面分か指定した行数だけ）前向きにスクロールする
     （`scroll-up'）。
`NEXT'
     同様に前向きにスクロールする。
`M-v'
     後向きにスクロールする（`scroll-down'）。
`PRIOR'
     同じく後向きにスクロールする。
`ARG C-l'
     ポイントがARG行目にくるようにスクロールする（`recenter'）。
`C-M-l'
     有益な情報が画面上にくるように発見的方法でスクロールする
     （`reposition-window'）。

もっとも基本的なスクロールコマンドは、引数を指定しない`C-l'（`recenter'）
です。このコマンドは、画面全体をクリアして、すべてのウィンドウを再表示し
ます。さらに、ポイントがウィンドウの中央の行に位置するように、選択されて
いるウィンドウをスクロールします。

スクロールコマンド`C-v'と`M-v'は、ウィンドウ内の全テキストを上下に何行か
移動します。`C-v'（`scroll-up'）に引数を指定すると、`C-l'と同じようにテ
キストとポイントを一緒に上へ移動して、追加分（引数分）の行をウィンドウの
下部に表示します。`C-v'に負の引数を指定した場合は、ウィンドウの上端に追
加分の行を表示します。`M-v'（`scroll-down'）は`C-v'に似ていますが、スク
ロール方向が逆です。ファンクションキーのNEXTとPRIORは、`C-v'と`M-v'に等
価です。

スクロールコマンドの名前は、ウィンドウ内でテキストを動かす向きに基づいて
います。したがって、前向きにスクロールするコマンドは、画面上ではテキスト
を上へ移動するため、`scroll-up'と呼ばれます。

一度にウィンドウ1面分のバッファを読んでいくには、引数を指定せずに`C-v'を
使います。ウィンドウの下端2行を上端に持っていき、それに続けてこれまで表
示されていなかったほぼウィンドウ1面分の行を表示します。ポイントがウィン
ドウの上端より上に出てしまう場合には、ポイントはウィンドウの新たな上端の
行に移動します。引数を指定しない`M-v'も同様に、テキストを重複させながら、
後向きに移動します。`C-v'や`M-v'で重複させる行数は、変数
`next-screen-context-lines'で制御します。デフォルトでは2です。

画面上でのポイント位置を保ったまま1画面分のスクロールを行うコマンドを好
むユーザーもいます。このようにするには、変数
`scroll-preserve-screen-position'に`nil'以外を設定します。このモードは、
1画面分ずつスクロールしながらファイルを閲覧するような場合に便利です。ス
クロールを始めた画面に戻ると、ポイントは開始時の行位置に戻ります。しかし、
つぎの画面に移動して、そこに表示されているテキストにポイントを移動するよ
うな使い方にはむいていません。

スクロールのもう1つの方法は、数引数を指定した`C-l'を使うことです。引数を
指定すると、`C-l'は画面をクリアしません。選択されているウィンドウだけを
スクロールします。正の引数Nを指定すると、ポイント位置が上端からN行目にく
るように、テキストの位置を変更します。引数として0を指定すると、ポイント
位置は最上端の行になります。ポイントがテキストに対して動くわけではなくて、
テキストとポイントは一緒に画面上を動きます。`C-l'に負の引数を指定すると、
ポイントはウィンドウの下端から指定行数にきます。たとえば、`C-u - 1 C-l'
とするとポイントは最下行になり、`C-u - 5 C-l'とすれば下から5行目にポイン
トがきます。`C-u C-l'のように`C-u'だけを引数に指定すると、ポイントが画面
中央にくるようにスクロールします。

`C-M-l'コマンド（`reposition-window'）は、有益な情報を画面上に持ってくる
ようにように設計された発見的手法で、カレントウィンドウをスクロールします。
たとえば、Lispファイルでは、このコマンドは、可能であれば現在の関数定義
（defun）全体を画面上にもってこようとします。

表示の際、ポイントがテキストの表示部分から飛び出してしまうと、自動的にス
クロールします。通常、この自動スクロールでは、ポイントがウィンドウ縦方向
の中央に位置するように画面を移動します。しかし、`scroll-conservatively'
に小さな数Nを設定しておくと、ポイントが画面から少しだけ（N行未満）はみだ
すと、Emacsはポイントを画面内に戻すのに必要な分だけスクロールします。デ
フォルトでは、`scroll-conservatively'は0です。

変数`scroll-margin'は、ポイントをウィンドウの上端や下端にどれだけ近づけ
られるかを制限します。その値は画面上での行数です。ポイントがウィンドウの
上端や下端からその行数以内にくると、Emacsはウィンドウを中央に位置付けし
直します。デフォルトでは、`scroll-margin'は0です。



File: emacs-ja.info, Node: Horizontal Scrolling, Next: Follow Mode, Prev: Scrolling, Up: Display

水平スクロール
==============

"水平スクロール"（horizontal scrolling）とは、すべての行をウィンドウ内で
横方向に動かすことです。これにより、左端近くのテキストは表示されなくなり
ます。

`C-x <'
     カレントウィンドウのテキストを左にスクロールする（`scroll-left'）。
`C-x >'
     右にスクロールする（`scroll-right'）。

ウィンドウが水平方向にスクロールされているときには、テキスト行を継続
（*Note Continuation Lines::）しないで切り捨てます。テキストの左側を切り
捨てているときは最初の桁に`$'を表示し、右側を切り捨てているときには最後
の桁に`$'を表示します。

コマンド`C-x <'（`scroll-left'）は、選択されたウィンドウを引数Nの桁数だ
け左にスクロールします。各行の最初の部分はウィンドウの左端から出てしまい
ます。引数を指定しないと、ほぼウィンドウ幅（正確には2桁少ない桁数）だけ
スクロールします。

`C-x >'（`scroll-right'）は、同様に右にスクロールします。
ウィンドウが（各行がウィンドウの左端から始まっている）通常の表示をしていると、
それ以上はスクロールできません。
スクロールさせようとしても何も起こりません。
つまり、`C-x >'に与える引数を正確に計算する必要はないのです。
十分に大きな引数を指定すれば、通常の表示に戻せます。

水平スクロール（hscroll）モードをオンにすると、自動的に水平スクロールを
行います。このモードがオンであると、ポイントが左右端から離れすぎない場所
に見えるようにEmacsが水平方向にウィンドウをスクロールします。このモード
のオン／オフを切り替えるコマンドは、`M-x hscroll-mode'です。



File: emacs-ja.info, Node: Follow Mode, Next: Selective Display, Prev: Horizontal Scrolling, Up: Display

追従モード
==========

"追従（follow）モード"は、同じバッファを表示している2つのウィンドウを、1
つの『仮想ウィンドウ』としてスクロールするマイナモードです。追従（follow）
モードを使うには、ウィンドウが1つだけのフレームに移動して、`C-x 3'を使っ
て左右に並んだ2つのウィンドウに分割してから、`M-x follow-mode'と打ちます。
これ以後、いずれのウィンドウのバッファでも編集できますし、どちらをスクロー
ルしてもかまいません。もう一方のウィンドウは他方に追従します。

追従（follow）モードをオフにするには、もう一度`M-x follow-mode'を打ちま
す。



File: emacs-ja.info, Node: Selective Display, Next: Optional Mode Line, Prev: Follow Mode, Up: Display

選択的な表示
============

Emacsには、（指定した）桁数以上字下げしてある行を隠す機能があります。プ
ログラムの一部を概観するのにこの機能を使えます。

行を隠すには、数引数Nを指定して`C-x $' （`set-selective-display'）と打ち
ます。これにより、N桁以上字下げしてある行は画面から消えます。1行以上の不
可視行に先行する可視行の末尾には、3つのドット（`...'）を表示します。この
印が不可視行の存在を示す唯一のものです。

コマンド`C-n'や`C-p'は、不可視行が存在しないかのように不可視行を飛び越え
て移動します。

不可視行は依然としてバッファ内に存在しています。たいていの編集コマンドは
それらを通常と同じように扱うので、隠蔽されたテキスト内にポイントを移動し
てしまうことも起こりえます。このような場合、カーソルは先行する行の末尾の
3つのドットの直後に表示されます。ポイントが可視行の行末の改行文字の直前
にあるときには、3つのドットの直前にカーソルが現れます。

すべての行をふたたび表示するには、引数を指定せずに`C-x $'を打ちます。

変数`selective-display-ellipses'に`nil'を設定すると、不可視行に先行する
可視行の末尾には3つのドットを表示しなくなります。すると、不可視行の存在
を示すものは何もありません。この変数を設定すると、自動的にローカルになり
ます。



File: emacs-ja.info, Node: Optional Mode Line, Next: Text Display, Prev: Selective Display, Up: Display

モード行の付加機能
==================

行番号（line-number）モードがオンであると、ポイントの現在の行番号をモー
ド行に表示します。このモードのオン／オフを切り替えるには、コマンド`M-x
line-number-mode'を使います。通常はオンです。行番号は、バッファの百分率
を示すPOSのまえに、行番号であること示す文字`L'とともに表示されます。マイ
ナモードやこのコマンドの使用方法について詳しくは、*Note Minor Modes::。

バッファが非常に大きい（`line-number-display-limit'の値以上に大きい）場
合には、この行番号を表示しません。計算が非常に遅くなるので、バッファが大
きい場合にはEmacsは行番号を計算しません。バッファをナロイング（*Note
Narrowing::）してある場合、表示される行番号はバッファの参照可能な部分に
対するものです。

桁番号（column-number）モードをオンにすると、現在の桁番号も表示できます。
このモードでは、`C'に続けて現在の桁番号を表示します。このモードのオン／
オフを切り替えるには、`M-x column-number-mode'と打ちます。

Emcasでは、すべてのモード行に、時刻とシステムの負荷状況を表示できます。
この機能をオンにするには、`M-x display-time'と打ちます。このときモード行
に追加される情報は、通常は、バッファ名のあと、括弧で囲まれたモード名のま
えに表示されます。その表示はつぎのようになります。

     HH:MMpm L.LL

ここで、HHとMMは、時分を表し、つねに`am'か`pm'が続きます。L.LLは、システ
ム全体で実行中のプロセスの個数の最近の平均数です。（オペレーティングシス
テムが情報を提供しなければ、いくつかの内容が消えていることもある。）時刻
を24時間表示したければ、変数`display-time-24hr-format'に`t'を設定します。

負荷レベル表示に続く語`Mail'は、未読のメイルがある場合に表示されます。



File: emacs-ja.info, Node: Text Display, Next: Display Vars, Prev: Optional Mode Line, Up: Display

テキストの表示方法
==================

Emacsバッファ内のASCII印字文字（8進コードで040から0176）は、それぞれの図
形で表示されます。非ASCIIのマルチバイトの印字文字（8進コード0400以上）も
同様です。

ASCIIコントロール文字の中には、特別な方法で表示されるものもあります。改
行文字（8進コード012）は、新たな行を始めるという形で表示されます。タブ文
字（8進コード011）は、つぎのタブストップ位置（通常は8桁ごと）まで移動す
るという形で表示されます。

その他のASCIIコントロール文字は、通常、カレット（`^'）に続けてコントロー
ル変種でない文字で表示されます。つまり、control-Aは`^A'のように表示され
ます。

0200から0377までの非ASCII文字は、8進のエスケープシーケンスで表示されます。
たとえば、文字コード0243（8進）は、`\243'と表示されます。しかし、ヨーロッ
パ向けの表示をオンにしていると、これらのたいていの文字は非ASCII印字文字
として扱われ、（端末がこれらの文字を表示できると仮定して）それぞれの図形
で表示されます。*Note Single-Byte European Support::。



File: emacs-ja.info, Node: Display Vars, Prev: Text Display, Up: Display

表示を制御する変数
==================

本節は、カスタマイズに関する情報のみです。初心者の方は読み飛ばしてくださ
い。

変数`mode-line-inverse-video'は、（端末が反転表示を扱えると仮定して）モー
ド行を反転表示するかどうかを制御します。`nil'は反転表示しないことを意味
します。*Note Mode Line::。`modeline'フェイスに前景色を指定していて、し
かも、`mode-line-inverse-video'が`nil'以外であれば、`modeline'フェイスの
デフォルトの背景色は通常の前景色です。*Note Faces::。

変数`inverse-video'が`nil'以外である場合、Emacsは画面上のすべての行を通
常の状態から反転表示します。

変数`visible-bell'が`nil'以外の場合、Emacsは、通常は端末のベルを鳴らす場
面では、画面全体を点滅します。端末に画面を点滅する機能がなければ、この変
数は何の効果もありません。

Emacsを休止したあとで再開した場合、通常Emacsは画面をクリアし、画面全体を
再表示します。ページメモリを複数個備えた端末では、termcapの定義を変更し
て、（それぞれ、Emacsを起動するときと抜けるときに端末に出力される）文字
列`ti'と`te'でページメモリを切り替えて、1ページをEmacs用に使い、もう1ペー
ジを他の出力用に使うようにできます。そして、変数`no-redraw-on-reenter'に
`nil'以外を設定します。こうすると、Emacsは、再開時には最後に出力した内容
が画面ページに入っているものと仮定します。

変数`echo-keystrokes'は、複数個の文字キーのエコーを制御します。設定する
値は、エコーを開始するまでの待機時間の秒数です。ゼロを指定するとエコーし
ません。*Note Echo Area::。

変数`ctl-arrow'に`nil'を設定すると、改行とタブを除いて、バッファ内のコン
トロール文字を8進のエスケープシーケンスで表示します。変数`ctl-arrow'の値
を変更すると、この変数はカレントバッファにローカルになります。それまでは、
デフォルトの値が使われます。デフォルトの初期値は`t'です。*Note 表示テー
ブル: (elisp)Display Tables。

通常、バッファ内のタブ文字は、つぎのタブストップ位置までの空白として表示
され、タブストップは8個分の空白と同じ間隔です。タブ1個あたりの空白の文字
数は、変数`tab-width'で制御します。この変数も`ctl-arrow'と同様に、変更す
るとバッファにローカルになります。バッファ内のタブ文字をどのように表示す
るかと、コマンドとしてのTABの定義とは無関係であることに注意してください。
変数`tab-width'の値は1以上1000以下の整数である必要があります。

変数`truncate-lines'に`nil'以外を設定すると、テキストの各行は表示上は画
面の1行を占有します。テキスト行が長すぎる場合は、画面に収まる範囲だけを
表示します。一方、`truncate-lines'に`nil'を設定すると、長いテキスト行は、
画面上では2行以上にわたってテキスト行の表示に必要なだけの行数で表示され
ます。*Note Continuation Lines::。変数`truncate-lines'の値を変更すると、
カレントバッファにローカルになります。それまでは、デフォルトが使われます。
デフォルトの初期値は`nil'です。

変数`truncate-partial-width-windows'に`nil'以外を設定すると、画面やフレー
ムの幅に満たないウィンドウでは、テキストの表示方法は`truncate-lines'の値
とは無関係に、継続行ではなく切り捨てて表示します。左右に並べたウィンドウ
に関しては、*Note Split Window::。*Note Emacsの画面表示: (elisp)Display
も参照してください。

変数`baud-rate'は、Emacsにとっての端末の出力速度を保持します。この変数の
値を設定したとしても、実際のデータ転送速度を変更できるわけではなく、この
値はパディングの計算などに用いられます。さらに、ウィンドウシステムを使用
している場合であっても、画面の一部をスクロールするのか、再表示するのかの
決定にも影響します。（ウィンドウシステムには正しい『出力速度』がないにし
ても、スクロール／再表示を調整できるようにこのように設計してある。）

どんな文字コードの表示方法も、表示テーブルを用いてカスタマイズできます。
*Note 表示テーブル: (elisp)Display Tables。


File: emacs-ja.info, Node: Search, Next: Fixit, Prev: Display, Up: Top

探索と置換
**********

他のエディタと同様に、Emacsにも文字列を探索するコマンドがあります。主な
探索コマンドが"インクリメンタル"（incremental）であるという点で、普通と
は違います。探索したい文字列全体を入力し終えなくても、探索を始めます。他
のエディタの探索コマンドのように、インクリメンタルでない探索コマンドもあ
ります。

指定した文字列の出現すべてを探し出して別の文字列に置換する、普通の置換コ
マンド`replace-string'に加えて、Emacsにはより高級な、出現箇所をみつける
たびに置換するかどうか対話的に尋ねる問い合わせ型置換コマンド
`query-replace'もあります。

* Menu:

* Incremental Search::	   Search happens as you type the string.
* Nonincremental Search::  Specify entire string and then search.
* Word Search::		   Search for sequence of words.
* Regexp Search::	   Search for match for a regexp.
* Regexps::		   Syntax of regular expressions.
* Search Case::		   To ignore case while searching, or not.
* Replace::		   Search, and replace some or all matches.
* Other Repeating Search:: Operating on all matches for some regexp.



File: emacs-ja.info, Node: Incremental Search, Next: Nonincremental Search, Prev: Search, Up: Search

インクリメンタルサーチ
======================

インクリメンタルサーチでは、探索文字列の最初の文字を打つとただちに探索を
開始します。探索文字列を入力するたびに、Emacsは（それまでに入力した）文
字列がどこでみつかるか表示します。目的の箇所を特定するのに十分なだけの文
字を打ってしまえば、そこで終りにできます。つぎに何をするかにもよりますが、
RETで探索を陽に終了する必要がある場合もあります。

`C-s'
     前向きにインクリメンタルサーチする（`isearch-forward'）。
`C-r'
     後向きにインクリメンタルサーチする（`isearch-backward'）。

`C-s'はインクリメンタルサーチを始めます。`C-s'はキーボードから文字を読み
取り、打った文字が最初に現れる位置までカーソルを移動します。たとえば、
`C-s'に続けて`F'を打つと、カーソルは最初に現れる`F'の直後に移動します。
さらに`O'を打つと、カーソルは最初に現れる`FO'の直後に移動します。さらに
`O'を打つと、探索を開始した場所以降で最初に現れる`FOO'の直後にカーソルが
移動します。各段階において、反転表示できる端末では、探索文字列に一致する
バッファ内のテキストを強調表示します。また、各段階において、エコー領域に
表示した現在の探索文字列も更新します。

探索する文字列を打ちまちがえたときには、DELで取り消せます。DELを1回押す
ごとに、探索文字列の最後の文字を取り消していきます。ただし、Emacsがつぎ
の入力文字を受け付け可能になるまで、この取り消し操作は実行できません。つ
まり、取り消そうと思っている文字をみつけるか、もしくはみつけられなかった
ことが確定する必要があります。それまで待てないなら、以下に説明するように
`C-g'を使ってください。

目的の箇所まで移動できたら、RETを打ちます。すると、探索を終了しカーソル
はその箇所に留まります。また、探索に関係ないコマンドを打っても、探索を終
了し、そのコマンドを実行します。したがって、`C-a'と打てば、探索を終了し、
カーソルを行頭に移動します。RETが必要な場面は、つぎに入力したいコマンド
が、印字文字、DEL、RET、および、探索で特別な意味を持つその他の各種コント
ロール文字（`C-q'、`C-w'、`C-r'、`C-s'、`C-y'、`M-y'、`M-r'、`M-s'）であ
る場合だけです。

`FOO'を探してそれがみつかった場合でも、予期していた`FOO'ではないこともあ
るでしょう。最初の`FOO'以降に、2つめの`FOO'があることを忘れていたような
場合です。このようなときには、さらに`C-s'を打てば、探索文字列のつぎの出
現箇所に移動できます。この操作は何度でも繰り返せます。行き過ぎてしまった
ときには、DELで`C-s'の操作を取り消せます。

探索を終了したあとでも、単に`C-s C-s'と打てば、ふたたび同じ文字列を探索
できます。つまり、最初の`C-s'がインクリメンタルサーチを起動して、つぎの
`C-s'が『再探索』を意味します。

以前に探索した文字列を再利用するには、"探索リング"（search ring）を使い
ます。コマンド`M-p'と`M-n'でリング内を移動して、再利用する文字列を取り出
します。これらのコマンドは、探索リング内の選択した要素をミニバッファに置
きますから、編集することも可能です。`C-s'や`C-r'を打てば、文字列の編集を
終了して探索を開始できます。

探している文字列がまったくみつからなかった場合には、エコー領域に`Failing
I-Search'と表示されます。カーソルは、指定した文字列に可能な限り一致する
箇所の直後にあります。たとえば、`FOOT'を探索しようとしたのに`FOOT'がなけ
れば、カーソルは`FOOL'の`FOO'の直後にあります。この時点でできることはい
くつかあります。文字列を打ちまちがえたのならば、それを消去して訂正します。
その箇所でよいのなら、『探索したものを受理する』ために、RETか他のEmacsコ
マンドを打ちます。あるいは、`C-g'を打てば、探索文字列からみつけられなかっ
た文字（`FOOT'中の`T'）を取り除き、みつけた文字列（`FOOT'中の`FOO'）はそ
のままにしておくこともできます。ここで、さらに`C-g'を打つと、探索全体を
取り止めて、探索を開始した位置に戻ります。

探索文字列に大文字を指定すると、大文字小文字を区別（case-sensitive）して
探索します。探索文字列から大文字を削除すると、この効果は消えます。*Note
Search Case::。

探索に失敗したときに、さらに`C-s'を打って探索の続行を指示すると、バッファ
の先頭からもう一度探索し始めます。後向きの探索に失敗したときに再度`C-r'
を打つと、バッファの末尾から探索を再開します。これらの操作は"巻き直し"
（wrapping around）と呼ばれます。巻き直しが起こると、探索のプロンプトに
は`Wrapped'が表示されます。もともとの探索開始位置を通過してなお探索を続
けると、表示が`Overwrapped'に変わります。これは、探索文字列にすでに一度
一致した箇所を再度探索していることを意味します。

『中断』文字`C-g'は、探索中には特別な意味があり、その機能は探索の状態に
依存します。指定したものがみつかり入力待ちの状態にあると、`C-g'は探索全
体を取り消します。カーソルは探索開始位置に戻ります。Emacsが探索中であっ
たり探索に失敗したために、探索文字列内に未発見の文字がある場合に`C-g'を
打つと、探索文字列から未発見の文字を消去します。そうすると、これで探索が
成功したことになるので、入力待ちになります。続けて`C-g'を打つと、探索全
体を取り消します。

改行を探索するには、`C-j'を打ちます。コントロールSや改行などのコントロー
ル文字を探索するには、まず`C-q'を打ってクォートする必要があります。`C-q'
のこの機能は、挿入時の利用法に似ています（*Note Inserting Text::）。この
コマンドは、あとに続く文字を、同じ文脈における『普通の』文字と同様に扱う
ようにします。文字を8進コードで指定することもできて、`C-q'に続けて8進数
字列を入力します。

`C-r'を使えば、後向き探索に変更できます。ファイルのうしろのほうで探索し
始めたために探索に失敗したのであれば、これを試してください。`C-r'を繰り
返し打つと、後向きにさらに探索を続けます。`C-s'は、ふたたび前向き探索を
再開します。探索中の`C-r'はDELで取り消せます。

始めから後向きで探索するのであれば、`C-s'のかわりに`C-r'を使って探索を始
めます。`C-r'は、後向きに探索するコマンド`isearch-backward'を起動します。
前向き探索が開始位置よりうしろにある一致箇所をみつけるのと同様に、後向き
探索は開始位置よりまえにある一致箇所をみつけだします。

インクリメンタルサーチ中には、文字`C-y'と`C-w'を使って、バッファから探索
文字列へテキストを取り込むことができます。この機能は、ポイント位置にある
テキストの出現箇所を探すときに便利です。`C-w'は、ポイント以降の単語を探
索文字列の一部としてコピーし、ポイントをその単語の末尾に進めます。探索を
繰り返す意味で`C-s'を打つと、その単語を含んだ文字列を探索します。`C-y'も
`C-w'に似ていますが、現在行の残りの部分をすべて探索文字列にコピーします。
大文字小文字を区別しない探索では、`C-y'と`C-w'はともに、コピーするテキス
トを小文字だけに変換します。

文字`M-y'は、キルリングから探索文字列にテキストをコピーします。これには、
ヤンクコマンド`C-y'がヤンクするのと同じテキストを用います。*Note
Yanking::。

インクリメンタルサーチを終了すると、探索開始前にポイントが*あった*位置に
マークを置きます。これにより容易にその位置に戻れます。暫定マーク
（transient-mark）モードでは、マークが不活性のときに限って、インクリメン
タルサーチが設定するマークも不活性です。

インクリメンタルサーチ中に用いる特別な文字をカスタマイズするには、キーマッ
プ`isearch-mode-map'中のバインディングを変更します。バインディング一覧は、
`C-h f isearch-mode RET'を使って`isearch-mode'に関する説明文を参照してく
ださい。


低速端末でのインクリメンタルサーチ
----------------------------------

速度の遅い端末でのインクリメンタルサーチでは、表示時間が少なくてすむよう
に設計された表示形式を使います。みつけた箇所でバッファを再表示するかわり
に、新たに1行分のウィンドウを作ってそこにみつけた行を表示します。この1行
分のウィンドウは、探索することでポイントが画面に表示中のテキストから飛び
出た時点で使われます。

探索を終了すると、この1行分のウィンドウは消えます。そして、Emacsは探索を
完了したウィンドウを再表示して、新たなポイント位置を示します。


低速向けの表示形式を使うのは、端末のボーレートが変数`search-slow-speed'
の値以下である場合で、その初期値は1200です。

低速向けの表示形式に使う表示用ウィンドウの行数は、変数
`search-slow-window-lines'で制御します。通常の値は1です。



File: emacs-ja.info, Node: Nonincremental Search, Next: Word Search, Prev: Incremental Search, Up: Search

一括型探索
==========

Emacsでは、従来方式の一括型探索コマンドもあります。探索を開始するまえに
探索文字列全体を打っておく必要があります。

`C-s RET STRING RET'
     STRINGを探索する。
`C-r RET STRING RET'
     STRINGを後向きに探索する。

一括型探索を実行するには、まず`C-s RET'と打ちます。すると、探索文字列を
読み取るためにミニバッファに移動します。文字列をRETで終えると、探索を開
始します。文字列がみつからなければ、探索コマンドはエラーになります。

`C-s RET'はつぎのように動作します。まず、`C-s'がインクリメンタルサーチを
起動します。インクリメンタルサーチは、特別な場合として、引数が空であった
ときには一括型探索を起動するようにプログラムしてあります。（さもなければ、
そのような空の引数に意味はない。）`C-r RET'もこのように動作します。

しかし、`C-s RET'で実行される一括型探索は、`search-forward'をただちに呼
び出すわけではありません。まず、つぎの文字が単語探索を指示する`C-w'であ
るかどうか調べます。*Note Word Search::。

前向き／後向きの一括型探索は、コマンド`search-forward'と
`search-backward'で実装されています。これらのコマンドは通常と同じように
キーにバインドできます。インクリメンタルサーチコマンドから呼び出せるよう
になっているのは、歴史的な理由、および、これらの機能にふさわしいキー列を
選ぶ労力を削減できるという理由からです。



File: emacs-ja.info, Node: Word Search, Next: Regexp Search, Prev: Nonincremental Search, Up: Search

単語探索
========

単語探索は、単語の区切られ方を無視して、単語の列を探索します。より正確に
は、空白1個で区切った数個の単語を打ち込むと、単語と単語のあいだに複数個
の空白／改行／句読点があったとしても、それらの文字列をみつけだすことがで
きます。

単語探索は、テキスト清書系で整形済みの文書を編集する場合に便利です。整形
した印刷出力を見ながら編集する場合、ソースファイルのどこで行が区切られて
いるのかわかりません。単語探索を使えば、単語の区切られ方を知らなくても探
索できます。

`C-s RET C-w WORDS RET'
     句読点などの詳細は無視して、WORDSを探索する。
`C-r RET C-w WORDS RET'
     句読点などの詳細は無視して、後向きにWORDSを探索する。

単語探索は、一括型探索の特別な場合であって、`C-s RET C-w'で起動します。
この入力に続いて、探索文字列を入力し、文字列はつねにRETで終えます。一括
型であるため、単語探索も引数を入力し終えるまで探索を開始しません。単語探
索は、正規表現を構築し、その正規表現で探索を行うことで動作します。*Note
Regexp Search::。

後向きの単語探索には`C-r RET C-w'を使います。

前向き／後向きの単語探索は、それぞれ、コマンド`word-search-forward'と
`word-search-backward'で実装されています。これらのコマンドは通常どおりキー
に割り当てることができます。インクリメンタルサーチコマンドから呼び出せる
ようになっているのは、歴史的な理由、および、これらの機能にふさわしいキー
列を選ぶ労力を削減できるという理由からです。



