Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999
Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU General
Public License" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU General Public License" may be included in a translation
approved by the Free Software Foundation instead of in the original
English.





File: emacs-ja.info, Node: Variables, Next: Keyboard Macros, Prev: Minor Modes, Up: Customization

変数
====

"変数"は値を持つLispシンボル（記号）です。そのシンボルの名前のことを、変
数名とも呼びます。変数名はファイルに入れられるどのような文字でも含むこと
ができますが、習慣的には、変数名は英単語をハイフンでつなげたものです。変
数には、その変数がどのような値を持ち、どのように使われるかを記述した説明
文字列を持たせることができます。

Lispではどの変数にどのような値でも格納できますが、Emacsの中ではほとんど
の変数はどのような値を持つかが決まっています。たとえば、ある変数はつねに
文字列である、別の変数は数値であるといった具合です。また、「これこれの機
能はこの変数が`nil'以外のときにオンになる」といういい方もします。その場
合は、その変数に`nil'が格納されているときはその機能はオフですが、それ以
外の*どんな*値が格納されているときでもその機能はオンになります。ですが、
ある機能をオンにするために使う値として何か選ばなければなりませんから、
`t'という値を使うのが習慣です。

Emacsは一般のLispプログラムと同様、内部で情報を保持するために数多くの変
数を使いますが、ユーザーにとって特に興味深い変数というのは、もっぱらカス
タマイズ向けに用意された変数だといえます。Emacsは（通常は）そのような変
数の値を変更しません。かわりに、ユーザーが値を設定すると、その値に応じて
さまざまなEmacsコマンドのふるまいを変更したり制御したりできるのです。こ
れらの変数のことを"ユーザーオプション"といいます。ほとんどのユーザーオプ
ションはこのマニュアルに記載してありますし、変数索引（*Note Variable
Index::）にも記載してあります。

ユーザーオプションであるような変数の例として`fill-column'があります。こ
の変数は、詰め込みコマンド（*Note Filling::）が使う右端の桁位置を（左端
から何文字右かを表す数値として）保持します。

* Menu:

* Examining::	        Examining or setting one variable's value.
* Easy Customization::
                        Convenient and easy customization of variables.
* Hooks::	        Hook variables let you specify programs for parts
		          of Emacs to run on particular occasions.
* Locals::	        Per-buffer values of variables.
* File Variables::      How files can specify variable values.



File: emacs-ja.info, Node: Examining, Next: Easy Customization, Up: Variables

変数の設定と参照
----------------

`C-h v VAR RET'
     変数VARの値と説明文字列を表示する（`describe-variable'）。
`M-x set-variable RET VAR RET VALUE RET'
     変数VARの値をVALUEに変更する。

特定の変数の値を見るには、`C-h v'（`describe-variables'）を使います。こ
のコマンドは、ミニバッファで補完機能付きで変数名を読み取ります。変数の値
と説明文字列の双方を表示します。たとえば、

     C-h v fill-column RET

とすると、つぎのように表示されます。

     fill-column's value is 75

     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes buffer-local when set in any fashion.

説明文の先頭にある`*'は、この変数がユーザーオプションであることを示しま
す。`C-h v'は、ユーザーオプションに限らず任意の変数を扱えます。

ユーザーオプションを設定するいちばん簡単な方法は`M-x set-variable'を使う
ことです。このコマンドは、まずミニバッファで（補完機能付きで）変数名を読
み取り、つぎにミニバッファで変数に設定するLisp式を読み取ります。たとえば、

     M-x set-variable RET fill-column RET 75 RET

とすると、`fill-column'に75を設定します。

`M-x set-variable'はユーザーオプションに対してだけ使えます。これに対し、
`setq'を使えばどの変数にでも値が設定できます。たとえば、`setq'を使って
`fill-column'に設定するにはつぎのようにします。

     (setq fill-column 75)

このような式を実行するには、`*scratch*'バッファにいき、式を打ち込んでか
ら`C-j'を打ちます。*Note Lisp Interaction::。

変数を設定することは、特記していない限り、他のカスタマイズ方法と同様に、
現在のEmacsセッションだけに影響します。



File: emacs-ja.info, Node: Easy Customization, Next: Hooks, Prev: Examining, Up: Variables

簡便なカスタマイズ方法
----------------------

変更したいユーザーオプション変数をみつけて値を変更する便利な方法は、`M-x
customize'を使うことです。このコマンドは"カスタマイズバッファ"を作成し、
そのバッファ内では論理的な順序に並べたEmacsのユーザーオプションを眺めて
まわることができますし、さらに値を編集して設定できます。また、カスタマイ
ズバッファを使えば設定を恒久的なものとして保存もできます。（まだこの機能
で扱えないユーザーオプションもあるが、それらも扱えるように現在作業中。）

* Menu:

* Groups: Customization Groups.
                             How options are classified in a structure.
* Changing an Option::       How to edit a value and set an option.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Making a customization buffer for specific
                                options, faces, or groups.



File: emacs-ja.info, Node: Customization Groups, Next: Changing an Option, Up: Easy Customization

カスタマイズグループ
....................

カスタマイズのために、ユーザーオプションを"グループ"にまとめてみつけやす
くしてあります。グループはさらに大きなグループにまとめられていて、いちば
ん大きな（すべてのグループを含む）グループは`Emacs'という名前です。

`M-x customize'は、トップレベルの`Emacs'グループおよびその直下の（第2レ
ベルの）グループを表示したカスタマイズバッファを作成します。その表示はつ
ぎのようになります。

     /- Emacs group: ---------------------------------------------------\
           [State]: visible group members are all at standard settings.
        Customization of the One True Editor.
        See also [Manual].

     Editing group: [Go to Group] 
     Basic text editing facilities.

     External group: [Go to Group] 
     Interfacing to external utilities.

     MORE SECOND-LEVEL GROUPS

     \- Emacs group end ------------------------------------------------/


この表示の先頭部分は、このバッファが`Emacs'グループの内容を表示している
ことを記しています。残りのグループが表示されるのは、それらが`Emacs'グルー
プに含まれているからです。ただし、それらは字下げや「-」なしで表示されて
いて、表示にはそれらのグループの内容が含まれては*いない*ことを示していま
す。各グループの表示には1行の説明文字列が付随しています。また、`Emacs'グ
ループについては`[State]'行が付随しています。

カスタマイズバッファ内のテキストのほとんどは変更できませんが、一部分は"
編集可能フィールド"になっていて、変更できます。また、"アクティブフィール
ド"という、その場所を"起動"するとなんらかの動作を行うような場所もありま
す。アクティブフィールドを起動するには、`Mouse-1'でそこをクリックするか、
またはそこにポイントを持っていってRETを打ちます。

たとえば、第2レベルグループ中の`[Go to Group]'と記された部分はアクティブ
フィールドです。`[Go to Group]'のフィールドを起動すると、そのグループと
そのグループの内容を表示する新しいカスタマイズバッファが作られ、そのグルー
プと中身が表示されます。このフィールドは他のグループへのハイパーテキスト
リンクの一種です。

`Emacs'グループそのものはユーザーオプションを1つも含んでいませんが、他の
グループにはあります。さまざまなグループを眺めてみると、興味を持ってカス
タマイズしてみようと思うような機能に属するオプションやフェイスをみつける
ことができるでしょう。

カスタマイズグループ群の構造を概観するには、`M-x customize-browse'を使い
ます。このコマンドは、グループ名（とオプションやフェイス）とそれらの構造
だけを表示する特別なカスタマイズバッファを作ります。

このバッファ中では、グループの中身を見るには`[+]'のところを起動します。
グループの中身が見えるようになると、このボタンは`[-]'に変わります。これ
を起動すると中身を（もとどおり）隠します。

各グループ、オプション、フェイスにはそれぞれ`[Group]'、`[Option]'、
`[Face]'と記されたアクティブフィールドがあります。それらを起動すると、そ
のグループ／オプション／フェイスのみを表示した通常のカスタマイズバッファ
が作成されます。そのバッファで値を設定します。



File: emacs-ja.info, Node: Changing an Option, Next: Face Customization, Prev: Customization Groups, Up: Easy Customization

オプションの変更
................

カスタマイズバッファでユーザーオプションがどのように見えるか、例をあげま
しょう。

     Kill Ring Max: [Hide] 30
        [State]: this option is unchanged from its standard setting.
     Maximum length of kill ring before oldest elements are thrown away.

`[Hide]'に続くテキスト、つまり、`30'がオプションの現在の値を示しています。
`[Hide]'ではなく`[Show]'と表示されていれば、値は隠されています。カスタマ
イズバッファでは、複数行にわたるような値は最初は隠されていて、`[Show]'を
起動すると表示されます。

オプション名に続く行はオプションの"カスタマイズ状態"を示しています。上の
例では、まだ変更していないと表示されています。行頭の`[State]'のところが
アクティブフィールドで、ここを`Mouse-1'かRETで起動するとさまざまな操作を
示すメニューが表示されます。これらの操作は変数をカスタマイズするうえでと
ても重要です。

`[State]'のつぎの行には、そのオプションの説明文字列の先頭部分が表示され
ます。1行に収まらない場合には、行末に`[More]'と表示されます。これを起動
すると説明文字列全体が表示されます。

`Kill Ring Max'に新しい値を設定するには、ポイントを値の位置へ持っていっ
て直接文字列を変更します。たとえば、`M-d'で現在の値を削除してから、設定
する数値を打ち込めばよいのです。

文字列を変更し始めると、`[State]'行の表示が変わって、値が編集されている
ことを示すようになります。

     [State]: you have edited the value as text, but not set the option.

文字列を変更しただけでは、まだオプション変数の値は設定されません。値を"
設定する"には、`[State]'のところを起動して、`Set for Current Session'を
選択します。

値を設定すると、オプションの状態表示も対応して変わります。

     [State]: you have set this option, but not saved it for future sessions.

正しくない値を設定してしまう心配はありません。というのは、オプションの設
定時には、値の正しさを検査して、正しくない値は設定できないようになってい
ます。

ディレクトリ名、ファイル名、コマンド名である値やフィールドを編集するとき、
および、その他何であれ補完が定義されているものを編集するときは、`M-TAB'
（`widget-complete'）を打てば補完できます。

いくつかのオプションでは、正しい値としては決まった少数のものだけを使えま
す。そのようなオプションは、テキストとしては編集できません。かわりに
`[Value Menu]'というアクティブフィールドが値のまえに現れます。『オンかオ
フ』だけの真偽値を持つオプションでは、アクティブフィールドは`[Toggle]'と
表示されていて、そこを起動するたびに値を反転できます。`[Value Menu]'も
`[Toggle]'もバッファを変更するだけです。値が実際に設定されるのは`Set for
Current Session'を起動したときです。

いくつかのオプションは、込み入った構造の値を持ちます。たとえば、
`load-path'は値としてディレクトリのリストを持ちます。これをカスタマイズ
バッファに表示すると、つぎのようになります。

     Load Path:
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/leim
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp/gnus
     [INS]
        [State]: this item has been changed outside the customization buffer.
     List of directories to search for files to load....

リスト中の各ディレクトリがそれぞれ別の行に表示され、各行にはいくつかの編
集可能／アクティブフィールドがあります。

どのディレクトリ名も直接編集できます。リストからディレクトリを削除するに
は、その行の`[DEL]'を起動します。リストに新しいディレクトリを追加するに
は、挿入したい箇所の`[INS]'を起動します。

`[Current dir?]'を起動すると、パスに特定のディレクトリを含めるのか、また
は、`nil'を含めるのかを切り替えられます。（探索パスにおける`nil'は、『カ
レントディレクトリを探せ』という意味。）

2つの特別なコマンド、TABと`S-TAB'は、カスタマイズバッファ内での移動に役
立ちます。TAB（`widget-forward'）はつぎのアクティブ／編集可能フィールド
へ移動します。`S-TAB'（`widget-backward'）は、1つまえのアクティブ／編集
可能フィールドへ移動します。

編集可能フィールドでRETを打つと、TABと同様につぎのフィールドへ進みます。
なぜそうなっているかというと、編集可能フィールドを編集し終えると最後に
RETを打つ人が多いからです。編集可能フィールドに改行文字を入るには、`C-o'
か`C-q C-j'と打ちます。

オプションを設定すると、その値は現在のEmacsセッションだけに有効です。そ
の値を"保存"すると、将来のセッションでも有効になります。保存を行うと、個
人の`~/.emacs'ファイルにコードが追加されて、つぎにEmacsを起動したときに
オプション変数の値を設定するようになります。オプションを保存するには、
`[State]'を起動して`Save for Future Sessions'を選びます。

オプションを標準値に戻したければ、`[State]'を起動して`Reset to Standard
Settings'を選びます。実際にはつぎの3種類のリセット操作があります。

`Reset'
     なんらかの修正を行ったが、まだオプションを設定していなければ、この
     操作により、カスタマイズバッファ上のテキストをオプションの現在値と
     一致させられる。

`Reset to Saved'
     この操作では、オプションの値を最後に保存した値に戻し、カスタマイズ
     バッファ上のテキストもその値に合わせる。

`Reset to Standard Settings'
     この操作では、オプションを標準値に設定し、カスタマイズバッファ上の
     テキストもその値に合わせる。さらに、以前にそのオプションについて保
     存した値もすべてもとに戻されるので、将来のEmacsセッションでもすべて
     標準値が使われるようになる。

グループの`[State]'はそのグループに属するもののどれかが編集された／設定
された／保存されたことを示します。`Set for Current Session'、`Save for
Future Sessions'、および各種の`Reset'をグループ全体に対して適用できます。
これらの操作はグループおよびそのサブグループに属するすべてのオプションに
対して適用されます。

カスタマイズバッファの先頭付近には、いくつかのアクティブフィールドを含ん
だつぎのような行があります。

      [Set for Current Session] [Save for Future Sessions]
      [Reset] [Reset to Saved] [Reset to Standard]   [Bury Buffer]

`[Bury Buffer]'を起動すると、カスタマイズバッファを消します。他のフィー
ルドは、そのバッファに含まれている項目それぞれについてそれぞれ、設定、保
存、リセットを（それらの操作が適用可能なら）実行します。



File: emacs-ja.info, Node: Face Customization, Next: Specific Customization, Prev: Changing an Option, Up: Easy Customization

フェイスのカスタマイズ
......................

いくつかのカスタマイズグループは、ユーザーオプションに加えてフェイスも含
みます。グループの内容を表示したとき、オプションとフェイスの両方がカスタ
マイズバッファに現れます。フェイスの見え方は、たとえばつぎのようになりま
す。

     Custom Changed Face: (sample)
        [State]: this face is unchanged from its standard setting.
     Face used when the customize item has been changed.
     Attributes: [ ] Bold: [toggle] off
                 [X] Italic: [toggle] on
                 [ ] Underline: [toggle] off
                 [ ] Inverse-Video: [toggle] on
                 [ ] Foreground: black (sample)
                 [ ] Background: white (sample)
                 [ ] Stipple:  

フェイスの各属性はそれぞれが1行を占めます。属性のまえの`[X]'というフィー
ルドは、その属性が"オンになっている"かどうかを表示しています。`X'が表示
されていればオンになっています。そのフィールドを起動することでオン／オフ
を反転できます。属性がオンになっている場合は、その属性の値をオプションと
同様にして変更できす。

白黒ディスプレイでは、背景に設定可能な表示色は`black'、`white'、`gray'、
`gray1'、`gray3'のいずれかです。Emacsは表示色のかわりにドットパターンで
灰色の階調を表します。

フェイスを設定／保存／リセットするのは、オプションと同様にしてできます
（*Note Changing an Option::）。

フェイスでは、ディスプレイの種別ごとに異なる見え方を指定できます。たとえ
ば、あるフェイスをカラーディスプレイでは赤で表示し、白黒ディスプレイでは
かわりにボールド体で表示するようにできます。あるフェイスに複数の見え方を
指定するには、`[State]'メニューを表示させて`Show Display Types'を選びま
す。

フェイスの属性を設定するもっと基本的な方法は、`M-x modify-face'を使うこ
とです。このコマンドは、まずフェイスの名前を聞いてきて、続いて属性を1つ
ずつ順に聞いてきます。表示色やパターンの属性では、その属性の現在の値がデ
フォルトになっています。これらを変更したくなければ、単に、RETを打てばよ
いのです。属性を空にしたければ`none'と打ちます。



File: emacs-ja.info, Node: Specific Customization, Prev: Face Customization, Up: Easy Customization

特定項目のカスタマイズ
......................

グループ構造を1段ずつ降りていって目指すオプションを探すかわりに、カスタ
マイズしたいオプション／フェイス／グループの名前を直接に指定することもで
きます。

`M-x customize-option RET OPTION RET'
     指定したオプションOPTIONだけを含むカスタマイズバッファを開く。
`M-x customize-face RET FACE RET'
     指定したフェイスFACEだけを含むカスタマイズバッファを開く。
`M-x customize-group RET GROUP RET'
     指定したグループGROUPだけを含むカスタマイズバッファを開く。
`M-x customize-apropos RET REGEXP RET'
     指定した正規表現REGEXPに一致するすべてのオプション／フェイス／グルー
     プを含むカスタマイズバッファを開く。
`M-x customize-changed-options RET VERSION RET'
     EmacsのバージョンVERSION以降に意味が変更されたすべてのオプション／
     フェイス／グループを含むカスタマイズバッファを開く。
`M-x customize-saved'
     カスタマイズバッファで保存したすべてのオプションとフェイスを含むカ
     スタマイズバッファを開く。
`M-x customize-customized'
     カスタマイズしたが、まだ保存していないすべてのオプションとフェイス
     を含むカスタマイズバッファを開く。

名前のわかっているオプション変数をカスタマイズバッファで変更したい場合は、
コマンド`M-x customize-option'で直接名前を指定します。これにより、そのオ
プションだけを含むカスタマイズバッファが現れます。編集／設定／保存はこれ
まで説明したとおりに行いますが、設定の対象になるのは指定したオプションだ
けです。

同様にして、`M-x customize-face'ではフェイス名を指定して変更できます。

同様に、`M-x customize-group'ではグループ名を指定してカスタマイズバッファ
を開くことができます。そのカスタマイズバッファには、指定したグループに直
接含まれているオプション、フェイス、他の（下位の）グループが現れます。た
だし、サブグループの内容は最初は隠されています。それらを表示したい場合は、
通常どおり`[Show]'を起動します。

`M-x customize-apropos'を使うと、カスタマイズするものをもっと細かく制御
できます。このコマンドでは引数として正規表現を指定し、それに一致するすべ
てのオプション／フェイス／グループを含んだカスタマイズバッファが現れます。
空の正規表現を指定すると、*すべての*オプション／フェイス／グループを含む
カスタマイズバッファができます（ただしすごく時間がかかる）。

Emacsの新版へ更新したときには、新しいオプション、意味やデフォルト値が変
更されたオプションをカスタマイズしたいはずです。それには、`M-x
customize-changed-options'を使い、ミニバッファで以前の版のEmacsのバージョ
ン番号を指定します。すると、指定したバージョン以降に定義が変更されたすべ
てのオプション（とグループ）を含んだカスタマイズバッファを作ります。

オプションを変更したあとでまちがったと気づいたときは、変更したものを再検
討するために2つのコマンドが使えます。保存してしまったオプションについて
は`customize-saved'を、変更したけれどまだ保存していないオプションについ
ては`M-x customize-customized'を使います。



File: emacs-ja.info, Node: Hooks, Next: Locals, Prev: Easy Customization, Up: Variables

フック
------

"フック"とはある特定の状況で既存のプログラムから呼び出される関数／関数群
を格納しておく変数をいいます。Emacsには、カスタマイズ用のフックが数多く
あります。

Emacs中のほとんどのフックは"ノーマルフック"です。これらの変数は、引数な
しで呼び出される関数のリストを保持します。ほとんどのフックがノーマルフッ
クなのは、それらを統一的に扱えるからです。Emacsでは、`-hook'で終わる名前
の変数はすべてノーマルフックです。

ほとんどのメジャーモードは初期設定の最終段階でフックを実行します。モード
が設定したローカル変数をフックで変更すればよいので、モードのふるまいをユー
ザーがカスタマイズすることが容易になります。しかし、フックはそれ以外の場
面でも使われます。たとえば、`suspend-hook'は、Emacsが休止する直前に実行
されます（*Note Exiting::）。

ノーマルフックにフック関数を追加するお勧めのやり方は、`add-hook'を呼ぶこ
とです。フック関数としては任意のLisp関数を使えます。たとえば、テキスト
（text）モードやテキスト（text）モードを基にしているモードにおいて、自動
的に自動詰め込み（auto-fill）モードをオンにするにはつぎのようにします

     (add-hook 'text-mode-hook 'turn-on-auto-fill)

つぎの例は、Cコードの字下げをカスタマイズするのにフックを使う方法を示し
ます。（誰でも字下げには独自の好みがある）。ここでは、フック関数は名前の
ないラムダ式です。

     (setq my-c-style
       '((c-comment-only-line-offset . 4)
         (c-cleanup-list . (scope-operator
     		       empty-defun-braces
     		       defun-close-semi))
         (c-offsets-alist . ((arglist-close . c-lineup-arglist)
     			(substatement-open . 0)))))

     (add-hook 'c-mode-common-hook
       (function (lambda ()
         (c-add-style "my-style" my-c-style t))))

どの順番で実行されても大丈夫なようにフック関数を設計するのが最良です。実
行順序に依存するのは、『事故を呼び込む』ようなものです。しかし、順番は予
測できます。もっとも最近に追加したフック関数ほど先に実行されます。



File: emacs-ja.info, Node: Locals, Next: File Variables, Prev: Hooks, Up: Variables

ローカル変数
------------

`M-x make-local-variable RET VAR RET'
     変数VARがカレントバッファでローカルに値を持つようにする。
`M-x kill-local-variable RET VAR RET'
     変数VARがカレントバッファではグローバル値を使うようにする。
`M-x make-variable-buffer-local RET VAR RET'
     変数VARを、値を設定したときにその時点のカレントバッファでローカルに
     値を持つようにする。

ほとんどの変数はEmacsバッファに対して"ローカル"にできます。つまり、その
変数のバッファ中での値は他のバッファでの値とは独立になります。いくつかの
変数はつねにすべてのバッファにおいてローカルです。それ以外の変数はすべて、
"グローバル"な値、つまりその変数をローカルにしていないすべてのバッファに
おいて共有される値を持ちます。

`M-x make-local-variable'は変数名を受け取り、その変数をカレントバッファ
においてローカルにします。それ以降、このバッファ内でその変数を変更しても
他のバッファには影響しませんし、その変数のグローバルな値を変更してもこの
バッファ内での値には影響しません。

`M-x make-variable-buffer-local'は、変数名を受け取り、値が設定されるとそ
の変数が自動的にローカルになるようにします。もっと正確にいえば、このよう
に特別な印を変数に付けておくと、通常の方法で変数に値を設定するときにはつ
ねにまず`make-local-variable'が実行されるようになるのです。このような変
数を"バッファごとの変数"と呼びます。

メジャーモード（*Note Major Modes::）では、変数を設定するまえにつねにロー
カルにします。このため、あるバッファでメジャーモードを変更しても他のバッ
ファには影響が及びません。マイナモード（*Note Minor Modes::）も同様で、
通常、マイナモードごとにオン／オフを制御する変数があり、その変数が`nil'
以外のときにそのマイナモードはオンになります。ほとんどのマイナモードでは、
その制御用変数はバッファごとの変数です。

Emacsには、つねにバッファごとの変数であるような変数が数多くあります。
`abbrev-mode'、`auto-fill-function'、`case-fold-search'、
`comment-column'、`ctl-arrow'、`fill-column'、`fill-prefix'、
`indent-tabs-mode'、`left-margin'、`mode-line-format'、`overwrite-mode'、
`selective-display-ellipses'、`selective-display'、`tab-width'、
`truncate-lines'がそのような変数です。これ以外にもつねに各バッファでロー
カルな変数はありますが、それらは内部作業用の変数です。

いくつかの変数はディスプレイに対してローカルになっているため、バッファに
対してローカルにはできません（*Note Multiple Displays::）。これらの変数
をバッファにローカルにしようとすると、エラーメッセージが表示されます。

`M-x kill-local-variable'は、変数名を受け取り、その変数をカレントバッファ
に対してローカルでなくします。それ以降そのバッファでは、その変数のグロー
バルな値が使われます。メジャーモードを設定すると、"つねにローカル"と印が
付いた少数の特別な変数を除いて、そのバッファにローカルなすべての変数をロー
カルでなくします。

ある変数がカレントバッファでローカルか否かに係わらずその変数のグローバル
な値を設定したければ、`setq-default'を使います。これは`setq'のように使わ
れますが、（たとえローカルな値があったとしても）つねにグローバルな値のほ
うを設定します。その変数がローカルな値を持っている場合、新たに設定したグ
ローバルな値は別のバッファに切り替えるまでは参照できません。以下に例をあ
げます。

     (setq-default fill-column 75)

`setq-default'は、`make-variable-buffer-local'で印を付けた変数のグローバ
ルな値を設定する唯一の方法です。

Lispプログラム中では、変数のデフォルト値を参照するためには
`default-value'を使えます。この関数はシンボルを引数とし、その変数のデフォ
ルト値を返します。引数は評価されるので、普通は引数をクォートします。たと
えば、`fill-column'のデフォルト値を取得するにはつぎのようにします。

     (default-value 'fill-column)



File: emacs-ja.info, Node: File Variables, Prev: Locals, Up: Variables

ファイルにローカルな変数
------------------------

Emacsでファイルを編集する際に、そのファイルに対応したローカル変数とその
値を指定することができます。Emacsはファイルを訪問すると、ローカル変数指
定の有無を検査し、あれば指定された変数を自動的にバッファにローカルにして、
その値をファイルで指定された値に設定します。

ローカル変数とその値を設定するには2つの方法があります。1つはファイルの先
頭行に書くことで、もう1つはローカル変数リストを書くことです。先頭行に書
く場合は、たとえばつぎのようにします。

     -*- mode: MODENAME; VAR: VALUE; ... -*-

変数とその値を「:」で区切った対を「;」で区切って並べ、いくつでも指定でき
ます。`mode: MODENAME;'はメジャーモードを指定するもので、行の最初にある
必要があります。VALUEは評価されずに書かれているとおりのまま使われます。
以下は、Lispモードで2つの変数に数値を設定する例です。

     ;; -*-mode: Lisp; fill-column: 75; comment-column: 50; -*-

この方法では、ファイルのコーディングシステムも指定できます。つまり、
`coding'という名前の『変数』に値を指定すればよいのです。『値』は、Emacs
が認識できるコーディングシステム名である必要があります。*Note Coding
Systems::。

一方、"ローカル変数リスト"はファイルの末尾（最後のページ）に置きます。
（最後のページにはローカル変数リストだけを置くというのを勧めます。）ロー
カル変数リストは`Local Variables:'という内容を含む行で始まり、`End:'とい
う内容を含む行で終ります。これらの行のあいだに、1つの変数につき1行ずつ、
`VARIABLE: VALUE'という形で変数の名前と値を指定します。VALUEは評価されず
にファイルに書かれたとおりにそのまま使われます。ファイルにローカル変数リ
ストと`-*-'の行が両方含まれていた場合には、Emacsはまず`-*-'の行を*すべて
*処理してから、続いてローカル変数リストの内容を*すべて*処理します。

以下にローカル変数リストの例を示します：

     ;;; Local Variables: ***
     ;;; mode:lisp ***
     ;;; comment-column:0 ***
     ;;; comment-start: ";;; "  ***
     ;;; comment-end:"***" ***
     ;;; End: ***

上の例では、各行は`;;;'で始まり`***'で終っています。Emacsはこれらの接頭
辞と接尾辞をリストの最初の内容に基づいて認識します。つまり、特別な文字列
`Local Variables:'の前後の文字列を、それぞれ、接頭辞、接尾辞とみなし、そ
れ以降の行についてはこの接頭辞と接尾辞を無視します。

接頭辞と接尾辞を使う主な理由は、ローカル変数リストをコメントの中に入れる
ことで、そのファイルを読み込む他のプログラムを困惑させないようにすること
です。上の例では、コメントが`;;;'で始まり`***'で終るような言語を想定して
います。変数`comment-start'と`comment-end'のローカルな値で、このような変
な構文に対処するようにEmacsをカスタマイズするのです。必要ないのであれば、
接頭辞（と接尾辞）は使わないでください。

ローカル変数リストにおいては、2つの変数名が特別な意味を持ちます。変数
`mode'に対する値は、実際にはメジャーモードを設定します。変数`eval'に対す
る値は、式として評価されますが、その結果は捨てられます。`mode'と`eval'は
本当の変数ではなく、他の状況でこれらの名前の変数に値を設定してもなんら特
別な意味を持ちません。メジャーモードを設定するために`mode'を指定する場合
は、ローカル変数リストの先頭に書く必要があります。

仮想的な『変数』`mode'は、メジャーモードだけでなくマイナモードを設定する
のにも使えます。実は、この指定は2回以上使うことができて、最初はメジャー
モードを設定し、それ以降は（それぞれ）マイナモードを設定します。しかし、
マイナモードはユーザーの好みに応じて選ぶものですから、普通はファイルでマ
イナモードを指定するべきではないでしょう。

たとえば、ローカル変数リストで自動詰め込み（auto-fill）モードをオンにし
たいと思うかもしれませんが、それはまちがいです。自動詰め込みにするかどう
かは、個人の好みの問題であり、ファイルの中身によって決まるものではないか
らです。ある種別のファイルでいつも自動詰め込みにしたければ、個人の
`.emacs'ファイルで（状況に応じて）自動詰め込み（auto-fill）モードをオン
にするようなメジャーモードのフックを設定してください（*Note Init File::）。
ローカル変数リストで他人に好みを押し付けてはいけません。

ローカル変数リストは、ファイルの末尾から3000文字以内にある必要があり、ファ
イルがページに分かれている場合には最後のページにある必要があります。これ
らが守られていないと、Emacsはローカル変数リストがあることを認識しません。
これらの規則の目的は、最後ではないページに偶然`Local Variables:'があって
もEmacsが誤認しないようにすることと、全体が1ページでローカル変数リストを
持たない長いファイルを訪問するときでもファイル全体を探さなくてもすむよう
にするためです。

バッファのローカル変数やメジャーモードを、ローカル変数リストがあるときに
はそれによる指定も含めて、ファイル名とファイルの内容に基づいたものにリセッ
トしたければ、`normal-mode'コマンドを使ってください。*Note Choosing
Modes::。

変数`enable-local-variables'は、ファイル中のローカル変数指定を処理するか
否かを制御します。つまり、ローカル変数指定を無視するようにもできます。デ
フォルトは`t'で、ファイル中のローカル変数指定を処理します。値を`nil'にす
ると、ファイル中のローカル変数指定を無視します。これら以外の値の場合は、
ファイル中にローカル変数指定があると、その内容を表示して処理するかどうか
問い合わせます。

仮想的な『変数』`eval'といくつかの（実在する）変数に対する指定は、ある種
の危険性をもたらします。他人のファイルを訪問したとき、そこに書かれている
ローカル変数指定によってあなたが使っているEmacsのふるまいがどのようにで
も変更できるからです。このため、オプション`enable-local-eval'により、変
数`eval'、さらに、`-hook'、`-hooks'、`-function'、`-functions'という名前
で終る変数、および、他のいくつかの変数に対するローカル変数指定を処理する
かどうか制御できるようになっています。`enable-local-variables'と同じよう
に指定できる値は3種類あって、`t'、`nil'、これら以外です。デフォルトは
`maybe'で、これは`t'でも`nil'でもありませんから、Emacsはこれらのローカル
変数指定があるときは確認を求めてきます。



File: emacs-ja.info, Node: Keyboard Macros, Next: Key Bindings, Prev: Variables, Up: Customization

キーボードマクロ
================

"キーボードマクロ"は、ユーザーが一連のキー操作に基づいて定義したコマンド
です。たとえば、`C-n C-d'という打鍵を40回繰り返す必要があるとわかったら、
`C-n C-d'を実行するキーボードマクロを定義し、それを40回繰り返す指定をし
て呼び出すと迅速に作業できます。

`C-x ('
     キーボードマクロの定義を開始する（`start-kbd-macro'）。
`C-x )'
     キーボードマクロの定義を終了する（`end-kbd-macro'）。
`C-x e'
     もっとも最近のキーボードマクロを実行する（`call-last-kbd-macro'）。
`C-u C-x ('
     もっとも最近のキーボードマクロを再実行したうえで、その定義にキーを
     追加する。
`C-x q'
     キーボードマクロの実行中にこの場所に到達したら、実行の確認を求める
     （`kbd-macro-query'）。
`M-x name-last-kbd-macro'
     もっとも最近に定義したキーボードマクロに（現在のEmacsセッションだけ
     で有効な）コマンド名を与える。
`M-x insert-kbd-macro'
     キーボードマクロの定義をLispコードとしてバッファに挿入する。
`C-x C-k'
     まえに定義したキーボードマクロを編集する（`edit-kbd-macro'）。
`M-x apply-macro-to-region-lines'
     リージョン内の各行に対して、最後に定義したキーボードマクロを実行す
     る。

キーボードマクロは、それがLispではなくEmacsのコマンド言語で記述されてい
るという点で、通常のEmacsコマンドとは違っています。このため、キーボード
マクロは初心者でも簡単に作れ、間に合わせとして定義するのにも向いています。
しかし、Emacsのコマンド言語は、プログラム言語として知的で汎用的な動作を
記述できるほど強力ではありません。そういう場合には、Lispを使ってください。

キーボードマクロは、定義内容のコマンド列を実際に実行しながら定義できます。
いいかえれば、キーボードマクロを定義しているときに、その定義の第1回目の
実行が行われることになります。ですから、コマンドがどのように動作するかを
目で見ながら確認でき、頭の中だけで動作を考えるよりも楽に定義できます。コ
マンド列の最後まできてキーボードマクロを定義し終ると、第1回目の実行も終っ
たことになります。そのあとは、マクロを呼び出すことで何回でもそのコマンド
列全体を実行できます。

* Menu:

* Basic Kbd Macro::     Defining and running keyboard macros.
* Save Kbd Macro::      Giving keyboard macros names; saving them in files.
* Kbd Macro Query::     Making keyboard macros do different things each time.



File: emacs-ja.info, Node: Basic Kbd Macro, Next: Save Kbd Macro, Up: Keyboard Macros

基本的な使い方
--------------

キーボードマクロの定義を開始するには、`C-x ('コマンド（`start-kbd-macro'）
を打ってください。それ以降打鍵するものは通常どおり実行されますが、それと
同時にキーボードマクロの定義として取り込まれます。モード行にもそのことを
表す`Def'という表示が現れます。定義の終りまできたら、`C-x )'
（`end-kbd-macro'）を打ち込むとキーボードマクロの定義が完了します（`C-x
)'はマクロの内容には含まれません！）。たとえば、

     C-x ( M-f foo C-x )

のように打鍵すると、1単語分ポイントを前進させ文字列`foo'をバッファに挿入
する、キーボードマクロを定義できます。

定義し終えたキーボードマクロは、コマンド`C-x e'（`call-last-kbd-macro'）
で再実行できますし、数引数として反復回数を指定することで多数回実行するこ
ともできます。`C-x )'にも引数として反復回数を指定でき、その場合は定義完
了とともにただちに指定した回数だけキーボードマクロを実行しますが、定義し
ているとき（実行しているので）を1回目の実行として数えます。ですから、
`C-u 4 C-x )'と打つと、キーボードマクロをただちに3回実行します。`C-x e'
や`C-x )'に反復回数0を指定すると、キーボードマクロを無限回、つまり、エラー
が発生するか、`C-g'（MS-DOSでは`C-BREAK'）が打鍵されるまで、繰り返し実行
します。

テキスト上の規則的にとびとびの位置に対して操作を行いたい場合には、キーボー
ドマクロを定義するときに、つぎに適用したい位置までポイントを移動するコマ
ンドを含めておきます。たとえば、各行について変更を行いたければ、ポイント
を行頭に置いてからキーボードマクロを定義し始め、最後にポイントをつぎの行
の行頭に置いたところで定義を終えます。キーボードマクロを繰り返し実行する
と、次々と連続する行に対して操作を実行できます。

キーボードマクロの定義を完了してしまったあとでも、`C-u C-x ('を打ち込め
ば、その定義の末尾に内容を追加できます。このコマンドは、`C-x ('に続いて
現在のキーボードマクロの定義内容全体を打鍵したのと同じ効果を持ちます。そ
の結果、定義されたとおりにマクロを再実行します。

キーボードマクロの中で、通常のキーと同様にファンクションキーを使うことも
できます。マウスイベントを使うことさえできますが、その場合は注意してくだ
さい。キーボードマクロはマウスイベントを再現しますが、マウス位置としては
最初にキーボードマクロを定義したときの位置がそのまま使われます。その結果
は予想し難いものになります。（現在のマウス位置を使っても、結果はさらに予
想し難いものになる。）

キーボードマクロの中で必ずうまくいくとは限らないことの1つに、`C-M-c'
（`exit-recursive-edit'）コマンドがあります。このコマンドがマクロの中で
開始させた再帰編集を終らせる場合には、期待どおりに動くでしょう。しかし、
このコマンドがキーボードマクロを起動するまえに入っていた再帰編集を終らせ
るとすると、その終了処理の過程でキーボードマクロの実行も終らせてしまいま
す。

定義済みのキーボードマクロを編集するには、`C-x C-k'（`edit-kbd-macro'）
と打ちます。このコマンドに続けてマクロを起動する打鍵、つまり、`C-x e'や
`M-x NAME'などのキー列を入れます。すると、キー列に対応するキーボードマク
ロの内容が整形されて特別な編集用メジャーモードのバッファに入ります。その
バッファ中で`C-h m'と打つと編集方法が表示されます。編集し終えたら`C-c
C-c'と打ちます。

コマンド`M-x apply-macro-to-region-lines'は最後に定義されたキーボードマ
クロを現在のリージョンの各行に対して実行します。つまり、各行について、行
頭にポイントを置いてからキーボードマクロを実行します。



File: emacs-ja.info, Node: Save Kbd Macro, Next: Kbd Macro Query, Prev: Basic Kbd Macro, Up: Keyboard Macros

キーボードマクロの命名と保存
----------------------------

新たにつぎのキーボードマクロを定義したあとでも現在のキーボードマクロを使
いたいなら、`M-x name-last-kbd-macro'でキーボードマクロに名前を付けてお
く必要があります。このコマンドは、ミニバッファで名前を読み取り、その名前
でキーボードマクロを実行できるように定義します。マクロ名はLispシンボルで
あり、このように定義されているので、`M-x'で呼び出したり`global-set-key' 
（*Note Keymaps::）でキーに対応付けたりできる有効なコマンド名になります。
その名前にキーボードマクロ以外のものがすでに定義されていると、エラーメッ
セージが表示され何の変更も起こりません。

キーボードマクロにコマンド名を付けると、その定義をファイルに保存できます。
そうすると、別の編集セッションで使えるようになります。まず、定義を保存し
たいファイルを訪問してから、つぎのコマンドを使ってください。

     M-x insert-kbd-macro RET MACRONAME RET

このコマンドは、実行するとそのキーボードマクロと同じ動作を行うLispコード
をバッファに挿入します。（`insert-kbd-macro'がLispコードの生成を代行する
ので、Lispコードを理解する必要はない。）そうしたら、このファイルを保存し
ます。`load-file'（*Note Lisp Libraries::）でファイルをロードできます。
保存するファイルとして`~/.emacs'（*Note Init File::）を使えば、Emacsを起
動するとつねにそのマクロが定義されます。

`insert-kbd-macro'に数引数を指定すると、さらに（もしあれば）キーボードマ
クロに割り当てたキーを記録するLispコードが追加されるので、ファイルをロー
ドしたときに同じキーがマクロに割り当てられます。



File: emacs-ja.info, Node: Kbd Macro Query, Prev: Save Kbd Macro, Up: Keyboard Macros

変化のあるマクロの実行
----------------------

`C-x q'（`kbd-macro-query'）を使うと、`query-replace'と同様に変更するか
どうか尋ねてくるキーボードマクロを作れます。キーボードマクロを定義してい
るときに、問い合わせが起きてほしい箇所で`C-x q'を打ちます。マクロの定義
中は`C-x q'は何の動作もしませんが、あとでマクロを実行させたときには`C-x
q'の箇所で処理を続けるかどうか尋ねてくるようになります。

`C-x q'の問い合わせに対する有効な応答は、SPC（または`y'）、DEL（または
`n'）、RET（または`q'）、`C-l'、`C-r'です。これらの意味は`query-replace'
と同じですが、`query-replace'のすべての応答が意味を持つとは限りません。

SPCは続行、DELはこの回の反復の残りを飛ばしてただちにつぎの反復に進むとい
う意味になります。RETではこの回の反復の残りも以後の反復もすべて取り消し
ます。`C-l'は画面を再描画し、再度どうするかを問い合わせてきます。

`C-r'で再帰編集レベルに入るので、そこでキーボードマクロにはない編集を行
えます。`C-M-c'で再帰編集から抜けると、再度どうするかを聞いてきます。こ
こでSPCを打つと、キーボードマクロの残りの部分が実行されます。キーボード
マクロの残りの部分が望みどおりの動作をする状態にポイントやテキストを保っ
ておくのは、ユーザーの責任です。

`C-u C-x q'、つまり、数引数を指定した`C-x q'は、まったく違った動作をしま
す。キーボードマクロの定義中でも実行中でも、キーボードから入力を受け付け
る再帰編集に入ります。定義中の場合、再帰編集の中で行った操作はマクロの一
部にはなりません。実行中の場合、再帰編集の中で各反復ごとに個別の編集を行
う機会が得られます。*Note Recursive Edit::。



File: emacs-ja.info, Node: Key Bindings, Next: Keyboard Translations, Prev: Keyboard Macros, Up: Customization

キーバインディングのカスタマイズ
================================

本節では、コマンドをキーに対応付ける"キーバインディング"と、キーバインディ
ングを記録する"キーマップ"について説明します。また、キーバインディングを
カスタマイズする方法についても説明します。

コマンドとは、対話利用向けに定義されたLisp関数であることを思い出してくだ
さい。コマンドには、他のLisp関数と同様、通常、英小文字とハイフンから成る
関数名前が付いています。

* Menu:

* Keymaps::             Generalities.  The global keymap.
* Prefix Keymaps::      Keymaps for prefix keys.
* Local Keymaps::       Major and minor modes have their own keymaps.
* Minibuffer Maps::     The minibuffer uses its own local keymaps.
* Rebinding::           How to redefine one key's meaning conveniently.
* Init Rebinding::      Rebinding keys with your init file, `.emacs'.
* Function Keys::       Rebinding terminal function keys.
* Named ASCII Chars::   Distinguishing TAB from `C-i', and so on.
* Non-ASCII Rebinding:: Rebinding non-ASCII characters such as Latin-1.
* Mouse Buttons::       Rebinding mouse buttons in Emacs.
* Disabling::           Disabling a command means confirmation is required
                          before it can be executed.  This is done to protect
                          beginners from surprises.



File: emacs-ja.info, Node: Keymaps, Next: Prefix Keymaps, Up: Key Bindings

キーマップ
----------

キー列とコマンド関数との対応は"キーマップ"と呼ばれるデータ構造に保持され
ています。Emacsには数多くのキーマップがあり、それぞれが特定の場面で使わ
れます。

"キー列"（または単に"キー"）とは、ひとまとまりの意味を持つ"入力イベント"
の並びをいいます。入力イベントは、文字、ファンクションキー、マウスボタン、
つまり、端末から計算機に送ることができるすべての入力から成ります。キー列
の意味付けは、どのコマンドを実行するかを表す"バインディング"によって決ま
ります。キーマップの役割は、これらのバインディングを保持することです。

"グローバル"キーマップはもっとも重要なキーマップですが、それはグローバル
キーマップがつねに有効だからです。グローバルキーマップは基本
（fundamental）モードのキーを定義します。つまり、そこに含まれる定義の大
部分は、ほとんどまたはすべてのメジャーモードに共通のものです。各メジャー／
マイナモードは、グローバルキーマップの定義の一部を置き換えるような独自の
キーマップを持つことができます。

たとえば、`g'のような自己挿入文字を打つとその文字がバッファに挿入される
のは、グローバルキーマップでこれらのキーが`self-insert-command'に対応付
けられているからです。また、`C-a'のような標準の編集コマンドも、その意味
付けはグローバルキーマップに書かれています。`M-x global-set-key'のような
バインディングを変更するコマンド群は、グローバルキーマップの適切な箇所に
新しいバインディングを書き込みます。

メタ文字はやや違った動作になります。Emacsでは、メタ文字はESCで始まる文字
列に変換されます。ですから、`M-a'という入力はつねにEmacsの中では`ESC a'
に置き換えられて処理されます。つまり、メタ文字は単一の入力イベントですが、
キーバインディングの観点では2つのイベントとして扱われます。こうなってい
る理由は歴史的なもので、将来は変わる可能性もあります。

最近のほとんどのキーボードには、文字キーの他にファンクションキーがありま
す。ファンクションキーは文字キーと同様に入力イベントを送出し、キーマップ
はそれに対応するバインディングを保持することができます。

多くの端末では、ファンクションキーを打つとコンピュータには一連の文字列が
送られます。具体的にどのファンクションキーがどんな文字列を送るかは端末に
よってまちまちです。（多くの場合、文字列は`ESC ['で始まる。）Emacsが使用
中の端末種別を正しく認識していれば、キー列（の先頭でだけでなく）に現れる
ファンクションキーに対応した文字列を正しく判別できます。ですから、多くの
場合、ファンクションキーの打鍵も1つの入力イベントとして直接Emacsに送られ
ているとみなして、文字列としての表現形式は無視してかまいません。

マウスボタンも入力イベントを発生させます。これらのイベントには、追加デー
タ、つまり、ボタンを押したり放したりしたときのウィンドウとその中での位置、
時刻が付属しています。ただし、キーバインディングに関しては、どのボタンが
使われたかだけが問題となります。残りの情報は、コマンドがこれらの情報を参
照する場合だけ意味を持ちます。（通常、マウスから起動できるコマンドは、こ
れらの情報を参照する。）

キーマップは1つのイベントに対する定義のみを保持します。複数キーの列から
成る複数のイベントの解釈には、キーマップの連鎖が使われます。最初のキーマッ
プが最初のイベントの定義を保持し、その定義がつぎのキーマップになっていて、
2番目のイベントの定義を保持し、というようになっています。

キー列にはファンクションキーと文字キーとが混ざっていてもかまいません。た
とえば、`C-x SELECT'というのも許されます。SELECTをプレフィックスキーとし
て定義しておけば、`SELECT C-n'というのも許されます。マウスイベントとキー
ボードイベントを混ぜることさえ可能ですが、そうすると打ち込むのが面倒です
からお勧めしません。

ユーザーはどんなキー列でも再定義して利用できますが、`C-c'に続けて1文字と
いうキー列だけを使うのが最善です。このキー列は『ユーザー定義のために予約』
されていて、正しく設計されたEmacsの各種拡張とは衝突しないようになってい
るからです。F5からF9までのファンクションキーもユーザー定義のために予約し
てあります。これ以外のキー列を再定義すると、同じキーを再定義する拡張やメ
ジャーモードによってあなたの定義が上書きされてしまう可能性があります。



File: emacs-ja.info, Node: Prefix Keymaps, Next: Local Keymaps, Prev: Keymaps, Up: Key Bindings

プレフィックスキーマップ
------------------------

`C-x'やESCのようなプレフィックスキーはそれぞれ専用のキーマップを持ってい
て、そこにはそのプレフィックスキーに続くイベントの定義が保持されています。

プレフィックスキーの定義は、通常、それに続くイベントの定義を検索するため
のキーマップです。あるいは、プレフィックスキーの定義がLispシンボルであっ
て、その関数の定義がキーマップというのもあります。どちらでも効果は同じで
すが、後者では、プレフィックスキーにコマンド名を与えてその用途を示すこと
ができます。このため、`C-x'にバインドされているのはシンボル
`Ctl-X-Prefix'であり、その関数定義は`C-x'コマンド群に対応するキーマップ
です。`C-c'、`C-x'、`C-h'、ESCはグローバルマップでプレフィックスキーとし
て定義されていますから、これらはつねにプレフィックスキーとして使用できま
す。

通常のプレフィックスキーに加えて、メニューバーを表す『仮想的なプレフィッ
クスキー』があります。メニューバーのキーバインディングに関する特別な点に
ついては*Note メニューバー: (elisp)Menu Barを参照してください。ポップアッ
プメニューを表示させるマウスボタンイベントもまた、プレフィックスキーです。
こちらの詳細については*Note メニューキーマップ: (elisp)Menu Keymapsを参
照してください。

決まった変数に格納されているプレフィックスキーマップもあります。

   * `ctl-x-map'は`C-x'に続くキーを探すためのマップを納めた変数名。
   * `help-map'は`C-h'に続くキーを探すためのマップを納めた変数名。
   * `esc-map'はESCに続くキーを探すためのマップを納めた変数名。つまり、
     すべてのメタ文字は実際にはこのマップで定義されている。
   * `ctl-x-4-map'は`C-x 4'に続くキーを探すためのマップを納めた変数名。
   * `mode-specific-map'は`C-c'に続くキーを探すためのマップを納めた変数
     名。



File: emacs-ja.info, Node: Local Keymaps, Next: Minibuffer Maps, Prev: Prefix Keymaps, Up: Key Bindings

ローカルキーマップ
------------------

これまではグローバルキーマップの諸側面について説明しました。メジャーモー
ド固有のキーバインディングを"ローカルキーマップ"に定義することで、各メ
ジャーモードはEmacsの動作を変更します。たとえば、Cモードでは、TABをCのコー
ドの現在行を字下げする機能に差し替えます。バッファ内の一部のテキストで、
そのバッファのメジャーモードのかわりとなる固有のキーマップを指定すること
もできます。

マイナモードもローカルキーマップを持てます。その場合、マイナモードが生き
ているときには、そのキーマップがメジャーモードのローカルキーマップやグロー
バルキーマップに優先します。

Lispモードおよびその他のいくつかのメジャーモードのローカルキーマップは、
そのモードを使っていないときでもつねに存在します。これらのキーマップは、
`lisp-mode-map'などの変数に格納されています。さほど頻繁に使われないメジャー
モードの場合は、そのモードがセッションの中で初めて起動されたときにローカ
ルキーマップが作られます。これは、メモリを節約するためです。このようなモー
ドのキーマップを変更したい場合には、当該メジャーモードの"モードフック"を
使う必要があります（以下を参照）。

すべてのマイナモードのキーマップは、あらかじめ作られています。マイナモー
ドのキーマップ作成をそのマイナモードが最初に起動されるまで遅延させる方法
はありません。

ローカルキーマップでは、その中のあるキーの定義をプレフィックスキーマップ
とすることで、そのキーをローカルなプレフィックスキーとして再定義できます。
そのキーがグローバルにもプレフィックスキーであると定義されているなら、ロー
カルキーマップとグローバルキーマップの内容は実質的に統合され、プレフィッ
クスキーに続くイベントは両方のキーマップで検索されます。したがって、ある
モードのローカルキーマップが`C-c'を別のキーマップとして定義し、そのキー
マップでは`C-z'をコマンドとして定義すると、これらによって`C-c C-z'のロー
カルな意味が与えられます。しかし、これは`C-c'で始まる他のキー列には影響
しません。あるキー列が独自のローカルなバインディングを持たなければ、グロー
バルなバインディングが意味を持つからです。

いいかえれば、Emacsが複数イベントから成るキー列を扱う方法は、複数のキー
マップから1つずつ、キー列全体に一致するバインディングを探すのです。まず、
マイナモードが生きていればそのキーマップを検索し、つぎにメジャーモードの
キーマップを検索し、最後にグローバルキーマップを検索します。これは厳密に
はキーの検索動作とは違いますが、通常の状況でどうなるか理解するには十分で
す。

メジャーモードのローカルバインディングを変更するには、そのモードのローカ
ルキーマップを変更する必要があります。通常、そのためにはそのモードが最初
に使われるまで待つ必要があります。というのは、ほどんどのメジャーモードは
使われるまでキーマップを作成しないからです。ですから、個人の`~/.emacs'ファ
イルでメジャーモードのバインディングを変更したければ、そのモードのモード
フックを使ってそのモードが最初に使われるまで（変更を）遅らせる必要があり
ます。

たとえば、texinfoモードを選択する`texinfo-mode'コマンドはフック
`texinfo-mode-hook'を実行します。このフックを使って`C-c n'と`C-c p'に対
する（有益ではないですが）ローカルバインディングをtexinfoモードに追加す
るには、つぎのようにします。

     (add-hook 'texinfo-mode-hook
               '(lambda ()
                  (define-key texinfo-mode-map
                              "\C-cp"
                              'backward-paragraph)
                  (define-key texinfo-mode-map
                              "\C-cn"
                              'forward-paragraph)
                  ))

*Note Hooks::。



File: emacs-ja.info, Node: Minibuffer Maps, Next: Rebinding, Prev: Local Keymaps, Up: Key Bindings

ミニバッファのキーマップ
------------------------

ミニバッファも一群の専用ローカルキーマップを持っています。それらには各種
の補完や脱出コマンドが定義されています。

   * `minibuffer-local-map'は通常の入力に使われる（補完なし）。
   * `minibuffer-local-ns-map'も同様。ただし、SPCは、RETと同様に、脱出動
     作である。これは主にMocklispとの互換性のために使われる。
   * `minibuffer-local-completion-map'は弱い補完に使われる。
   * `minibuffer-local-must-match-map'は強い補完と慎重な補完に使われる。



File: emacs-ja.info, Node: Rebinding, Next: Init Rebinding, Prev: Minibuffer Maps, Up: Key Bindings

キーバインディングの対話的な変更
--------------------------------

Emacsのキーを再定義するには、キーマップの対応する項目を変更すればよいの
です。グローバルキーマップを変更すると、その変更は（同じキーに対して独自
のローカルな定義をしているメジャーモードを除く）すべてのメジャーモードに
影響します。あるいは、カレントバッファのローカルマップを変更すると、同じ
メジャーモードを使っているすべてバッファに影響が及びます。

`M-x global-set-key RET KEY CMD RET'
     CMDを実行するようにKEYをグローバルに定義する。
`M-x local-set-key RET KEY CMD RET'
     CMDを実行するようにKEYを（現在のメジャーモードで）ローカルに定義す
     る。
`M-x global-unset-key RET KEY'
     KEYをグローバルマップで未定義にする。
`M-x local-unset-key RET KEY'
     KEYを（現在のメジャーモードで）ローカルに未定義にする。

たとえば、Emacsを休止してログインシェルでコマンドを実行するかわりに、
Emacsバッファ内のサブシェルでコマンドを実行したいとします。通常、（Xウィ
ンドウシステムを使っていない場合）`C-z'は関数`suspend-emacs'にバインドさ
れていますが、つぎのようにこのキーを`shell'にバインドすれば、このキーで
Emacs内の対話的サブシェルを起動するように変更できます。

     M-x global-set-key RET C-z shell RET

`global-set-key'はキー列に続けてコマンド名を読み取ります。使いたいキーを
打鍵すると、どのキーをバインドしたいのかを確認するつぎのようなメッセージ
が表示されます。

     Set key C-z to command: 

同じ手順で、ファンクションキーやマウスイベントを再定義できます。バインド
すべきキーを指定するときに、キーのかわりにファンクションキーを押したりマ
ウスボタンをクリックしてください。

複数イベントから成るキーも単一イベントのキーと同様にして再定義できます。
Emacsは再定義すべきキー列が完成するまで（つまりプレフィックスキーではな
いキーが出てくるまで）イベントを読み続けます。たとえば、KEYとして`C-f'を
打てばそれで終りですから、ミニバッファはただちにCMDを読む状態になります。
一方、`C-x'を打つとさらにその先のキーを読みます。そこで`4'を打つと、さら
にその先のキーが読まれる、というようになります。たとえば、

     M-x global-set-key RET C-x 4 $ spell-other-window RET

では、`C-x 4 $'を（実在しない）コマンド`spell-other-window'にバインドし
ます。

`C-c'に続けて英字という2文字のキー列は、ユーザーのカスタマイズ用に予約さ
れています。Lispプログラムはこれらのキー列を定義しないことになっています
から、これらのキー列のバインディングはどのメジャーモードでも使え、いかな
る機能とも干渉しないはずです。

`global-unset-key'でキーのグローバルな定義を取り除けます。そのキーは"未
定義"になります。未定義のキーを打つと、Emacsはベルを鳴らします。同様に、
`local-unset-key'は現在のメジャーモードでキーを未定義にしますから、グロー
バルな定義（あるいはグローバルでの未定義状態）が現在のメジャーモードでふ
たたび有効になります。

キーを再定義（または未定義に）して、あとでもとに戻したいと思った場合、キー
を未定義にしてももとには戻りません。キーの標準定義を設定し直す必要があり
ます。キーの標準定義を調べるには、基本（fundamental）モードのバッファに
いって`C-h c'を使います。本書のキーの説明にもコマンド名を掲載してありま
す。

まちがって、あるコマンドを実行することを防ぎたければ、キーを未定義にする
のでなく、コマンドを使用禁止にするのがよいでしょう。必要になったときに使
用禁止コマンドを起動するのは造作もありません。



File: emacs-ja.info, Node: Init Rebinding, Next: Function Keys, Prev: Rebinding, Up: Key Bindings

初期化ファイルでのキーの変更
----------------------------

いつでもあるキーバインディングを設定しておきたければ、その指定を個人の
`.emacs'ファイルにLispのコードとして書いておきます。

これを行うもっとも簡単な方法は、ASCII文字とメタ修飾付きのASCII文字に対し
てのみ使えます。たとえば、`C-z'を`shell'にバインドするにはつぎのようにし
ます。

     (global-set-key "\C-z" 'shell)

この例では1つの文字`C-z'から成る文字列定数を指定しています。コマンド名
`shell'のまえのクォート「'」は、`shell'を変数ではなく定数シンボルとして
扱う印です。クォートがないと、Emacsは`shell'を変数としてその値をただちに
評価しようとします。すると、望んでいることではなく、エラーになります。

つぎは、2文字のキー列をバインドする例です。

     (global-set-key "\C-xl" 'make-symbolic-link)

キー列にファンクションキーやマウスボタンイベントが含まれていたり、`C-='
や`H-a'などの非ASCII文字が含まれているなら、文字列よりもっと一般的な指定
方法であるベクタを使った指定を使う必要があります。

Emacs Lispでのベクタの書き方は、その要素を中括弧（`[...]'）で囲みます。
要素は空白で区切ります。要素がシンボルであれば、単にその名前だけを書けば
よく、区切り記号などは不要です。要素が文字であれば、Lispの文字定数として、
つまり`?'に続けてその文字が文字列中に現れるのと同じ書き方で、書いてくだ
さい。

ベクタを使って`C-='（ASCIIの範囲にないコントロール文字）、`H-a'（ハイパー
文字。ASCIIにはハイパー文字は含まれない）、F7（ファンクションキー）、
`C-Mouse-1'（キーボード修飾付きのマウスボタン）をバインドする例を示しま
す。

     (global-set-key [?\C-=] 'make-symbolic-link)
     (global-set-key [?\H-a] 'make-symbolic-link)
     (global-set-key [f7] 'make-symbolic-link)
     (global-set-key [C-mouse-1] 'make-symbolic-link)

単純な（文字列ですむ）場合にベクタを使ってもかまいません。先の2つの例を
ベクタを使うように書き直すとつぎのようになります。

     (global-set-key [?\C-z] 'shell)

     (global-set-key [?\C-x ?l] 'make-symbolic-link)



File: emacs-ja.info, Node: Function Keys, Next: Named ASCII Chars, Prev: Init Rebinding, Up: Key Bindings

ファンクションキーの再定義
--------------------------

キー列には通常の文字以外にもファンクションキーを含めることができます。キー
ボードの文字がLispの文字（実は整数です）で表されるのに対し、ファンクショ
ンキーはLispシンボルで表されます。ファンクションキーに単語のラベルが付い
ているなら、その単語が対応するLispシンボルの名前になります。たとえば普通
に見られるファンクションキーとLispシンボルの対応はつぎのとおりです。

`left', `up', `right', `down'
     カーソル矢印キー。

`begin', `end', `home', `next', `prior'
     その他のカーソル移動キー。

`select', `print', `execute', `backtab'
`insert', `undo', `redo', `clearline'
`insertline', `deleteline', `insertchar', `deletechar'
     その他のファンクションキー。

`f1', `f2', ... `f35'
     （キーボードの上端に並んでいる）番号の付いたファンクションキー。

`kp-add', `kp-subtract', `kp-multiply', `kp-divide'
`kp-backtab', `kp-space', `kp-tab', `kp-enter'
`kp-separator', `kp-decimal', `kp-equal'
     （普通のキーボードの右側にまとまっている）キーパッドのキーで、名前
     や句読点が印字されているもの。

`kp-0', `kp-1', ... `kp-9'
     キーパッドの数字キー

`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     キーパッドのPFキー。

これらの名前は習慣的なものですが、システムによっては（とりわけXウィンド
ウシステムを使っている場合は）、別の名前になっている場合があります。ある
ファンクションキーにどのシンボルが対応しているか調べるには、`C-h c'に続
いてそのキーを打鍵してください。

ファンクションキーのシンボルを含むキー列（あるいは、ASCII以外の文字を含
むもの）は文字列ではなくベクタで指定してください。ベクタの構文では要素と
要素のあいだは空白で区切り、全体を中括弧``[...]''で囲みます。たとえば、
ファンクションキー`f1'をコマンド`rmail'にバインドするには、つぎのように
します。

     (global-set-key [f1] 'rmail)

右矢印キーをコマンド`fowared-char'にバインドするには、つぎのようにします。

     (global-set-key [right] 'forward-char)

これは、シンボル`right'を要素とするベクタのLisp構文です。（このバインディ
ングはEmacsのデフォルト設定に入っている。）

ベクタを用いたキーの再定義ついてより詳しくは、*Note Init Rebinding::。

キー列の中でファンクションキーと文字を混ぜることができます。以下の例は、
`C-x NEXT'をコマンド`forward-page'にバインドしています。

     (global-set-key [?\C-x next] 'forward-page)

ここで、`?\C-x'はLispの文字定数で、文字`C-x'を表します。ベクタのもう1つ
の要素である`next'は、シンボルですから`?'は不要です。

ファンクションキーに対して、修飾キーCTRL、META、HYPER、SUPER、ALT、SHIFT
を指定できます。これらの修飾キーを指定するには、シンボル名のまえに`C-'、
`M-'、`H-'、`s-'、`A-'、`S-'を付けてください。たとえば、
`Hyper-Meta-RIGHT'で1語先へ移動するにはつぎのように指定します。

     (global-set-key [H-M-right] 'forward-word)



File: emacs-ja.info, Node: Named ASCII Chars, Next: Non-ASCII Rebinding, Prev: Function Keys, Up: Key Bindings

名前の付いたASCIIコントロール文字
---------------------------------

TAB、RET、BS、LFD、ESC、DELはもともとASCIIの特定のコントロール文字に対応
していたのですが、よく使われるため別にそれ専用のキーを持つようになりまし
た。のちに人々はEmacsでこれらのキーとそれらと『同じ』文字をCTRLキーと組
み合わせて打鍵した場合とを区別できると便利だと気がつきました。

EmacsではXウィンドウシステムを使っている場合、これら2種類の入力を区別し
ます。つまり、キーボード上の特殊キーの方は`tab'、`return'、`backspace'、
`linefeed'、`escape'、`delete'という名前のファンクションキーとして扱うの
です。これらのファンクションキーは、*もし*それ固有のバインディングが指定
されていなければ、自動的に対応するASCII文字に変換されます。その結果、特
にこの2種類を区別したいと思わない限りは、ユーザーもLispプログラムもこれ
らの区分について気にする必要はありません。

（たとえば）TABと`C-i'を区別したくないなら、ASCII文字TAB（8進コード011）
に対応するバインディング1つだけを指定してください。区別したいのなら、こ
のASCII文字に対するバインディングに加えて、『ファンクションキー』`tab'に
対するバインディングも指定します。

通常のASCII端末では、TABと`C-i' （および上記の対応する組のそれぞれ）を区
別する方法はありません。というのは、端末はどちらが押されても同じ文字を送
出するからです。



File: emacs-ja.info, Node: Non-ASCII Rebinding

キーボード上の非ASCII文字
-------------------------

アクセント付き文字などの非ASCII文字を送出するキーがあるキーボードでは、
それらのキーの再定義には、少々トリックが必要です。2つの解決方法がありま
す。1つめは、`set-keyboard-coding-system'（*Note Specify Coding::）を使っ
て、キーボードのコーディングシステムを指定することです。そうすれば、つぎ
のように書いて、通常の方法でそれらのキーを再定義できます。

     (global-set-key [?CHAR] 'some-function)

ただし、CHARを挿入するには、定義したいキーを打ちます。

キーボードのコーディングシステムを指定しないと、上のようにはできません。
そのかわりに、端末が実際に送出するコードを調べる必要があります。Emacsで
これを簡単に行うには、`C-x b temp RET'で空バッファを作成し、`M-x
toggle-enable-multibyte-characters RET'でユニバイトにしてから、このバッ
ファに文字を挿入するキーを打ちます。

文字のまえにポイントを移動して、`C-b C-x ='と打ちます。8進数、10進数、16
進数の3通りで表した文字コードを括弧で括ったメッセージがミニバッファに表
示されます。定義するには、3つの数字の2番目、つまり、10進数をベクタの中に
書きます。

     (global-set-key [DECIMAL-CODE] 'some-function)



File: emacs-ja.info, Node: Mouse Buttons, Next: Disabling, Prev: Non-ASCII Rebinding, Up: Key Bindings

マウスボタンの再定義
--------------------

Emacsではマウスボタンを表すのにもLispシンボルを使います。Emacsのもっとも
一般的なマウスイベントは"クリック"（click）イベントです。これはマウスボ
タンを押して、マウスを移動せずにボタンを放したときに発生します。ボタンを
押した状態でマウスを移動すると"ドラッグ"（drag）イベントになります。そし
て最後にマウスボタンを放したときにも、やはり"ドラッグ"イベントが発生しま
す。

基本的なクリックイベントに対応するシンボルは、左ボタンに対しては
`mouse-1'、左から2番目のボタンに対しては`mouse-2'、などとなっています。2
番目のボタンをクリックしたときカレントウィンドウを分割するには、つぎのよ
うに設定します。

     (global-set-key [mouse-2] 'split-window-vertically)

ドラッグイベントについても同様ですが、イベント名の`mouse'のまえに`drag-'
が付きます。たとえば、第1ボタンを押したままドラッグすると`drag-mouse-1'
イベントが発生します。

マウスボタンが押されたときに発生するイベントに対してバインディングを指定
することもできます。これらのイベントは`drag-'のかわりに`down-'で始まりま
す。これらのイベントはキーバインディングが定義されているときだけ生成され
ます。`down-'イベントのあとには、必ず、対応するクリック／ドラグッイベン
トが発生します。

必要ならば、シングルクリック／ダブルクリック／トリプルクリックを区別する
こともできます。ダブルクリックとは、ほぼ同じ位置でマウスボタンを2回クリッ
クすることです。最初のクリックで通常のクリックイベントが発生します。最初
のクリックから十分短い時間内に2回目のクリックが起こると、クリックイベン
トではなくダブルクリックイベントが発生します。ダブルクリックイベントは、
`double-'で始まります。たとえば、`double-mouse-3'です。

つまり、同じ場所で2回クリックがあったとき、2回目のクリックに特別な意味を
与えることはできますが、ただし最初のクリックで発生する通常のシングルクリッ
クに対して定義された動作も実行されることを前提としなければなりません。

このような制限のため、ダブルクリックで行えることが制約されますが、ユーザー
インターフェイスデザイナは、よいユーザーインターフェイスがつねにそのよう
な制約に従うべきだとの考えを述べています。つまり、ダブルクリックはシング
ルクリックと類似した動作をすべきであり、『それよりいくらか多く』の動作を
するのがよい、ということです。そして、ダブルクリックイベントに対応するコ
マンドがその「いくらか多く」のぶんの動作を行うべきだということです。

ダブルクリックイベントに対してバインディングが定義されていなければ、ダブ
ルクリックは2つのシングルクリックとして扱われます。その結果、シングルク
リックに対応するコマンドが2回実行されることになります。

Emacsではさらにトリプルクリックイベントも使えます（その場合、名前は
`triple-'で始まる）。しかし4重クリックをイベントタイプとして区別しません。
ですから、3回目以降の連続したクリックは、すべてトリプルクリックイベント
として報告されます。ただし、連続したクリックの回数はイベントリストに記録
されていますから、本当に4重以上のクリックを区別したければそうすることも
できます。4重以上のクリックに特別な意味を与えるのはお勧めできませんが、4
回だと1回と同じ、5回だと2回と同じというように3つの選択肢のあいだで巡回で
きるようにするのは場合によっては有効かもしれません。

Emacsはまた、ドラッグやボタンイベントでも複数回の押し下げを記録します。
たとえば、ボタンを2回押してからそのままマウスを移動した場合、Emacsは
`double-drag-'で始まるイベントを生成します。ドラッグでなくボタンを押し下
げただけの場合は同様に、`double-down-'で始まるイベントを生成します（ただ
し、他のボタンイベントと同様に、そのイベントに対するバインディングがなけ
れば無視される）。

変数`double-click-time'は、どれくらいの時間間隔内であれば2つの隣接するク
リックをダブルクリックとみなすかを指定します。単位はミリ秒です。値が
`nil'であれば、ダブルクリックを検出しません。値が`t'であれば、時間間隔の
上限はないものとして扱います。

マウスイベントに対応するシンボルにはさらに、`C-'、`M-'、`H-'、`s-'、`A-'、
`S-'の各プレフィックスで、修飾キーの情報も組み込めます。順番は、プレフィッ
クスに続いて`double-'や`triple-'があり、そのあとが`drag-'や`down-'という
ことになります。

フレームには、モード行やスクロールバーなどのバッファ中のテキストを表示す
る以外の部分もあります。マウスイベントがこれらの特別な部分で発生したもの
かどうかを調べるために、ダミーの「プレフィックスキー」があります。たとえ
ば、マウスがモード行でクリックされた場合、まず`mode-line'というプレフィッ
クスキーが送られ、続いて通常のマウスボタンに対応したイベントが送られます。
ですから、モード行で第1ボタンがクリックされたときに`scroll-up'を実行する
にはつぎのようにします。

     (global-set-key [mode-line mouse-1] 'scroll-up)

ダミーのプレフィックスキーとその意味はつぎのとおりです。

`mode-line'
     マウスがウィンドウのモード行にある。
`vertical-line'
     マウスが横に隣接するウィンドウ間の境界線上にある。（スクロールバー
     を表示させると、境界線のかわりにスクロールバーが現れる。）
`vertical-scroll-bar'
     マウスが縦スクロールバー上にある。（Emacsで使えるスクロールバーは、
     現在のところ縦スクロールバーのみ。）

1つのキー列の中に2つ以上のマウスボタンイベントを含めることもできますが、
普通はあまりしないでしょう。



File: emacs-ja.info, Node: Disabling, Prev: Mouse Buttons, Up: Key Bindings

使用禁止コマンド
----------------

コマンドを使用禁止にすると、コマンドの実行にはユーザーの確認が必要になり
ます。コマンドを使用禁止にする目的は、初心者がそのコマンドをまちがって実
行してしまい、混乱するのを防ぐためです。

Emacs上で使用禁止コマンドを対話的に実行しようとすると、コマンド名、説明
文、とりあえずどうすべきかの指示を表示したウィンドウが現れます。つぎに
Emacsはコマンドを実行するか、使用禁止を解除してから実行するか、実行を取
り消すかを問い合わせてきます。コマンドの使用禁止を解除することを選ぶと、
Emacsさらに、以後恒久的にそうするのか、または現在のセッション内だけそう
するのかも問い合わせてきます。恒久的に使えるようにすると、自動的に個人の
`.emacs'ファイルを編集します。

コマンドを使用禁止にする機構は、コマンドに対応するLispシンボルの属性
`disabled'に`nil'以外の値を設定することです。これを行うLispプログラムは
つぎのようになります。

     (put 'delete-region 'disabled t)

属性`disabled'の値が文字列であれば、コマンドを使用しようとしたときに表示
されるメッセージにその文字列も含まれるようになります。

     (put 'delete-region 'disabled
          "It's better to use `kill-region' instead.\n")

コマンドを使用禁止にするには、`.emacs'ファイルを直接編集するか、かわって
このファイルを編集するコマンド`M-x disable-command'を使います。同様に、
コマンド`M-x enable-command'は、`.emacs'ファイルを編集してコマンドを恒久
的に使える状態にします。*Note Init File::。

コマンドが使用禁止であるかどうかは、そのコマンドを起動するキー列には無関
係です。したがって、`M-x'でそのコマンドを起動してもEmacsはその可否を問い
合わせてきます。Lispプログラムからコマンドを関数として呼び出す場合には使
用禁止にしても何の効果もありません。



File: emacs-ja.info, Node: Keyboard Translations, Next: Syntax, Prev: Key Bindings, Up: Customization

キーボード変換
==============

キーボードの機種によっては、Emacsが使用するすべての特殊文字を送ってくれ
ないものがあります。もっともよくある問題は、DEL文字に関するものです。い
くつかのキーボードでは、このきわめて重要な文字を簡単に打ち込む手段があり
ません。それは、削除には`C-h'を使うことを前提としているからです。そのよ
うなキーボードで削除のためのキーを打つと、Emacsはそれをプレフィックス文
字`C-h'として解釈し、どのヘルプ機能を使うか問い合わせてきてしまいます。
それはユーザーがしたかったことではありません。

Emacs内でこの問題を回避するには、`C-h'をDELに、DELを`C-h'に変換するキー
ボード変換を以下のように設定することで回避できます。

     ;; C-hをDELに変換する。
     (keyboard-translate ?\C-h ?\C-?)

     ;; DELをC-hに変換する。
     (keyboard-translate ?\C-? ?\C-h)

キーボード変換はキーマップによるキーバインディング（*Note Keymaps::）と
同じではありません。Emacsには状況ごとに使い分けられる多数のキーマップが
あるのに対し、キーボード変換は一式だけしかなく、Emacsが端末から読むすべ
ての文字に対してその変換が適用されます。キーボード変換は入力処理のいちば
ん下位のレベルで行われ、キーマップ上の検索はキーボード変換を施した結果に
対して行われます。

XウィンドウシステムではDELETEというキーはファンクションキーであり、ASCII
文字DELとは別ものです。*Note Named ASCII Chars::。キーボード変換はASCII
文字入力だけに適用され、ファンクションキーとは無関係ですから、Xウィンド
ウシステムでは上の例はDELETEキーに対して効果をもたらしません。しかし、X
ウィンドウシステムでは上のようなキーボード変換そのものが不要です。という
のは、EmacsはXウィンドウシステムではBACKSPACEキーと`C-h'も区別でき、通常、
BAKSPACEをDELとして扱うからです。

キーボード変換の使い方に関する詳しい情報は、*Note 入力イベントの変換:
(elisp)Translating Inputを参照してください。



File: emacs-ja.info, Node: Syntax, Next: Init File, Prev: Keyboard Translations, Up: Customization

構文テーブル
============

単語や対応した括弧の対を認識するEmacsコマンドはすべて、"構文テーブル"
（syntax table）によって制御されます。構文テーブルは、どの文字が開き括弧
で、どの文字が単語の中身で、どの文字がシングルクォートかといったことを記
述しています。各メジャーモードにはそれぞれ専用の構文テーブルがあり（ただ
し、互いに関係のあるメジャーモードが1つの構文テーブルを共用することはあ
る）、各バッファごとにそのときのメジャーモードの構文テーブルが使われます。
カレントバッファに設定されている構文テーブルはすべてのコマンドが使うので、
以下ではこれを『現在の』構文テーブルと呼びます。構文テーブルは文字テーブ
ル（char-table）型のLispオブジェクトであり、その要素は数値です。

現在の構文テーブルの内容に関する記述を表示するには、`C-h s'
（`descirbe-syntax'）を使います。記述の表示には各文字ごとに、その文字の
現在の構文を設定するために`modify-syntax-entry'に渡すべき文字列、および、
その文字列の英語での説明が含まれます。

構文テーブルに関する詳しい情報については、*Note 構文テーブル:
(elisp)Syntax Tablesを参照してください。



File: emacs-ja.info, Node: Init File, Prev: Syntax, Up: Customization

初期化ファイル`~/.emacs'
========================

Emacsが実行を開始するとき、通常はユーザーのホームディレクトリにあるファ
イル`.emacs'や`.emacs.el'からLispプログラムをロードします。このファイル
がEmacsの初期化の仕方を指定するので、このファイルのことを"初期化ファイル
"（init file）と呼びます。コマンド行オプション`-q'で、Emacsに初期化ファ
イルを読まないことを指示したり、`-u'（あるいは`--user'）で、別のユーザー
の初期化ファイルを指定できます（*Note Entering Emacs::）。

"デフォルトの初期化ファイル"もあります。これは`default.el'という名前のラ
イブラリファイルで、Emacsはライブラリ探索パスをとおしてその場所を探しま
す。Emacsの配布には`default.el'は含まれていません。ローカルなカスタマイ
ズのためにサイトで`default.el'を用意することもあります。このファイルがあ
れば（`-q'を指定したときを除いて）Emacsを開始するときつねにロードされま
す。しかし、あるならば個人の初期化ファイルが最初にロードされます。その中
で`inhibit-default-init'に`nil'以外の値を設定すると、`default.el'はロー
ドされません。

各サイトには"サイトスタートアップファイル"があるかもしれません。あるなら
ば、このファイルの名前は`site-start.el'です。Emacsはユーザーの初期化ファ
イルを読むまえにこのファイルもロードします。このファイルのロードを抑止す
るには、オプション`-no-site-file'を指定します。

`.emacs'に大量のコードがある場合には、`~/.emacs.el'と改名してバイトコン
パイルしておくべきです。Emacs Lispプログラムのコンパイルについてより詳し
くは、*Note バイトコンパイル: (elisp)Byte Compilation。

単なるカスタマイズを超えるような実際のEmacsプログラムを書くのであれば、
`The Emacs Lisp Reference Manual' (1) (*Note Init File-Footnotes::)を読
むべきです。*Note Emacs Lisp: (elisp)Top。

* Menu:

* Init Syntax::	        Syntax of constants in Emacs Lisp.
* Init Examples::       How to do some things with an init file.
* Terminal Init::       Each terminal type can have an init file.
* Find Init::	        How Emacs finds the init file.


File: emacs-ja.info  Node: Init File-Footnotes, Up: Init File

(1) 【訳注】日本語訳：『Emacs Lispリファレンスマニュアル』、アスキー出版
局、ISBN4-7561-3414-9




File: emacs-ja.info, Node: Init Syntax, Next: Init Examples, Up: Init File

初期化ファイルの構文
--------------------

ファイル`.emacs'にはLispの関数呼び出し式を書きます。関数呼び出しは、関数
名に続けて引数リストを並べ、全体を括弧で囲みます。たとえば、`(setq
fill-column 60)'は、関数`setq'によって、変数`fill-column'（*Note
Filling::）に60を設定します。

`setq'の2番目の引数は変数の新しい値を表す式です。これは、定数でも、変数
でも、関数呼び出し式でもかまいません。`.emacs'ファイルでは定数を使うこと
がもっとも多いでしょう。定数にはつぎのものがあります。

数値：
     数値は10進表記し、先頭にマイナス符号があってもよい。

文字列：
     Lispの文字列の構文はCの文字列の構文とほぼ同じだが、多少違うところも
     ある。文字列定数の始まりと終りにはダブルクォートを使う。

     文字列の中には、改行や特殊文字をそのまま入れることができる。しかし、
     バックスラッシュで始まる形式、つまり、改行は`\n'、バックスペースは
     `\b'、復帰は`\r'、タブは`\t'、ページ送りは`\f'（コントロールL）、エ
     スケープは`\e'、バックスラッシュは`\\'、ダブルクォートは`\"'、8進コー
     ドOOOの文字は`\OOO'で表すことができ、そのほうが読みやすい。バックス
     ラッシュとダブルクォートの2つだけは、文字列に含めるのに必ずこのよう
     な形で書き表す必要がある。

     `\C-'はコントロール文字を表すプレフィックスとして使用できる。たとえ
     ば、`\C-s'でASCIIのコントロールSを表す。同様に、`\M-'はメタ文字を表
     すプレフィックスとして使用できる。たとえば、`\M-a'で`Meta-A'、
     `\M-\C-a'で`Control-Meta-A'を表す。

文字：
     Lispの文字定数は、`?'に続けて文字または`\'で始まるエスケープシーケ
     ンスを書いたもの。たとえば、`?x'、`?\n'、`?\)'などは文字定数。Lisp
     では文字と文字列は別ものなので注意すること。ある場面では文字列が必
     要であり、別の場面では文字が必要である。

真：
     `t'は「真」を表す。

偽：
     `nil'は「偽」を表す。

その他のLispオブジェクト：
     シングルクォートに続けてそのLispオブジェクトを書く。



File: emacs-ja.info, Node: Init Examples, Next: Terminal Init, Prev: Init Syntax, Up: Init File

初期化ファイルの例
------------------

以下にはよく使われるLispの式の例をあげておきます。

   * Cモードにおいて、行の途中でTABが押されたときにはタブ文字を挿入する
     ように設定する。

          (setq c-tab-always-indent nil)

     変数の値を「真」にするには`t'を設定し、逆に「偽」にするには`nil'を
     設定する。

   * 探索をデフォルトで大文字小文字を区別するように設定する（ただし、違
     う設定に変更しているバッファは除く）。

          (setq-default case-fold-search nil)

     ここでは`setq-default'で変数のデフォルト値を設定し、その変数に対し
     てローカルな値を設定していないすべてのバッファで有効である。`setq'
     で`case-fold-search'に値を設定すると、カレントバッファのローカルな
     値だけに影響し、初期化ファイルで記述したいこととは異なるだろう。

   * Emacsが自動的にメイルアドレスを割り出せない場合に備え、この変数に自
     分のメイルアドレスを指定する。

          (setq user-mail-address "coon@yoyodyne.com")

     メイルアドレスを必要とする多くのEmacsパッケージは、
     `user-mail-address'の値を使う。

   * 新たに作ったバッファのデフォルトのモードをテキストモードにする。

          (setq default-major-mode 'text-mode)

     `text-mode'を指定しているのは、これがテキストモードに入るためのコマ
     ンドだから。コマンド名のまえのシングルクォートは、シンボルを定数と
     して扱うため。さもないと`text-mode'という変数を参照することになって
     しまう。

   * 西ヨーロッパのほとんどの言語を扱えるLatin-1文字集合をデフォルトとす
     る (1) (*Note Init Examples-Footnotes::)。

          (set-language-environment "Latin-1")

   * テキストモードやそれに関連するモードでは、自動詰め込みモードをオン
     にする。

          (add-hook 'text-mode-hook
            '(lambda () (auto-fill-mode 1)))

     これはノーマルフック変数（*Note Hooks::）にフック関数を追加する例。
     ここでは関数として`lambda'で始まるリストを指定し、シングルクォート
     を前置して式ではなく定数として扱わせる。

     Lispの関数について説明するのは本書の範囲外だが、この例を理解するに
     は、テキストモードに入るときに`(auto-fill-mode 1)'が実行されるのだ
     と考えておけば十分。この式を別の式に変えたり、式を複数並べてもかま
     わない。

     Emacsには`turn-on-auto-fill'という関数が用意されており、その定義は
     `(lambda () (auto-fill-mode 1))'になっている。したがって、上の例を
     もっと簡単に書くとつぎのようになる。

          (add-hook 'text-mode-hook 'turn-on-auto-fill)

   * あらかじめ用意してあるLispライブラリ`foo' （実際には標準Emacsディレ
     クトリに置かれたファイル`foo.elc' または`foo.el'）をロードする。

          (load "foo")

     `load'に渡す引数が相対ファイル名、つまり、`/'や`~'で始まらない場合
     には、`load'は`load-path'（*Note Lisp Libraries::）のディレクトリ群
     を順に探索する。

   * 自分のホームディレクトリにあるコンパイル済みのLispファイル`foo.elc'
     をロードする。

          (load "~/foo.elc")

     ここでは絶対ファイル名が使われているので、探索は行わない。

   * キー`C-x l'で関数`make-symbolic-link'が実行されるようにバインディン
     グを設定する。

          (global-set-key "\C-xl" 'make-symbolic-link)

     または

          (define-key global-map "\C-xl" 'make-symbolic-link)

     ここでもシンボル`make-symbolic-link'を変数としての値ではなく定数と
     するためにシングルクォートが使われていることに注意。

   * 上と同じだが、Lispモードの中だけでのバインディングを設定する。

          (define-key lisp-mode-map "\C-xl" 'make-symbolic-link)

   * 基本（fundamental）モードで`next-line'を実行するようになっているす
     べてのキーを、かわりに`forward-line'を実行するように直す。

          (substitute-key-definition 'next-line 'forward-line
                                     global-map)

   * `C-x C-v'を未定義にする。

          (global-unset-key "\C-x\C-v")

     キーを未定義にする必要のある場合の1つとして、そのキーをプレフィック
     スにしたい場合がある。たとえば、`C-x C-v ANYTHING'を定義すると、
     `C-x C-v'は自動的プレフィックスになるが、しかしそのまえに`C-x C-v'
     の通常の（プレフィックスではない）定義を未定義に戻しておく必要があ
     る。

   * `$'をテキスト（text）モードでの区切り文字にする。`$'を文字定数とし
     て指定していることに注意。

          (modify-syntax-entry ?\$ "." text-mode-syntax-table)

   * コマンド`narrow-to-region'を確認なしに使えるようにする。

          (put 'narrow-to-region 'disabled nil)


