Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999
Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU General
Public License" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU General Public License" may be included in a translation
approved by the Free Software Foundation instead of in the original
English.





File: emacs-ja.info, Node: Log Buffer, Prev: Without Locking, Up: Basic VC Editing

記録項目用バッファの機能
........................

変更をチェックインすると、`C-x C-q'は記録項目をまず読みます。記録項目を
入力するように、`*VC-Log*'というバッファを立ち上げます。入力し終えたら、
`*VC-Log*'で`C-c C-c'と打ちます。実際にチェックインを行うと、このように
行われます。

チェックインをアボートするには、そのバッファでは`C-c C-c'を打た*ない*で
ください。別のバッファに切り替えて、別の編集をします。別のファイルをチェッ
クインしようとしない限り、入力していた記録項目は`*VC-Log*'バッファに残っ
ていますから、チェックインを完了するため、いつでもそのバッファに戻れます。

複数のソースファイルを同じ理由で変更したときには、多くのファイルに同じ記
録項目を指定できると便利です。こうするには、まえの記録項目の履歴を使いま
す。コマンド、`M-n'、`M-p'、`M-s'、`M-r'は、ミニバッファの履歴コマンドの
ように働きます（ただし、これらのコマンドはミニバッファの外部で使う）。

ファイルにチェックインするたびに、記録項目用バッファはVC記録（vc-log）モー
ドになります。このモードは2つのフック、`text-mode-hook'と
`vc-log-mode-hook'を起動します。*Note Hooks::。



File: emacs-ja.info, Node: Old Versions, Next: Secondary VC Commands, Prev: Basic VC Editing, Up: Version Control

旧版の調査と比較
----------------

版管理の便利な機能の1つは、ファイルの任意の版を調べたり、2つの版を比較で
きることです。

`C-x v ~ VERSION RET'
     訪問しているファイルの版VERSIONをそれ専用のバッファで調べる。

`C-x v ='
     カレントバッファの内容とファイルのチェックインした最新版とを比較す
     る。

`C-u C-x v = FILE RET OLDVERS RET NEWVERS RET'
     FILEの指定した2つの版を比較する。

`C-x v g'
     表示色を変えてCVSの注記コマンドの結果を表示する。

1つの旧版を調べるには、ファイルを訪問して`C-x v ~ VERSION RET' 
（`vc-version-other-window'）と打ちます。これにより、ファイルの版VERSION
のテキストを`FILENAME.~VERSION~'という名前のファイルに収め、別のウィンド
ウのそれ専用のバッファでそのファイルを訪問します。（RCSでは、旧版を選択
して、それから枝分かれを作成できる。*Note Branches::。）

しかし通常は、コマンド`C-x v ='（`vc-diff'）でファイルの2つの版を比較し
たほうが、もっと便利です。引数を指定しない`C-x v ='では、カレントファイ
ルの内容（必要があればファイルに保存する）とファイルのチェックインしてあ
る最新版とを比較します。数引数を指定した`C-u C-x v ='では、ファイル名と2
つの版番号を読み取ってから、指定したファイルの2つの版を比較します。

登録したファイルのかわりにディレクトリ名を指定すると、このコマンドは、そ
のディレクトリとその下にあるサブディレクトリに置かれているすべての登録さ
れたファイルの指定した2つの版を比較します。

チェックインしてある版は、その番号で指定します。入力が空だと、（チェック
インしてある版とは異なるかもしれない）作業ファイルの現在の内容を指定しま
す。版番号のかわりに、スナップショット名（*Note Snapshots::）を指定する
こともできます。

このコマンドは、変数`diff-switches'で指定されるオプションを用いて、
`diff'プログラムを実行して動作します。その出力は別のウィンドウの特別なバッ
ファに表示されます。`M-x diff'コマンドと違って、`C-x v ='では新版と旧版
の相違箇所には移動できません。というのは、通常、一方の版、あるいは、両方
の版は、比較するときにはファイルとしては存在していないからです。それらは、
マスタファイルの記録の中に存在するだけです。`M-x diff'についてより詳しく
は、*Note Comparing Files::。

CVSで管理しているファイルに関しては、一目でわかるように複数の表示色を使っ
て、CVS注記コマンドの結果を表示できます。これには、`M-x vc-annotate'を使
います。赤は新版、青は旧版、それらの中間色は中間の版を表します。数引数N
は、時間尺度を伸ばします。つまり、ある表示色で表す期間をN倍します。



File: emacs-ja.info, Node: Secondary VC Commands, Next: Branches, Prev: Old Versions, Up: Version Control

VCの副次的なコマンド
--------------------

本節では、VCの副次的なコマンドを説明します。1日に一度くらい使うようなコ
マンドです。

* Menu:

* Registering::         Putting a file under version control.
* VC Status::           Viewing the VC status of files.
* VC Undo::             Cancelling changes before or after check-in.
* VC Dired Mode::       Listing files managed by version control. 
* VC Dired Commands::   Commands to use in a VC Dired buffer.



File: emacs-ja.info, Node: Registering, Next: VC Status, Up: Secondary VC Commands

VCへのファイル登録
..................

ファイルを訪問してから`C-x v i'（`vc-register'）と打つだけで、
ファイルを版管理の管理下に置けます。

`C-x v i'
     訪問したファイルを版管理に登録する。

ファイルを登録するには、Emacsはそのファイルに対してどの版管理システムを
使うか選ぶ必要があります。`vc-default-back-end'に、`RCS'、`CVS'、`SCCS'
のいずれかを設定すれば、明示的に指定できます。あるいは、`RCS'、`SCCS'、
`CVS'という名前のサブディレクトリがあるなら、Emacsは対応する版管理システ
ムを使います。指定がまったくなければ、デフォルトでは、RCSがインストール
されていればRCS、さもなければSCCSを選びます。

ロックを使用している場合には、`C-x v i'は、ファイルのロックを解除し読み
出し専用にします。ファイルの編集を始めたい場合には、`C-x C-q'と打ちます。
CVSにファイルを登録したあとでは、`C-x C-q'と打って最初の版を記録する必要
があります。

新しく登録されたファイルの最初の版番号は、デフォルトでは1.1です。異なる
デフォルトを指定するには、変数`vc-default-init-version'に設定します。あ
るいは、`C-x v i'に数引数を指定すると、そのファイルだけに使う最初の版番
号をミニバッファで読みます。

`vc-initial-comment'が`nil'以外ならば、`C-x v i'はこのソースファイルの目
的を記した初期コメントを読みます。これは記録項目（*Note Log Buffer::）を
読むのと同じように動作します。



File: emacs-ja.info, Node: VC Status, Next: VC Undo, Prev: Registering, Up: Secondary VC Commands

VC状態表示コマンド
..................

`C-x v l'
     版管理の状態と変更履歴を表示する。

ファイルの詳しい版管理状態や履歴を見るには、`C-x v l'（`vc-print-log'）
と打ちます。記録項目を含めてカレントファイルの変更履歴を表示します。出力
は別のウィンドウに表示されます。



File: emacs-ja.info, Node: VC Undo, Next: VC Dired Mode, Prev: VC Status, Up: Secondary VC Commands

版管理操作のアンドゥ
....................

`C-x v u'
     バッファとファイルを最新のチェックインしてある版に復元する。

`C-x v c'
     訪問先ファイルのマスタファイルに最後に入れた変更を取り除く。つまり、
     最後のチェックインをアンドゥする。

これまでの一連の変更を破棄してチェックインしてある最新版へ復元したいとき
は、`C-x v u'（`vc-revert-buffer'）を使います。ロックを使用しているとき
には、ファイルのロックを解除するので、変更を始めるまえにまずファイルをロッ
クし直す必要があります。チェックインした最新版から変更していないと判断で
きない限り、`C-x v u'は確認を求めてきます。

`C-x v u'は、ファイルをロックしたけれどもやはりファイルを変更しないと決
めたときに、ロックを解除するコマンドでもあります。

すでにチェックインしてしまった変更を取り消すには、`C-x v c'
（`vc-cancel-version'）を使います。このコマンドは、チェックインした最新
版のすべての記録を捨てさります。さらに、`C-x v c'は、作業ファイルとバッ
ファを以前の版（捨てた最新版の1つまえの版）に復元するかどうか聞いてきま
す。

`no'と答えると、VCはバッファでの変更を保持してファイルもロックしたままに
します。チェックインした変更に明らかなまちがいがあるとわかったときに、こ
の「復元しない」という選択肢は便利です。誤りを含んだチェックインを取り消
し、誤りを訂正してから、改めてファイルをチェックインできます。

`C-x v c'がバッファを復元しないときには、そのかわりに、バッファ内のすべ
ての版管理ヘッダの展開形をもとの形に戻します（*Note Version Headers::）。
なぜなら、バッファはもはや既存のどの版にも対応しないからです。ふたたび
チェックインすると、チェックインの過程で、新たな版番号として正しくヘッダ
を展開します。

しかしながら、RCSの`$Log$'ヘッダを
自動的にもとの形に戻すことは不可能です。
このヘッダの機能を使うなら、取り消した版に対応する項目を削除することで、
もとの形に手で戻す必要があります。

多くの作業結果を簡単に失ってしまうので、`C-x v c'を起動するときには十分
注意してください。



File: emacs-ja.info, Node: VC Dired Mode, Next: VC Dired Commands, Prev: VC Undo, Up: Secondary VC Commands

VC下のdired
...........

大きなプログラムを扱っているときは、ディレクトリの木構造全体の中でどのファ
イルが変更されたのかを調べたり、版管理の下に置かれているすべてのファイル
の状態を一度に見られると便利です。コマンド`C-x v d'（`vc-directory'）を
使えば、版管理に関連したファイルだけを含んだディレクトリ一覧を作れます。

`C-x v d'は、VC diredモードを使うバッファを作ります。これは、普通のdired
バッファ（*Note Dired::）にそっくりですが、（ロックされていたり、未更新
の）注意を払うべきファイルだけを通常は表示します。これを"簡素な表示"と呼
びます。変数`vc-dired-terse-display'に`nil'を設定すると、VC diredは、関
連するすべてのファイル、つまり、版管理の下に置かれたファイルとすべてのサ
ブディレクトリを表示します（"完全な表示"）。VC diredバッファのコマンド`v
t'は、簡素な表示と完全な表示を切り替えます。（*Note VC Dired Commands::。）

デフォルトでは、VC diredは、指定したディレクトリやそれより下に置かれた注
意を払うべきファイルや関連するファイルの再帰的な一覧を作ります。この動作
を変えるには、変数`vc-dired-recurse'に`nil'を設定します。すると、VC
diredは、指定したディレクトリにあるファイルだけを表示します。

各ファイルを表す行には、ハードリンク数、所有者、グループ、ファイルサイズ
のかわりに版管理状態があります。ファイルが変更されていなければ、つまり、
マスタファイルの内容に同期しているならば、版管理状態は空です。そうでなけ
れば、括弧で括ったテキストになります。RCSとSCCSでは、ファイルをロックし
ているユーザーの名前が示されます。CVSでは、cvs状態（`cvs status'）を簡略
化したものが示されます。つぎは、RCSを使っている場合の例です。

       /home/jim/project:

       -rw-r--r-- (jim)      Apr  2 23:39 file1
       -r--r--r--            Apr  5 20:21 file2

ファイル、`file1'と`file2'が、版管理の下に置かれていて、`file1'はユーザー
jimがロックしていて、`file2'はロックされていません。

つぎは、CVSを使っている場合の例です。

       /home/joe/develop:

       -rw-r--r-- (modified) Aug  2  1997 file1.c
       -rw-r--r--            Apr  4 20:09 file2.c
       -rw-r--r-- (merge)    Sep 13  1996 file3.c

保管庫のものに比べて、`file1.c'は変更されていますが、`file2.c'は変更され
ていません。`file3.c'も変更されていますが、保管庫には他の変更がチェック
インされています。`file3.c'をチェックインするまえに、それらの変更を併合
する必要があります。

VC diredで（『完全な表示』のときに）サブディレクトリを表示するときには、
版管理の下には絶対に置かれないものは省略します。デフォルトでは、`RCS'や
`CVS'などのVCのサブディレクトリが含まれます。これは、変数
`vc-directory-exclusion-list'を設定してカスタマイズできます。

普通のdiredのように、`C-u C-x v d'と打てば、`ls'プログラムに渡す追加オプ
ションを指定して、VC diredの出力書式を微調整できます。



File: emacs-ja.info, Node: VC Dired Commands, Prev: VC Dired Mode, Up: Secondary VC Commands

VC diredコマンド
................

VC diredモードでも、通常のdiredコマンドはすべて普通に動作しますが、`v'は
例外で、版管理プレフィックスとして再定義してあります。`vc-diff'や
`vc-print-log'のようなVCコマンドは、`v ='や`v l'いうように打てば起動でき
ます。これらのコマンドの多くは、現在行のファイルに作用します。

コマンド`v v'（`vc-next-action'）は、印を付けたすべてのファイルに作用す
るので、複数のファイルを一度にロックしたりチェックインしたりできます。複
数のファイルに作用する場合、各ファイルの現状に応じて個別に扱います。つま
り、あるファイルはロックしたり、別のファイルはチェックインしたりします。
これは混乱の原因かもしれません。同じ状態の一連のファイルに印を付けて、混
乱を防止するのはユーザーの責任です。

ファイルをチェックインするときには、`v v'は1つの記録項目を読んで、それを
チェックインするすべてのファイルに使います。これは、同じ変更に属する一連
のファイルを一度にチェックインする場合に便利です。

`v t'（`vc-dired-toggle-terse-mode'）と打てばいつでも、（ロックされてい
たり、内容が未更新のものだけを表示する）簡素な表示と完全な表示とを切り替
えられます。特別なコマンド`* l'（`vc-dired-mark-locked'）もあります。こ
れは現在ロックされている（CVSの場合には、内容が未更新である）すべてのファ
イルに印を付けます。つまり、現在ロックされいるもの以外のすべてのファイル
をバッファから削除する別の方法は、`* l t k'と打つことです。



File: emacs-ja.info, Node: Branches, Next: Snapshots, Prev: Secondary VC Commands, Up: Version Control

ファイルの複数の枝分かれ
------------------------

版管理の用途の1つは、ファイルの複数の『現在』版を維持することです。たと
えば、さまざまな完了していない新しい機能を徐々に付け加えているプログラム
の異なる版を持つかもしれません。そういった開発の独立した流れを"枝"
（branch）と呼びます。VCでは、枝を作ったり、別の枝へ切り替えたり、2つの
枝を併合したりできます。しかし、今のところ、RCSだけで枝を使えることに注
意してください。

ファイルの開発の主要な流れを"幹"（trunk）と呼びます。幹にある版は、普通、
1.1、1.2、1.3、…と番号が付けられます。そのような版のどれからでも、独立
した枝を始めることができます。版1.2から始まる枝の版番号は1.2.1.1となり、
同じ枝の後続の版番号は1.2.1.2、1.2.1.3、1.2.1.4、…となります。版1.2から
始まる別の枝があれば、それらの版番号は、1.2.2.1、1.2.2.2、1.2.2.3、…と
なります。

版番号の最後の要素を省略したものを"枝番号"と呼びます。これは、その枝にあ
る版の中でもっとも大きい番号の版、"先頭版"を指します。まえの例の枝は、枝
番号1.2.1と1.2.2です。

* Menu:

* Switching Branches::    How to get to another existing branch.
* Creating Branches::     How to start a new branch.
* Merging::               Transferring changes between branches.
* Multi-User Branching::  Multiple users working at multiple branches 
                            in parallel.



File: emacs-ja.info, Node: Switching Branches, Next: Creating Branches, Up: Branches

枝の切り替え
............

枝を切り替えるには、`C-u C-x C-q'と打ってから、選択したい版番号を指定し
ます。その版を*ロックしない*（書き込み不可）で訪問するので、ロックするま
えに調べることができます。このような枝の切り替えが可能なのは、ファイルが
ロックされていない場合に限ります。

枝の中での版番号を省略して枝番号だけを指定できます。すると、その枝の先頭
版を選ぶことになります。RETだけを打つと、Emacsは幹の上のもっとも大きい版
を選びます。

（幹を含む）どれかの枝へ切り替えたあとでは、明示的に他の枝を選択するまで、
それ以降のVCコマンドはその枝を使います。



File: emacs-ja.info, Node: Creating Branches, Next: Merging, Prev: Switching Branches, Up: Branches

新しい枝の作成
..............

先頭版（枝の中にある最新版）から新たな枝を作るには、必要ならまずその版を
選択してから、`C-x C-q'でそれをロックし、必要な変更を施します。そして、
変更をチェックインするときに、`C-u C-x C-q'を使います。このコマンドでは、
新版に対する版番号を指定できます。現在の版から始まる枝として適切な番号を
指定する必要があります。たとえば、現在の版が2.5ならば、その時点で存在す
る枝の数に依存しますが、枝番号は、2.5.1、2.5.2、…です。

旧版（先頭版ではないもの）から新しい枝を作るには、その版をまず選択してか
ら（*Note Switching Branches::）、それを`C-x C-q'でロックします。旧版を
ロックすると、本当に新しい枝を作るのかどうか確認してきます。noで答えると、
かわりに、最新版をロックするかどうか聞いてきます。

変更してから、ふたたび`C-x C-q'と打って新版にチェックインします。こうす
ると選択した版から始まる新しい枝を自動的に作ります。新しい枝を特に指定す
る必要はありません。なぜなら、枝の先頭版でないところに新版を付け加える唯
一の方法だからです。

枝を作ったあとでは、その枝に『留まり』ます。つまり、それ以降にチェックイ
ンすると、その枝に新版が作られます。枝を去るには、`C-u C-x C-q'で明示的
に別の版を選ぶ必要があります。ある枝から別の枝へ変更を移すには、次節で説
明する併合コマンドを使ってください。



File: emacs-ja.info, Node: Merging, Next: Multi-User Branching, Prev: Creating Branches, Up: Branches

枝の併合
........

ある枝で変更を完了したときには、それらの変更をファイルの開発の主流（幹）
に取り込みたいことがしばしばあるでしょう。これは簡単な操作ではありません。
というのは、幹でも開発は進行しているので、別の向きに変更されているファイ
ルに変更を"併合"する必要があるからです。VCでは、`vc-merge'コマンドで併合
（とそれ以外のことも）できます。

`C-x v m (vc-merge)'
     作業ファイルに変更を併合する。

`C-x v m'（`vc-merge'）は、一連の変更を作業ファイルの現在の版に併合しま
す。このコマンドはまず、ミニバッファで枝番号か2つの版番号を読み取ります。
そして、その枝での変更、あるいは、指定した2つの版のあいだの変更を調べ、
それらをファイルの現在の版に併合します。

例として、枝1.3.1である機能を実装し終えたとしましょう。この間、幹でも開
発が進んでいて版1.5になっています。枝での変更を幹に併合するには、まず、
`C-u C-x C-q RET'と打って、幹の先頭版へ行きます。版1.5が現在の版になりま
す。ファイルのロックを使っている場合には、`C-x C-q'と打って、版1.5をロッ
クして変更できるようにします。続いて`C-x v m 1.3.1 RET'と打ちます。する
と、枝1.3.1での（枝の開始点である版1.3から枝の中にある最新版までの）一連
の変更を取り出して、それらを作業ファイルの現在の版に併合します。ここで、
変更された作業ファイルをチェックインできます。つまり、枝での変更を取り込
んだ版1.6を作れるのです。

チェックインするまえに、枝から併合したあとにさらに編集することも可能です。
しかし、併合した版をチェックインしたあとで、ロックしてさらに編集するのが、
普通は賢いやり方です。こうすれば、変更履歴をよりよく記録に残せます。

すでに修正されているファイルに変更を併合するときには、変更が重複する場合
があります。この状況を"矛盾"と呼びます。矛盾した変更の辻褄を合わせること
を"矛盾の解消"と呼びます。

併合中に矛盾が起こると、VCはこれらを検出し、それらをエコー領域に表示して
ユーザーに伝え、併合を補佐してほしいかどうか聞いてきます。yesで答えると、
ediffセッションを開始します（*Note Ediff: (ediff)Top.）。

noで答えると、矛盾する変更はどちらも"矛盾印"で囲ってファイルに挿入します。
矛盾する部分は、下の例のようになります。作業ファイルの名前は`name'であり、
ユーザーBの変更を収めたマスタファイルの版は1.11です。

     <<<<<<< name
       USER A'S VERSION
     =======
       USER B'S VERSION
     >>>>>>> 1.11

この矛盾を解消するようにファイルを手で編集できます。あるいは、ファイルを
訪問してから`M-x vc-resolve-conflicts'と打ちます。すると上に述べたediff
セッションを開始します。



File: emacs-ja.info, Node: Multi-User Branching, Prev: Merging, Up: Branches

複数ユーザーの枝
................

ファイルの異なる枝上で同時に複数の開発者が作業すると有益なことがしばしば
あります。CVSでは、デフォルトで、これができます。RCSでは、複数のソースディ
レクトリを作れば可能です。RCSのマスタファイルを置いた共通のディレクトリ
を指す`RCS'という名前のリンクを各ソースディレクトリに置きます。こうすれ
ば、各ソースディレクトリでは、それぞれ独自に版を選択できます。しかし、同
じ共通のRCSレコードをすべてで共有します。

ソースファイルにRCSの版管理ヘッダ（*Note Version Headers::）が入っていれ
ば、この技法は信頼性があり自動的に動作します。ヘッダにより、Emacsはいつ
でも作業ファイルに入っている版番号がわかります。

ファイルに版管理ヘッダが入っていないときには、各セッションごとにどの枝で
作業しているかをEmacsに明示する必要があります。こうするには、ファイルを
訪問してから、`C-u C-x C-q'と打ち、正しい枝番号を指定します。これにより、
編集セッションではどの枝を操作しているかをEmacsが知っていることを保証し
ます。



File: emacs-ja.info, Node: Snapshots, Next: Miscellaneous VC, Prev: Branches, Up: Version Control

スナップショット
----------------

"スナップショット"とは、ファイルの版（登録されたファイルそれぞれに1つず
つ）の集合に名前を付けたもので、一塊として扱うことができます。スナップ
ショットの重要な種類の1つは、"リリース"です。これは、ユーザーへ配布する
準備が整ったシステムの（理論的には）安定した版のことです。

* Menu:

* Making Snapshots::		The snapshot facilities.
* Snapshot Caveats::		Things to be careful of when using snapshots.



File: emacs-ja.info, Node: Making Snapshots, Next: Snapshot Caveats, Up: Snapshots

スナップショットの作成と使用
............................

スナップショットに対しては、基本的なコマンドが2つあります。1つは名前を指
定してスナップショットを作り、もう1つは指名したスナップショットを取り出
すことです。

`C-x v s NAME RET'
     カレントディレクトリやその下に置いてある登録されたファイルのそれぞ
     れの保存された最新版をNAMEという名前のスナップショットとして定義す
     る（`vc-create-snapshot'）。

`C-x v r NAME RET'
     カレントディレクトリやその下に置いてある登録されたファイルすべてに
     ついて、スナップショットNAMEに対応する版を選択する。

     カレントディレクトリやその下に置いてある登録されたファイルのいずれ
     かがロックされていると、このコマンドは何も変更せずにエラーを報告す
     る。これは、進行中の作業結果を上書きしてしまうことを避けるため。

スナップショットはとても少量の資源しか使いません。ファイル名一覧とスナッ
プショットに属する版番号を記録するに十分な量だけでいいのです。したがって、
使いものになるものをスナップショットにすることを躇うことはありません。

`C-x v ='や`C-x v ~'（*Note Old Versions::）の引数として、スナップショッ
トの名前を指定できます。したがって、スナップショットと現在のファイル、あ
るいは、2つのスナップショット同士、あるいは、指定した名前の版とスナップ
ショット同士を比較できます。



File: emacs-ja.info, Node: Snapshot Caveats, Prev: Making Snapshots, Up: Snapshots

スナップショットの弱点
......................

VCのスナップショット機能は、RCSの名前付きコンフィギュレーションサポート
（named-configuration support）をモデルにしています。RCS固有の機能を使っ
ているため、RCSを使って作ったVCのスナップショットは、VCを使わなくても見
えます。

SCCSでは、VC自身でスナップショット機能を実装しています。VCが使うファイル
には、名前／ファイル／版番号の3つ組みが含まれます。これらのスナップショッ
トは、VCを使ったときだけ見えます。

スナップショットはチェックインした版の集合です。ですから、スナップショッ
トを作るときには、すべてのファイルをチェックインしてあり、しかもロックし
ていないことを確認してください。

ファイルを改名したり削除すると、スナップショットに問題を生じます。これは
VCに固有の問題ではなく、版管理システムに一般的な設計上の問題で、まだ誰も
満足ゆく解決をできていません。

登録されたファイルを改名するなら、そのマスタファイルも一緒に改名する必要
があります（コマンド`vc-rename-file'は自動的にこれを行う）。SCCSを使って
いるならば、ファイル名を新しい名前にしてスナップショットの記録も更新する
必要があります（`vc-rename-file'はこれも行う）。記録された名前ではもはや
存在しないマスタファイルを参照する古いスナップショットは無効です。VCは
（古い名前では）取り出せません。スナップショットを手で更新する方法を説明
するためにRCSやSCCSを詳しく説明することは、本書の範囲を越えています。

`vc-rename-file'を使えば、取り出し操作に使える程度にはスナップショットを
保てますが、すべての問題を解決できるわけではありません。たとえば、プログ
ラムのいくつかのファイルでは、名前で他のファイルを参照しているでしょう。
少なくとも、makefileでは、改名したファイルを指しているでしょう。古いスナッ
プショットを取り出すと、改名したファイルは新しい名前で取り出しますが、
makefileで使っている名前ではありません。ですから、取り出しただけではプロ
グラムは動かないでしょう。



File: emacs-ja.info, Node: Miscellaneous VC, Next: Customizing VC, Prev: Snapshots, Up: Version Control

VCのその他のコマンドと機能
--------------------------

本節では、使用頻度の少ないVCの機能を説明します。

* Menu:

* Change Logs and VC::  Generating a change log file from log entries.
* Renaming and VC::     A command to rename both the source and master 
                          file correctly.
* Version Headers::     Inserting version control headers into working files.



File: emacs-ja.info, Node: Change Logs and VC, Next: Renaming and VC, Up: Miscellaneous VC

変更記録とVC
............

プログラムに対してRCSやCVSを使い、しかも、それらに変更記録ファイル
（*Note Change Log::）を保持しているならば、版管理の記録項目から変更記録
項目を自動的に生成できます。

`C-x v a'
     カレントディレクトリにある変更記録ファイルを訪れる。そして、そのディ
     レクトリに置いてある登録された各ファイルについて、変更記録ファイル
     にある最新の項目以降にチェックインされた版に関する新たな項目を作成
     する。（`vc-update-change-log'）。

     このコマンドはRCSやCVSだけで動作し、SCCSでは動作しない。

`C-u C-x v a'
     上と同様であるが、カレントバッファのファイルに関する項目だけを探す。

`M-1 C-x v a'
     上と同様だが、現在訪問しているファイルのうち版管理の下に置かれてい
     るファイルすべてに関する項目を探す。このコマンドはRCSでのみ動作する。
     しかも、デフォルトディレクトリに関するすべての項目を変更記録に追加
     するが、これは適切でないこともある。

たとえば、`ChangeLog'の最初の行の日付が1999年4月10日であり、それ以降の
チェックインはNathaniel Bowditchが1999年5月22日に`Ignore log messages
that start with `#'.'という記録で`rcs2log'にチェックインしたものだけだと
しましょう。そうすると、`C-x v a'は`ChangeLog'を訪問して、つぎのようなテ
キストを挿入します。

     1999-05-22  Nathaniel Bowditch  <nat@apn.org>

             * rcs2log: Ignore log messages that start with `#'.

このあと、変更記録の新しい項目を好きなように編集できます。

残念ながら、ChangeLogファイルには日付しか記録していないので、新たな変更
記録項目がChangeLogファイルの既存の項目と重複することがあります。そのよ
うな日付の重複は、手作業で削除する必要があります。

通常、ファイル`foo'に関する記録項目は、
`* foo: TEXT OF LOG ENTRY'のように表示されます。
記録項目のテキストが`(FUNCTIONNAME):'で始まると、
`foo'のうしろの`:'は省かれます。
たとえば、`vc.el'に関する記録項目が
`(vc-do-command): Check call-process status.'であれば、
`ChangeLog'の中のテキストはつぎのようになります。

     1999-05-06  Nathaniel Bowditch  <nat@apn.org>

             * vc.el (vc-do-command): Check call-process status.

`C-x v a'が複数の変更記録項目を一度に追加するときには、同じ作者がほぼ同
じ日時にチェックインしたものならば、関連する記録項目をまとめます。そのよ
うないくつかのファイルに対する記録項目がすべて同じテキストならば、1つの
項目にまとめます。たとえば、最後にチェックインしたものに、以下の記録があっ
たとします。

* `vc.texinfo'の記録項目: `Fix expansion typos.'
* `vc.el'の記録項目: `Don't call expand-file-name.'
* `vc-hooks.el'の記録項目: `Don't call expand-file-name.'

これらは`ChangeLog'の中ではつぎのようになります。

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.

             * vc.el, vc-hooks.el: Don't call expand-file-name.

通常、`C-x v a'は記録項目を空行で区切りますが、
関連する記録項目のテキストを`{CLUMPNAME} 'のような
ラベルで始めれば、関連する複数の記録項目を1つの塊にする
（区切りの空行を入れない）ように印を付けられます。
ラベル自体は`ChangeLog'にはコピーされません。
たとえば、記録項目がつぎのようであるとします。

* `vc.texinfo'の記録項目: `{expand} Fix expansion typos.'
* `vc.el'の記録項目: `{expand} Don't call expand-file-name.'
* `vc-hooks.el'の記録項目: `{expand} Don't call expand-file-name.'

すると、`ChangeLog'のテキストはつぎのようになります。

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.
             * vc.el, vc-hooks.el: Don't call expand-file-name.

記録項目のテキストが`#'で始まると、その記録項目は`ChangeLog'にはコピーさ
れません。たとえば、コメントの綴りまちがいだけを変更したときには、記録項
目を`#'で始めれば、このような自明なものを`ChangeLog'に入れないですみます。



File: emacs-ja.info, Node: Renaming and VC, Next: Version Headers, Prev: Change Logs and VC, Up: Miscellaneous VC

VC作業ファイルとマスタファイルの改名
....................................

登録したファイルを改名するときには、そのマスタファイルも同様に改名して正
しい結果を得られるようにする必要があります。指定どおりにソースファイルを
改名し、それに従ってマスタファイルも改名するには、`vc-rename-file'を使い
ます。このコマンドは、当該ファイルを指名しているどんなスナップショット
（*Note Snapshots::）も更新するので、スナップショットでも新しい名前を使
うようになります。それにも関わらず、修正したスナップショットは動作しない
かもしれません（*Note Snapshot Caveats::）。

誰かがロックしているファイルに対しては、`vc-rename-file'を使えません。



File: emacs-ja.info, Node: Version Headers, Prev: Renaming and VC, Up: Miscellaneous VC

版管理ヘッダの挿入
..................

版を識別する文字列を作業ファイルへ直接入れておくと便利なこともあります。
"版管理ヘッダ"と呼ばれる特別な文字列は、各版ごとにその版番号で置き換えら
れます。

RCSを使っていて、かつ、作業ファイルに版管理ヘッダが入っていれば、Emacsは、
版管理ヘッダを使って現在の版とファイルのロック状態を決定できます。これは、
版管理ヘッダがないときにマスタファイルを参照するより、信頼できます。複数
の枝を使う環境では、VCが正しくふるまうためには版管理ヘッダが必要です
（*Note Multi-User Branching::）。

版管理ヘッダの探索は、変数`vc-consult-headers'で制御されます。`nil'以外
ならば、編集中の版番号を決定するためにEmacsはヘッダを探します。`nil'を設
定すると、この機能はオフになります。

適切なヘッダ文字列を入れるには、コマンド`C-x v h' （`vc-insert-headers'）
を使います。

`C-x v h'
     版管理システムで使うヘッダをファイルに挿入する。

デフォルトのヘッダ文字列は、
RCSでは`$Id$'、SCCSでは`%W%'です。
変数`vc-header-alist'に設定すれば、他のヘッダを指定できます。
この値は、`(PROGRAM . STRING)'の形式の
要素から成るリストです。
ここで、PROGRAMは`RCS'または`SCCS'であり、
STRINGは使用する文字列です。

1つの文字列のかわりに、文字列のリストを指定することもできます。そうする
と、リストの各文字列は、別々の行に別のヘッダとして挿入されます。

この変数に入れる文字列を書くときには、『余分な』バックスラッシュを使う必
要がよくあります。この文字列を含むEmacs Lispファイルが版管理の下に置かれ
ているときに、定数中の文字列がヘッダと解釈されることを防ぐためです。

各ヘッダは、ポイント位置の新しい行に、コメント区切りの内側にタブで囲んで
挿入されます。通常、現在のモードのコメント開始文字列とコメント終了文字列
を使いますが、特定のモードでは、この目的のための特別なコメント区切りがあ
ります。変数`vc-comment-alist'がそれらを指定します。このリストの各要素は
`(MODE STARTER ENDER)'という形式です。

変数`vc-static-header-alist'は、バッファ名に基づいた追加の文字列を指定し
ます。この値は、`(REGEXP . FORMAT)'の形式の要素から成るリストでなくては
いけません。REGEXPがバッファ名に一致するたびに、FORMATをヘッダの一部とし
て挿入します。バッファ名に一致する各要素と`vc-header-alist'に指定された
各文字列ごとにヘッダ行を挿入します。`vc-header-alist'の文字列を要素の書
式FORMATで処理してヘッダ行を作ります。`vc-static-header-alist'のデフォル
ト値はつぎのとおりです。

     (("\\.c$" .
       "\n#ifndef lint\nstatic char vcid[] = \"\%s\";\n\
     #endif /* lint */\n"))

これは、つぎのようなテキストを挿入します。


     #ifndef lint
     static char vcid[] = "STRING";
     #endif /* lint */

上のテキストは空行で始まっていることに注意してください。

複数の版管理ヘッダをファイルに入れる場合には、ファイル内ではそれらを一緒
にまとめて入れておきます。`revert-buffer'のマーカを保存する機構は、2つの
版管理ヘッダのあいだに置かれたマーカを扱えないこともあります。



File: emacs-ja.info, Node: Customizing VC, Prev: Miscellaneous VC, Up: Version Control

VCのカスタマイズ
----------------

VCをカスタマイズする方法はたくさんあります。設定可能なオプションは、次節
に述べる4つに分類できます。

* Menu:

* Backend Options::       Customizing the back-end to your needs.
* VC Workfile Handling::  Various options concerning working files.
* VC Status Retrieval::   How VC finds the version control status of a file,
                            and how to customize this.
* VC Command Execution::  Which commands VC should run, and how.



File: emacs-ja.info, Node: Backend Options, Next: VC Workfile Handling, Up: Customizing VC

VCのバックエンドに対するオプション
..................................

RCSとCVSには、ファイルのロックを使うかどうかを指定できます（ロックに関し
ては*Note VC Concepts::）。VCはどちらを選んだかを識別し、そのようにふる
まいます。

RCSでは、デフォルトはロックを使います。しかし、ファイルをロックしていな
くても変更をチェックインできる、"弱いロック"と呼ばれるモードがあります。
特定のファイルに対して弱いロックを使うように切り替えるには、`rcs -U'を使
います。詳しくは、`rcs'のマニュアルページを参照してください。

CVSでは、デフォルトはロックを使いません。いつでも誰もが作業ファイルを変
更できます。しかし、これを制限する方法があり、ロックに似たふるまいをしま
す。

1つの方法は、環境変数`CVSREAD'に何か値を設定することです。この変数が定義
されていると、CVSはデフォルトでは作業ファイルを読み出し専用にします。
Emacs内では、`C-x C-q'と打ってファイルを書き込み可能にする必要があります。
そうすると、事実上ロックを使っているかのように編集できます。しかしながら、
実際にロックされているわけではないので、複数のユーザーが各自のファイルを
同時に書き込み可能にできてしまいます。`CVSREAD'を初めて設定するときには、
ファイルの保護が正しく設定されるように、あなたのモジュールすべてを新たに
チェックアウトしたことを確認してください。

ロックに似たふるまいを達成する別の方法は、CVSの"監視"機能を使うことです。
ファイルを監視するようにしておくと、CVSはデフォルトでそのファイルを読み
出し専用にします。そのため、Emacs内では`C-x C-q'を使って書き込み可能にす
る必要があります。VCは、`cvs edit'を実行してファイルを書き込み可能にしま
す。すると、CVSは、あなたがファイルを変更しようとしていることを他の開発
者に通知します。監視機能の詳しい使い方については、CVSの解説を参照してく
ださい。

変数`vc-handle-cvs'に`nil'を設定すれば、CVSの管理下に置いたファイルに対
してVCを使わないようにできます。こうすると、Emacsは、これらのファイルを
あたかも登録されていないかのように扱い、それらに対してVCコマンドは使えま
せん。すべてのCVS操作を手動で行う必要があります。



File: emacs-ja.info, Node: VC Workfile Handling, Next: VC Status Retrieval, Prev: Backend Options, Up: Customizing VC

VC作業ファイルの扱い方
......................

Emacsは、版管理の下に置かれたソースファイルに対しては、通常バックアップ
ファイルを作りません。版管理を使っているファイルに対してもバックアップファ
イルを作りたいなら、変数`vc-make-backup-files'に`nil'以外の値を設定しま
す。

ロックの状態に関わらず、普通、作業ファイルはつねに存在します。
`vc-keep-workfiles'に`nil'を設定すると、`C-x C-q'で新版をチェックインす
ると、作業ファイルを削除します。しかし、Emacsでファイルを訪問しようとす
ると、作業ファイルをふたたび作ります。（CVSでは、作業ファイルはつねに存
在する。）

版管理されているファイルをシンボリックリンクを介して編集することは、危険
なことになりえます。版管理システムを迂回してしまいます。つまり、ロックせ
ずにファイルを編集できてしまい、変更のチェックインには失敗します。また、
他のユーザーがあなたの変更を上書きしてしまうかもしれません。こういったこ
とを防ぐために、VCは、訪問する各シンボリックリンクを検査して、それが版管
理の下に置かれたファイルを指しているかどうか調べます。

変数`vc-follow-symlinks'は、シンボリックリンクが版管理されているファイル
を指しているときにどうするかを制御します。その値が`nil'ならば、VCは警告
メッセージを表示するだけです。`t'ならば、VCは自動的にリンクを辿って、か
わりに本当のファイルを訪問し、エコー領域にこのことを表示します。値が
`ask'（デフォルト）ならば、VCはリンクを辿るかどうかを毎回聞いてきます。



File: emacs-ja.info, Node: VC Status Retrieval, Next: VC Command Execution, Prev: VC Workfile Handling, Up: Customizing VC

VC状態検索
..........

ファイルのロック状態を推測するとき、VCはまずファイルのRCSの版管理ヘッダ
文字列を探します（*Note Version Headers::）。ヘッダ文字列がなかったり、
SCCSを使っているときは、VCは通常、作業ファイルのパーミッションを調べます。
ここまでは、すぐにできます。しかし、ファイルのパーミッションを信頼できな
い場合もあります。この場合、やや手間がかかりますが、マスタファイルを調べ
る必要があります。さらに、マスタファイルは、ファイルがロックされているか
どうかは教えてくれますが、作業ファイルがロックされた版を本当に含んでいる
かどうかは教えてくれません。

ロック状態を調べるために版管理ヘッダを使わないようにVCに指示するには、変
数`vc-consult-headers'に`nil'を設定します。すると、VCは（信頼できるなら）
ファイルパーミッションを使うか、マスタファイルを調べます。

変数`vc-mistrust-permissions'を設定することで、ファイルパーミッションを
信頼するかどうかの基準を指定できます。その値は、`t'（つねにファイルパー
ミッションを疑い、マスタファイルを調べる）、`nil'（つねにファイルパーミッ
ションを信頼する）、あるいは、可否を決定する1引数の関数です。その引数は、
サブディレクトリ、`RCS'、`CVS'、`SCCS'のいずれかの名前です。関数の戻り値
が`nil'以外ならば、ファイルパーミッションを疑います。作業ファイルのパー
ミッションがまちがって変更されていると思うなら、 
`vc-mistrust-permissions'に`t'を設定します。すると、VCはつねにファイルの
状態を決定するためにマスタファイルを調べます。



File: emacs-ja.info, Node: VC Command Execution, Prev: VC Status Retrieval, Up: Customizing VC

VCコマンドの実行
................

`vc-suppress-confirm'が`nil'以外ならば、`C-x C-q'と`C-x v i'は確認せずに
カレントバッファを保存し、`C-x v u'も確認せずに作用します。（この変数は
`C-x v c'には影響しない。その操作は思い切ったものなので、つねに確認する
べき。）

VCモードは、RCS、CVS、SCCSのシェルコマンドを実行することで、その作業の多
くを行います。`vc-command-messages'が`nil'以外ならば、VCはどのシェルコマ
ンドを実行しているか表示し、コマンドが終了したときに追加メッセージを表示
します。

変数`vc-path'を設定すれば、版管理プログラムを探すための追加のディレクト
リを指定できます。これらのディレクトリは、通常の探索パスを探すまえに探さ
れます。しかし、通常は適切なファイルを自動的にみつけられます。



File: emacs-ja.info, Node: Directories, Next: Comparing Files, Prev: Version Control, Up: Files

ファイルディレクトリ
====================

ファイルシステムは、ファイル群を"ディレクトリ"にまとめます。"ディレクト
リ一覧"は、ディレクトリの中にある、すべてのファイルの一覧表です。Emacsに
は、ディレクトリを作成したり削除したりするコマンド、短形式（ファイル名の
み）や長形式（サイズ、日付、作者を含む）のディレクトリ一覧を作成するコマ
ンドがあります。diredと呼ばれるディレクトリブラウザもあります。*Note
Dired::。

`C-x C-d DIR-OR-PATTERN RET'
     短形式でディレクトリ一覧を表示する（`list-directory'）。
`C-u C-x C-d DIR-OR-PATTERN RET'
     長形式でディレクトリ一覧を表示する。
`M-x make-directory RET DIRNAME RET'
     DIRNAMEという名前の新しいディレクトリを作る。
`M-x delete-directory RET DIRNAME RET'
     DIRNAMEという名前のディレクトリを削除する。ディレクトリは空である必
     要があり、さもないとエラー。

ディレクトリ一覧を表示するコマンドは`C-x C-d'（`list-directory'）です。
表示するディレクトリや一覧に含めるファイルを指定するワイルドカードを含む
パターンをミニバッファから読み取ります。たとえば、

     C-x C-d /u2/emacs/etc RET

とすると、ディレクトリ`/u2/emacs/etc'の中のすべてのファイルを表示します。
ファイル名のパターンを指定した例はつぎのとおりです。

     C-x C-d /u2/emacs/src/*.c RET

通常、`C-x C-d'はファイル名だけを含んだ短形式のディレクトリ一覧を表示し
ます。（値は無関係な）数引数を指定すると、（`ls -l'のように）サイズ、日
付、作者を含む長形式の一覧を作ります。

ディレクトリ一覧のテキストは、下位プロセスで`ls'を実行して取得します。
Emacsの2つの変数で、`ls'へ渡すオプションを制御します。
`list-directory-brief-switches'は、短形式一覧のときに使うオプションを与
える文字列です（デフォルトは`"-CF"'）。`list-directory-verbose-switches'
は、長形式一覧のときに使うオプションを与える文字列です（デフォルトは
`"-l"'）。



File: emacs-ja.info, Node: Comparing Files, Next: Misc File Ops, Prev: Directories, Up: Files

ファイルの比較
==============

コマンド`M-x diff'は、2つのファイルを比較し、`*Diff*'という名前のEmacsバッ
ファにその違いを表示します。このコマンドは、値が文字列である変数
`diff-switches'で指定されたオプションを使って`diff'プログラムを実行しま
す。

バッファ`*Diff*'のメジャーモードはコンパイル（compilation）モードです。
ですから、`C-x `'を使って、2つのソースファイルで変更されている箇所を次々
に訪れることができます。特定の変更箇所にポイントを移動してから、RETや
`C-c C-c'を打つか、そこで`Mouse-2'をクリックすると、そこに対応するソース
の場所へ移動できます。コンパイル（compilation）モードの他の特別なコマン
ドを使うこともできます。SPCとDELでスクロール、`M-p'と`M-n'でカーソル移動
できます。*Note Compilation::。

コマンド`M-x diff-backup'は、指定されたファイルとその最新のバックアップ
とを比較します。バックアップファイルの名前を指定すると、`diff-backup'は
そのもとのファイルとバックアップファイルとを比較します。

コマンド`M-x compare-windows'は、カレントウィンドウの中のテキストと、つ
ぎのウィンドウの中のテキストを比較します。それぞれのウィンドウのポイント
位置から比較を始めます。それぞれの開始位置は、各バッファのマークリングに
積まれます。そして、各ウィンドウでそれぞれのポイントを1文字ずつ進めるこ
とを、両者のウィンドウで一致しないものに出会うまで行います。そして、コマ
ンドは終了します。Emacsのウィンドウについてより詳しくは、*Note Windows::。

数引数を指定すると、`compare-windows'は白文字の違いを無視します。変数
`compare-ignore-case'が`nil'以外ならば、大文字小文字の違いも同様に無視し
ます。

2つの似たファイルの併合に便利な機能に関しては、*Note Emerge::。



File: emacs-ja.info, Node: Misc File Ops, Next: Compressed Files, Prev: Comparing Files, Up: Files

その他のファイル操作
====================

Emacsには、ファイルをさまざまに操作するコマンドがあります。それらすべて
は1つのファイルを操作します。これらのコマンドは、ワイルドカードを含むファ
イル名を受け付けません。

`M-x view-file'では、ファイルを1画面分ずつ順番に眺めることができます。こ
のコマンドは、ミニバッファでファイル名を読み取ります。Emacsバッファにファ
イルを読み込んだあと、`view-file'は先頭を表示します。そうしたら、1ウィン
ドウ分先へスクロールするにはSPC、逆向きにスクロールするにはDELを打ちます。
ファイル内を動き廻るための他のいろいろなコマンドもありますが、変更するた
めのコマンドはありません。コマンド一覧を見るには、このモードで`?'と打ち
ます。コマンド群は、Emacsの普通のカーソル移動コマンドとほとんど同じです。
ファイル閲覧を終了するには、`q'を打ちます。閲覧用のコマンドは、閲覧
（view）モードと呼ばれる特別なメジャーモードで定義されています。

関連したコマンド、`M-x view-buffer'は、Emacsの既存のバッファを閲覧します。
*Note Misc Buffer::。

`M-x insert-file'は、指定したファイルの内容をカレントバッファのポイント
位置に挿入します。ポイントの位置はそのままですが、挿入された部分の直後に
マークを設定します。

`M-x write-region'は、`M-x insert-file'の逆です。指定したファイルにリー
ジョンの内容をコピーします。`M-x append-to-file'は、指定したファイルの末
尾にリージョンのテキストを付け加えます。*Note Accumulating Text::。

`M-x delete-file'は、シェルの`rm'コマンドのように、指定したファイルを削
除します。1つのディレクトリ内のたくさんのファイルを削除するのなら、dired
を使うほうが便利です（*Note Dired::）。

`M-x rename-file'は、ミニバッファで2つのファイル名、OLDとNEWを読み取り、
ファイルOLDをNEWに改名します。NEWという名前のファイルが既存のときには、
確認に`yes'で応答する必要があります。そうしないと、改名しません。これは、
改名により名前NEWの古い意味が失われるからです。OLDとNEWが異なるファイル
システムの上にあるときには、ファイルOLDを（NEWに）コピーしてから削除しま
す。

似たコマンド`M-x add-name-to-file'は、既存ファイルの名前を消さずに別の名
前を追加するために使います。新しい名前は、既存ファイルが置かれている同じ
ファイルシステムに属している必要があります。

`M-x copy-file'は、ファイルOLDを読んで、新しいファイルNEWに同じ内容を書
き出します。NEWという名前のファイルが既存なら、確認を求めてきます。とい
うのは、コピーするとファイルNEWの古い内容を上書きしてしまうからです。

`M-x make-symbolic-link'は、2つのファイル名、TARGETとLINKNAMEを読み取っ
て、TARGETを指すLINKNAMEという名前のシンボリックリンクを作ります。この結
果、将来LINKNAMEをオープンしようとすると、その時点でTARGETという名前のファ
イルを参照します。その時点で名前TARGETが使われていなければ、エラーになり
ます。このコマンドは引数TARGETを展開しないので、リンク先に相対名を書くこ
とができます。

LINKNAMEが使われていると、リンクを作るときに確認を求めます。すべてのシス
テムでシンボリックリンクを使えるわけではないことに注意してください。



File: emacs-ja.info, Node: Compressed Files, Next: Remote Files, Prev: Misc File Ops, Up: Files

圧縮されたファイルの参照
========================

Emacsには、圧縮されたファイルを訪問すると自動的に展開し、それを変更して
保存すると自動的に再度圧縮するライブラリがあります。この機能を利用するに
は、コマンド`M-x auto-compression-mode'を打ちます。

（自動展開を含む）自動圧縮がオンのときには、Emacsはファイル名で圧縮され
たファイルを認識します。ファイル名の語尾が`.gz'のものは、`gzip'で圧縮さ
れたファイルであることを表します。他の語尾の場合には、他の圧縮プログラム
であることを表します。

自動展開と自動圧縮は、Emacsがファイルの内容を使うすべての操作に適用され
ます。ファイルを訪問する、ファイルに保存する、ファイルの内容をバッファに
挿入する、ファイルをロードする、ファイルをバイトコンパイルすることを含み
ます。



File: emacs-ja.info, Node: Remote Files, Next: Quoted File Names, Prev: Compressed Files, Up: Files

リモートファイル
================

特別なファイル名の構文を使って、他のマシン上のファイルを参照できます。

     /HOST:FILENAME
     /USER@HOST:FILENAME

このようにすると、Emacsは、指定したホスト上のファイルを読み書きするため
にFTPプログラムを使います。あなたのユーザー名かUSERを使ってFTPでログイン
します。毎回パスワードを聞かれることもありますが、これはHOSTへのログイン
に使われます。

普通、リモートファイル名にユーザー名を指定しないと、あなたのユーザー名を
使うことを意味します。しかし、変数`ange-ftp-default-user'に文字列を設定
しておけば、その文字列をかわりに使います。（FTPによるファイル参照を実装
するEmacsのパッケージは、`ange-ftp'と呼ばれる。）

変数`file-name-handler-alist'に`nil'を設定すると、FTPファイル名機能を完
全にオフにできます (1) (*Note Remote Files-Footnotes::)。


File: emacs-ja.info  Node: Remote Files-Footnotes, Up: Remote Files

(1) ファイル名をクォートする`/:'の機能もオフになる。



File: emacs-ja.info, Node: Quoted File Names, Prev: Remote Files, Up: Files

クォートしたファイル名
======================

特殊文字や特別な構文の特別な効果を抑えるために、絶対ファイル名を"クォー
ト"できます。そうするには、先頭に`/:'を加えます。

たとえば、リモートにあるように見えるローカルなファイル名をクォートして、
リモートファイル名として扱われるのを防ぎます。したがって、ディレクトリが
`/foo:'という名前であり、その中に`bar'という名前のファイルがあるとき、
Emacsでは、そのファイルを`/:/foo:/bar'で参照できます。

`/:'は、`~'をユーザーのホームディレクトリを表す特殊文字として扱わないよ
うにもします。たとえば、`/:/tmp/~hack'は、ディレクトリ`/tmp'の中にある
`~hack'というファイル名を指します。

同様に、`/:'は`$'を含むファイル名をミニバッファで入力する方法の1つです。
しかし、`$'をクォートするには、`/:'は（ミニ）バッファの先頭に置く必要が
あります。

ワイルドカード文字を`/:'でクォートすることもできます。たとえば、
`/:/tmp/foo*bar'でファイル`/tmp/foo*bar'を訪問します。しかしながら、多く
の場合、単にワイルドカード文字そのものを入力できます。たとえば、`/tmp'に
ある`foo'で始まり`bar'で終る名前のファイルが`foo*bar'であるときには、
`/tmp/foo*bar'と指定すると、単に`/tmp/foo*bar'を訪問します。



File: emacs-ja.info, Node: Buffers, Next: Windows, Prev: Files, Up: Top

複数のバッファの使い方
**********************

Emacs内で編集しているテキストは"バッファ"（buffer）と呼ばれるオブジェク
トの中に存在します。ファイルを訪問するたびに、ファイルのテキストを保持す
るバッファを作ります。diredを起動するたびに、ディレクトリ一覧を保持する
バッファを作ります。`C-x m'でメッセージを送信するときには、メッセージの
テキストを保持するためにバッファ`*mail*'が使われます。コマンドの説明文を
求めると、`*Help*'と呼ばれるバッファに説明文が現れます。

どんなときでも、1つのバッファだけが"選択"されています。このバッファを"カ
レントバッファ"とも呼びます。バッファが1つしかないかのように、コマンドが
『バッファ』に作用するといういい方をよくします。しかし、実際には、コマン
ドが選択されたバッファに作用するということです（多くのコマンドはそうす
る）。

複数のウィンドウがあるとき、各ウィンドウはそこに表示しているバッファを選
んでいますが、いつでもそれらのウィンドウのうち1つだけが選択されていて、
そのウィンドウに表示されているバッファが選択されているバッファです。各ウィ
ンドウのモード行は、そのウィンドウに表示しているバッファの名前を表示しま
す（*Note Windows::）。

各バッファにはどんな長さでもよい名前があり、バッファ名を指定してバッファ
を選択できます。多くのバッファはファイルを訪問することで作成され、それら
の名前はファイル名から導き出します。好きな名前で空のバッファを作ることも
できます。Emacsを新たに始めると、Emacs内でLisp式の評価に使える
`*scratch*'という名前のバッファができます。バッファ名では大文字小文字を
区別します。

各バッファは独立に、どのファイルを訪問しているか、変更されているか、どの
メジャーモードとマイナモードを使っているかを記録しています。（*Note
Major Modes::）。どのEmacs変数も各バッファに"ローカルに"することができま
す。つまり、あるバッファでの変数の値を他のバッファでのその変数の値とは違
う値にできます。*Note Locals::。

* Menu:

* Select Buffer::       Creating a new buffer or reselecting an old one.
* List Buffers::        Getting a list of buffers that exist.
* Misc Buffer::	        Renaming; changing read-onlyness; copying text.
* Kill Buffer::	        Killing buffers you no longer need.
* Several Buffers::     How to go through the list of all buffers
			  and operate variously on several of them.
* Indirect Buffers::    An indirect buffer shares the text of another buffer. 



File: emacs-ja.info, Node: Select Buffer, Next: List Buffers, Up: Buffers

バッファの作成と選択
====================

`C-x b BUFFER RET'
     BUFFERという名前のバッファを選択または作成する（`switch-to-buffer'）。
`C-x 4 b BUFFER RET'
     同様だが、別のウィンドウでBUFFERを選択する
     （`switch-to-buffer-other-window'）。
`C-x 5 b BUFFER RET'
     同様だが、別のフレームでBUFFERバッファを選択する
     （`switch-to-buffer-other-frame'）。

BUFNAMEという名前のバッファを選択するには、`C-x b BUFNAME RET'と打ちます。
これは、引数BUFNAMEでコマンド`switch-to-buffer'を実行します。バッファ名
の略称形を補完することができます（*Note Completion::）。`C-x b'に空の引
数を指定すると、どのウィンドウにも表示されていない最近選択したバッファを
意味します。

ほとんどのバッファは、ファイルを訪問することで作られるか、テキストを表示
するようなEmacsコマンドによって作られますが、`C-x b BUFNAME RET'と打って、
明示的にバッファを作ることもできます。こうすると、ファイルを訪問していな
い新しい空のバッファを作り、編集できるようにそのバッファを選択します。こ
のようなバッファは、自分用のメモを作るのに使います。これらのバッファを保
存しようとすると、使用するファイル名を聞かれます。新しいバッファのメジャー
モードは、`default-major-mode'の値で決まります（*Note Major Modes::）。

`C-x C-f'やファイルを訪問する他のコマンドは、ファイルを訪問している既存
のバッファへの切り替えにも使えることに注意してください。*Note Visiting::。

Emacsは、内部目的用のバッファには、空白で始まるバッファ名を使います。
Emacsは、これらのバッファを少々特別に扱います。たとえば、デフォルトでは、
アンドゥ情報を記録しません。このようなバッファ名は避けるのが最良です。



File: emacs-ja.info, Node: List Buffers, Next: Misc Buffer, Prev: Select Buffer, Up: Buffers

既存バッファの一覧
==================

`C-x C-b'
     既存バッファを一覧表示する（`list-buffers'）。

既存のすべてのバッファを一覧表示するには、`C-x C-b'と打ちます。各行は、
バッファ名、メジャーモード、訪問しているファイルを示します。バッファは選
択された順に表示されます。もっとも最近に選択されたバッファが始めにきます。

行頭の`*'は、バッファが『修正され』ていることを示します。いくつかのバッ
ファが修正されているなら、`C-x s'でいくつかのバッファを保存する時期かも
しれません（*Note Saving::）。`%'は、読み出し専用バッファを示します。`.'
は選択されているバッファに付けられます。つぎは、バッファ一覧の例です。

      MR Buffer         Size  Mode           File
      -- ------         ----  ----           ----
     .*  emacs.tex      383402 Texinfo       /u2/emacs/man/emacs.tex
         *Help*         1287  Fundamental	
         files.el       23076 Emacs-Lisp     /u2/emacs/lisp/files.el
       % RMAIL          64042 RMAIL          /u/rms/RMAIL
      *% man            747   Dired          /u2/emacs/man/		
         net.emacs      343885 Fundamental   /u/rms/net.emacs
         fileio.c       27691 C              /u2/emacs/src/fileio.c
         NEWS           67340 Text           /u2/emacs/etc/NEWS
         *scratch*	   0	 Lisp Interaction

バッファ`*Help*'は、ヘルプ要求で作られたものです。このバッファはファイル
を訪問していません。バッファ`man'は、ディレクトリ`/u2/emacs/man/'に対し
てdiredが作ったものです。



File: emacs-ja.info, Node: Misc Buffer, Next: Kill Buffer, Prev: List Buffers, Up: Buffers

その他のバッファ操作
====================

`C-x C-q'
     バッファの読み出し専用状態を切り替える（`vc-toggle-read-only'）。
`M-x rename-buffer RET NAME RET'
     カレントバッファの名前を変更する。
`M-x rename-uniquely'
     名前の最後に`<NUMBER>'を付加してカレントバッファ名を変更する。
`M-x view-buffer RET BUFFER RET'
     バッファBUFFERをスクロールする。

バッファは、"読み出し専用"にもなります。そうすると、その内容を変更するコ
マンドは許されません。モード行では、左端付近に`%%'や`%*'を表示して、読み
出し専用バッファであることを示します。通常、読み出し専用バッファは、テキ
ストを操作する特別なコマンドを持つdiredやrmailなどのサブシステムが作りま
す。書き込みを禁止されたファイルを訪問しても読み出し専用バッファが作られ
ます。

読み出し専用バッファで変更したいときには、コマンド`C-x C-q'を使います
（`vc-toggle-read-only'）。これは、読み出し専用バッファは書き込み可能に
し、書き込み可能バッファは読み出し専用にします。多くの場合、これは変数
`buffer-read-only'を設定することで動作します。この変数は各バッファでロー
カルな値を持ち、値が`nil'以外だとバッファは読み出し専用になります。ファ
イルが版管理の下に置かれている場合には、`C-x C-q'は版管理システムを介し
てバッファだけでなくファイルの読み出し専用の状態も変更します。*Note
Version Control::。

`M-x rename-buffer'は、カレントバッファの名前を変更します。ミニバッファ
引数として新しい名前を指定します。デフォルトはありません。すでに他のバッ
ファに使っている名前を指定すると、エラーになり、名前は変更されません。

`M-x rename-uniquely'は、他のどれとも違う唯一の名前にするために、カレン
トバッファ名に数字の接尾辞を付け加えて似た名前に変更します。このコマンド
は引数を必要としません。このコマンドは複数のシェルバッファを作るのに便利
です。バッファ`*Shell*'を改名すれば、`M-x shell'をふたたび実行してバッファ
名`*Shell*'の新しいシェルバッファを作れます。一方、古いシェルバッファは、
新しい名前で存在し続けます。この方法は、メイルバッファ、コンパイルバッ
ファ、特定の名前のバッファを作るEmacsの多くの機能にも有効です。

`M-x view-buffer'は、既存のEmacsバッファを調べることを除けば、`M-x
view-file'（*Note Misc File Ops::）によく似ています。閲覧（view）モード
には、バッファを簡単にスクロールするためのコマンドがありますが、変更する
コマンドはありません。`q'で閲覧（view）モードから抜けると、ウィンドウに
まえに表示していたバッファ（とその中での箇所）に切り替わります。あるいは、
`e'で閲覧（view）モードから抜けると、閲覧していたバッファとそのポイント
位置はそのまま残ります。

コマンド、`M-x append-to-buffer'と`M-x insert-buffer'は、1つのバッファか
ら別のバッファへテキストをコピーするのに使います。*Note Accumulating
Text::。



File: emacs-ja.info, Node: Kill Buffer, Next: Several Buffers, Prev: Misc Buffer, Up: Buffers

バッファの消去
==============

Emacsのセッションをしばらく続けると、たくさんの数のバッファが溜っている
でしょう。もう必要としないバッファを"消去"したほうがよいと思うかもしれま
せん。多くのオペレーティングシステムでは、バッファを消去するとそのメモリ
領域を解放してオペレーティングシステムに返すので、他のプログラムが使える
ようになります。バッファを消去するコマンドをいくつかあげます。

`C-x k BUFNAME RET'
     バッファBUFNAMEを消去する（`kill-buffer'）。
`M-x kill-some-buffers'
     1つ1つ各バッファを消去するかどうか聞いてくる。


`C-x k'（`kill-buffer'）は、ミニバッファで指定した名前のバッファを消去し
ます。ミニバッファでRETだけ打ったときに使われるデフォルトは、カレントバッ
ファを消去することです。カレントバッファを消去すると、別のバッファが選択
されます。どのウィンドウにも表示されていない、もっとも最近に選択されたバッ
ファです。ファイルを訪問して修正してある（編集後に保存していない）バッファ
を消去しようとすると、バッファを消去するまえに`yes'での確認を求めます。

コマンド`M-x kill-some-buffers'は、1つ1つ各バッファについて消去するか聞
いてきます。`y'と答えると、そのバッファを消去します。カレントバッファや
未保存の変更を含むバッファを消去しようとすると、新しいバッファを選択する
か`kill-buffer'のように確認を求めてきます。

バッファメニュー機能（*Note Several Buffers::）も、さまざまなバッファを
削除するのに便利です。

バッファを削除するときに、毎回何か特別なことをしたいならば、フック
`kill-buffer-hook'にフック関数を追加します（*Note Hooks::）。

多くの人々がやるように、何日にもわたってたった1つのEmacsセッションを実行
する場合、数日前に使ったバッファで一杯になることがあります。コマンド`M-x
clean-buffer-list'は、それらのバッファを消去する便利な方法です。長い期間
にわたって使っていない未修正のバッファすべてを消去します。3日間表示して
いない普通のバッファは消去されます。しかし、特定のバッファを自動的には消
去しないようにしたり、ほんの数時間使用しないだけで消去するようにも指定で
きます。

真夜中（midnight）モードをオンにすれば、このようなバッファの消去を毎日真
夜中に行わせることもできます。真夜中（midnight）モードは、毎日真夜中に動
作します。真夜中に、`clean-buffer-list'、あるいは、ノーマルフック
`midnight-hook'に指定した関数を実行します。

真夜中（midnight）モードをオンにするには、カスタマイズ（customization）
バッファを使って、変数`midnight-mode'に`t'を設定します。*Note Easy
Customization::。



File: emacs-ja.info, Node: Several Buffers, Next: Indirect Buffers, Prev: Kill Buffer, Up: Buffers

複数バッファの操作
==================

"バッファメニュー"（buffer-menu）機能は『バッファに対するdired』に似てい
ます。このコマンドは、バッファ一覧を収めたEmacsバッファを編集することで、
さまざまなEmacsバッファを操作できます。バッファの保存、消去（ここでは
diredとの一貫性のために"削除"と呼ぶ）、表示を行うことができます。

`M-x buffer-menu'
     すべてのEmacsバッファの一覧を収めたバッファを編集し始める。

コマンド`buffer-menu'は、すべてのEmacsバッファの一覧をバッファ`*Buffer
List*'に書き、そのバッファをバッファメニュー（buffer-menu）モードにして
選択します。そのバッファは読み出し専用で、本節で述べる特別なコマンドでの
み変更できます。普通のEmacsカーソル移動コマンドは、`*Buffer List*'バッファ
でも使えます。つぎにあげるコマンドは、現在行に書かれているバッファに作用
します。

`d'
     バッファを削除（消去）するように指示し、1行下へ移動する。この指示は、
     その行のバッファ名のまえに`D'を表示する。指示した削除は、`x'コマン
     ドを打ったときに実行される。
`C-d'
     `d'に似ているが、1行下へ移動するかわりに上へ移動する。
`s'
     バッファを保存するように指示する。この指示により、行には`S'が表示さ
     れる。指示した保存は、`x'コマンドを打ったときに実行される。同じバッ
     ファに対して、保存と削除の両方を指示できる。
`x'
     まえに指示した削除と保存を実行する。
`u'
     現在行に対する指示を消し、1行下へ移動する。
`DEL'
     1つまえの行に移動し、その行に対するどんな指示も消す。

`d'、`C-d'、`s'、`u'コマンドは、フラグを追加または削除して、1行下へ（あ
るいは上へ）移動します。これらのコマンドは、反復回数として数引数を取りま
す。

つぎにあげるコマンドは、現在行に書かれているバッファにただちに作用します。

`~'
     バッファに『変更なし』と印を付ける。コマンド`~'を打つと、ただちに実
     行する。
`%'
     バッファの読み出し専用フラグをトグルする。コマンド`%'を打つと、ただ
     ちに実行する。
`t'
     タグテーブルとしてバッファを訪問する。*Note Select Tags Table::。

他のバッファや複数のバッファを選択するコマンドもあります。

`q'
     バッファメニューをやめる。このウィンドウには、ここに表示していたもっ
     とも最近のバッファを表示する。
`RET'
`f'
     `*Buffer List*'のかわりに、この行のバッファをただちに選択する。
`o'
     `C-x 4 b'のように、別のウィンドウでこの行のバッファをただちに選択す
     る。`*Buffer List*'はそのまま。
`C-o'
     別のウィンドウにこの行のバッファをただちに表示するが、そのウィンド
     ウを選択しない。
`1'
     この行のバッファを画面一杯のウィンドウにただちに選択する。
`2'
     ただちに2つのウィンドウにして、この行のバッファをその1つに、
     （`*Buffer List*'バッファを除いて）まえに選択していたバッファをもう
     1つに表示する。
`b'
     この行のバッファを一覧の最後に移す。
`m'
     `v'コマンドでバッファメニューをやめたときに、この行のバッファを別の
     ウィンドウに表示するように印を付ける。この指示は、行頭に`>' を表示
     する。（1つのバッファに、削除指示と表示指示の両方を付けることはでき
     ない。）
`v'
     ただちにこの行のバッファを選択し、別のウィンドウ群には`m'コマンドで
     印を付けたバッファ群を表示する。印を付けたバッファがなければ、この
     コマンドは`1'コマンドと同じ。

`buffer-menu'が直接行うことは、適切なバッファを作成してそれに切り替えて
から、バッファメニュー（buffer-menu）モードにすることです。それ以外の上
に述べたことはすべて、バッファメニュー（buffer-menu）モードが用意した特
別なコマンドで実装されています。その結果、`*Buffer List*'バッファから別
のEmacsバッファへ切り替えて、そこで編集できます。あとで`*Buffer List*'バッ
ファをふたたび選択してすでに指示した操作を実行したり、このバッファを削除
したり、無視したりもできます。

`buffer-menu'と`list-buffers'の唯一の違いは、`buffer-menu'は選択されたウィ
ンドウで`*Buffer List*'バッファに切り替えることです。`list-buffers'は別
のウィンドウにこのバッファを表示するだけです。`list-buffers'を実行し（つ
まり、`C-x C-b'と打つ）、`*Buffer List*'バッファを手動で選択すると、ここ
に述べたすべてのコマンドを使えます。

バッファを作成したり削除したりしても、バッファ`*Buffer List*'は自動的に
更新されません。その内容はただのテキストにすぎません。バッファを作成／削
除／改名したら、現在のバッファの状態を見るために`*Buffer List*'を更新す
る方法は、`g'（`revert-buffer'）を打つか、`buffer-menu'コマンドを再度実
行することです。



File: emacs-ja.info, Node: Indirect Buffers, Prev: Several Buffers, Up: Buffers

間接バッファ
============

"間接バッファ"は、他のバッファとテキストを共有します。そのような他のバッ
ファを間接バッファの"基底バッファ"と呼びます。ある意味で、ファイルのあい
だのシンボリックリンクに似ています。

`M-x make-indirect-buffer BASE-BUFFER RET INDIRECT-NAME RET'
     BASE-BUFFERを基底バッファとする間接バッファINDIRECT-NAMEを作る。

間接バッファのテキストはつねに基底バッファのテキストと同じです。どちらか
片方を編集して変更すると、他方のバッファでもすぐにそれが見えます。しかし、
それ以外のすべての点では、間接バッファとその基底バッファは完全に別のもの
です。これらは、異なる名前、異なるポイントの値、異なるナロイング、異なる
マーカ、異なるメジャーモード、異なるローカル変数を持ちます。

間接バッファではファイルを訪問できませんが、基底バッファではできます。間
接バッファを保存しようとすると、実際には基底バッファを保存します。基底バッ
ファを消去すると間接バッファも消去されますが、間接バッファを消去しても基
底バッファには影響しません。

間接バッファの使い方の1つは、アウトラインを複数の視点で表示することです。
*Note Outline Views::。


File: emacs-ja.info, Node: Windows, Next: Frames, Prev: Buffers, Up: Top

複数のウィンドウ
****************

Emacsは、フレームを2つ以上のウィンドウに分割できます。複数のウィンドウは、
異なるバッファの一部分、あるいは、1つのバッファの異なる部分を表示するこ
とができます。複数フレームはつねに複数ウィンドウを意味します。というのは、
各フレームはそれ独自のウィンドウの集合を持つからです。各ウィンドウはたっ
た1つのフレームだけに属します。

* Menu:

* Basic Window::        Introduction to Emacs windows.
* Split Window::        New windows are made by splitting existing windows.
* Other Window::        Moving to another window or doing something to it.
* Pop Up Window::       Finding a file or buffer in another window.
* Force Same Window::   Forcing certain buffers to appear in the selected
                          window rather than in another window.
* Change Window::       Deleting windows and changing their sizes.



File: emacs-ja.info, Node: Basic Window, Next: Split Window, Up: Windows

Emacsウィンドウの概念
=====================

各Emacsウィンドウは、いつでも1つのEmacsバッファを表示します。1つのバッファ
は複数のウィンドウに表示できます。その場合、そのテキストの変更は、そのバッ
ファを表示しているすべてのウィンドウで表示されます。しかし、同じバッファ
を表示している各ウィンドウではバッファの異なる部分を表示することができま
す。なぜなら、各ウィンドウはそれ自身のポイント値を持つからです。

どんなときでも、1つのウィンドウだけが"選択されたウィンドウ"です。そのウィ
ンドウに表示されているバッファがカレントバッファです。端末のカーソルは、
そのウィンドウのポイント位置を示します。別の各ウィンドウにもそれぞれ同じ
ようにポイント位置がありますが、端末にはカーソルは1つしかないので、それ
らの位置を示す方法がありません。Xウィンドウシステムで複数フレームを表示
しているときには、各フレームには、そのフレームで選択されたウィンドウにカー
ソルがあります。選択されているフレームのカーソルは塗り潰されている矩形で、
それ以外のフレームのカーソルは中空の矩形です。

ポイントを移動するコマンドは、選択されているEmacsウィンドウのポイント値
に対してだけ影響します。たとえ同じバッファを表示しているとしても、他の
Emacsウィンドウのポイント値は変更しません。選択しているウィンドウで選択
しているバッファを変更する`C-x b'といったコマンドでも同様です。他のウィ
ンドウには少しも影響しません。しかし、別のウィンドウを選択してそのバッファ
を切り替える`C-x 4 b'のようなコマンドもあります。さらに、（たとえば）
`C-h f'（`describe-function'）や`C-x C-b'（`list-buffers'）などを含むウィ
ンドウに情報を表示するコマンドは、選択されているウィンドウに影響すること
なく、選択されていないウィンドウのバッファを切り替えます。

複数のウィンドウが同じバッファを表示するとき、異なるリージョンを持つこと
ができます。というのは、各ウィンドウは、それぞれ異なるポイント値を持てる
からです。しかしながら、各バッファにはたった1つのマーク位置しかないため、
マークの値はすべて同じになります。

各ウィンドウにはそれ専用のモード行があり、そこにはウィンドウに表示してい
るバッファの名前、修正状態、バッファのメジャーモード、バッファのマイナモー
ドを表示します。モード行に関して詳しくは、*Note Mode Line::。




File: emacs-ja.info, Node: Split Window, Next: Other Window, Prev: Basic Window, Up: Windows

ウィンドウの分割
================

`C-x 2'
     選択されているウィンドウを上下2つに分割する。
     （`split-window-vertically'）。
`C-x 3'
     選択されているウィンドウを左右2つに分割する
     （`split-window-horizontally'）。
`C-Mouse-2'
     ウィンドウのモード行やスクロールバー上の位置で、そのウィンドウを分
     割する。

コマンド`C-x 2'（`split-window-vertically'）は、選択されているウィンドウ
を上下2つのウィンドウに分割します。どちらのウィンドウも同じポイント値、
同じバッファを表示するところから始まります。デフォルトでは2つのウィンド
ウは、それぞれ、分割されるウィンドウの半分の高さになります。数引数は上の
ウィンドウの行数を指定します。

`C-x 3'（`split-window-horizontally'）は、選択されているウィンドウを左右
2つのウィンドウに分割します。数引数は左側のウィンドウの桁数を指定します。
2つのウィンドウはスクロールバーで分けられます。画面幅に満たないウィンド
ウのモード行は、切り詰められます。Emacsが強調表示を扱えない端末では、切
り詰めたモード行が反転表示されない場合があります。

モード行やスクロールバーで`C-Mouse-2'をクリックすることで、ウィンドウを
左右や上下に分割できます。 分割する線はクリックした位置を通ります。モー
ド行でクリックすると、新しいスクロールバーはクリックした点上を通ります。
スクロールバーでクリックすると、分割したウィンドウのモード行はクリックし
た位置に並びます。

ウィンドウの幅が十分でないと、長すぎて行に入りきらないテキスト行が多くな
ります。これらの行すべてを継続すると混乱してしまうかもしれません。変数
`truncate-partial-width-windows'に`nil'以外を設定すると、画面幅に満たな
いすべてのウィンドウで切り詰めを強制できます。これは、表示されているバッ
ファや`truncate-lines'の値とは独立しています。*Note Continuation Lines::。

水平スクロールは左右に並べたウィンドウでよく使われます。*Note Display::。

`split-window-keep-point'の値が`nil'以外（デフォルト）ならば、`C-x 2'で
分割した2つのウィンドウは、分割前のウィンドウのポイント値を継承します。
つまり、スクロールを避けられません。この変数が`nil'ならば、`C-x 2'は、画
面上のテキストが移動しないように、各ウィンドウで見えている部分にポイント
を移動しようと試みます。また、分割前にカーソルがあった行を表示しているウィ
ンドウを選択します。遅い端末では後者の動作を好むユーザーもいます。



File: emacs-ja.info, Node: Other Window, Next: Pop Up Window, Prev: Split Window, Up: Windows

別のウィンドウの使い方
======================

`C-x o'
     別のウィンドウを選択する（`other-window'）。（小文字の）`o'であって
     ゼロではない。
`C-M-v'
     つぎのウィンドウをスクロールする（`scroll-other-window'）。
`M-x compare-windows'
     選択されているウィンドウのテキストとつぎのウィンドウのテキストで一
     致していないつぎの箇所を探す。
`Mouse-1'
     ウィンドウのモード行で`Mouse-1'をクリックすると、そのウィンドウを選
     択するがポイントは移動しない（`mouse-select-window'）。

別のウィンドウを選択するには、そのモード行で`Mouse-1'をクリックします。
キーボードからは、`C-x o'（`other-window'）でウィンドウを切り替えられま
す。これは「other」の`o'であってゼロではありません。2つ以上のウィンドウ
があるときは、このコマンドはすべてのウィンドウを、一般的には、上から下へ、
左から右へ巡回します。もっとも右下のウィンドウのつぎは、左上隅にあるウィ
ンドウに戻ります。数引数は、ウィンドウを巡回する回数を意味します。負の引
数では逆順に巡回します。ミニバッファを使っているときには、ミニバッファが
巡回の最後のウィンドウになります。ミニバッファウィンドウから別のウィンド
ウに切り替えて、あとで戻ってきて、ミニバッファ引数が要求しているものを与
えてから終了できます。*Note Minibuffer Edit::。

通常のスクロールコマンド（*Note Display::）は、選択されているウィンドウ
のみに作用しますが、つぎのウィンドウをスクロールするコマンドが1つありま
す。`C-M-v'（`scroll-other-window'）は、`C-x o'が選択するウィンドウをス
クロールします。`C-v'のように正負の引数を取ります。（ミニバッファでは、
ミニバッファヘルプがあると、標準の巡回順でつぎのウィンドウではなくて、ミ
ニバッファヘルプを表示しているウィンドウをスクロールする。）

コマンド`M-x compare-windows'は、2つのウィンドウで見えている2つのファイ
ル、つまり、バッファを比較して、一致しないつぎの箇所へ移動します。詳細は、
*Note Comparing Files::。



File: emacs-ja.info, Node: Pop Up Window, Next: Force Same Window, Prev: Other Window, Up: Windows

別のウィンドウに表示する
========================

`C-x 4'は、（ウィンドウが1つだけならば分割して）別のウィンドウを選択して、
そのウィンドウでバッファを選択するコマンドのプレフィックスキーです。異な
る`C-x 4'コマンドは、異なる方法で選択するバッファを探します。

`C-x 4 b BUFNAME RET'
     別のウィンドウでバッファBUFNAMEを選択する。このコマンドは、
     `switch-to-buffer-other-window'を実行する。
`C-x 4 C-o BUFNAME RET'
     別のウィンドウでバッファBUFNAMEを表示するが、そのウィンドウもそのバッ
     ファも選択しない。このコマンドは、`display-buffer'を実行する。
`C-x 4 f FILENAME RET'
     ファイルFILENAMEを訪問して、別のウィンドウでそのバッファを選択する。
     このコマンドは、`find-file-other-window'を実行する。*Note
     Visiting::。
`C-x 4 d DIRECTORY RET'
     別のウィンドウでディレクトリDIRECTORYに対するdiredバッファを選択す
     る。このコマンドは、`dired-other-window'を実行する。*Note Dired::。
`C-x 4 m'
     別のウィンドウでメイルメッセージを作成し始める。このコマンドは、
     `mail-other-window'を実行する。これは、同じウィンドウを使う`C-x m'
     に類似したもの。（*Note Sending Mail::）。
`C-x 4 .'
     別のウィンドウで現在のタグテーブルのタグを探す。このコマンドは、
     `find-tag-other-window'を実行するが、`M-.'の複数ウィンドウ向けの変
     種（*Note Tags::）。
`C-x 4 r FILENAME RET'
     ファイルFILENAMEを読み出し専用で訪問し、別のウィンドウでそのバッファ
     を選択する。このコマンドは `find-file-read-only-other-window'を実行
     する。*Note Visiting::。



File: emacs-ja.info, Node: Force Same Window, Next: Change Window, Prev: Pop Up Window, Up: Windows

同じウィンドウへの強制表示
==========================

ある種のEmacsコマンドは、特別な内容を持つ特有のバッファに切り替えます。
たとえば、 `M-x shell'は、`*Shell*'という名前のバッファに切り替えます。
慣習では、これらのすべてのコマンドは、別のウィンドウにバッファを立ち上げ
るようにプログラムされています。しかし、これらのバッファのいくつかを選択
されているウィンドウに表示するように指定できます。

バッファ名をリスト`same-window-buffer-names'に追加すると、そういったコマ
ンドは、選択されているウィンドウで特定のバッファに切り替えます。たとえば、
そのリストに要素`"*grep*"'を追加すれば、`grep'コマンドは、選択されている
ウィンドウにその出力バッファを表示します。

`same-window-buffer-names'のデフォルト値は`nil'ではありません。（古い
Emacsパッケージが使うものも含めて）バッファ名、`*info*'、`*mail*'、
`*shell*'を指定してあります。このため、`M-x shell'が通常は選択されている
ウィンドウで`*shell*'バッファに切り替えるのです。もしこの要素を
`same-window-buffer-names'から削除すると、`M-x shell'のふるまいは変わり
ます。かわりに別のウィンドウでバッファを立ち上げます。

これらのバッファを、より一般的に変数`same-window-regexps'で指定できます。
この変数には、正規表現のリストを設定します。そうすると、正規表現の1つに
一致するバッファはどれも、選択されているウィンドウでバッファを切り替えて
表示します。（繰り返すが、これは、普通は別のウィンドウに表示されるバッファ
のみにあてはまる。）この変数のデフォルト値には、telnetバッファとrloginバッ
ファが指定されています。

類似の機能で、独立したフレームに表示させるバッファを指定することができま
す。*Note Special Buffer Frames::。



File: emacs-ja.info, Node: Change Window, Prev: Force Same Window, Up: Windows

ウィンドウの削除と再配置
========================

`C-x 0'
     選択されているウィンドウを削除する（`delete-window'）。このキー列の
     最後の文字はゼロ。
`C-x 1'
     選択されているウィンドウを除いて、選択されているフレームのウィンド
     ウすべてを削除する（`delete-other-windows'）。
`C-x 4 0'
     選択されているウィンドウを削除し、その中に表示されているバッファを
     削除する（`kill-buffer-and-window'）。このキー列の最後の文字はゼロ。
`C-x ^'
     選択されているウィンドウの高さを大きくする（`enlarge-window'）。
`C-x }'
     選択されているウィンドウの幅を広くする
     （`enlarge-window-horizontally'）。
`C-x {'
     選択されているウィンドウの幅を狭くする
     （`shrink-window-horizontally'）。
`C-x -'
     バッファがそんなに多くの行を必要としないならウィンドウを縮める
     （`shrink-window-if-larger-than-buffer'）。
`C-x +'
     すべてのウィンドウを同じ高さにする（`balance-windows'）。
`Drag-Mouse-1'
     ウィンドウのモード行を`Mouse-1'で上下にドラッグして、ウィンドウの高
     さを変更する。
`Mouse-2'
     ウィンドウのモード行で`Mouse-2'をクリックすると、フレーム内のそのウィ
     ンドウ以外のすべてのウィンドウを削除する
     （`mouse-delete-other-windows'）。
`Mouse-3'
     ウィンドウのモード行で`Mouse-3'をクリックすると、そのウィンドウを削
     除する（`mouse-delete-window'）。

ウィンドウを削除するには、`C-x 0'（`delete-window'）と打ちます（これはゼ
ロ）。削除されたウィンドウが占めていた場所は、隣接のウィンドウに与えられ
ます。（ただし、ミニバッファのウィンドウを使っている場合でも、ミニバッファ
のウィンドウには与えない。）ウィンドウを一度削除すると、その属性は失われ
ます。ウィンドウの構成情報を回復する以外にウィンドウをもとに戻す方法はあ
りません。ウィンドウを削除しても、そこに表示していたバッファには何の影響
もありません。バッファは存在し続け、どのウィンドウへでも`C-x b'で選択で
きます。

`C-x 4 0'（`kill-buffer-and-window'）は、`C-x 0'よりも強いコマンドです。
これは、カレントバッファを削除し、そこで選択されていたウィンドウを削除し
ます。

`C-x 1'（`delete-other-windows'）は、別の意味でさらに強力です。選択され
ているウィンドウ（とミニバッファ）を除いて、すべてのウィンドウを削除しま
す。選択されているウィンドウは、エコー領域を除いたフレーム全体を使うよう
に広がります。

モード行で`Mouse-2'をクリックしても、そのウィンドウを削除できます。モー
ド行で`Mouse-3'をクリックすると、そのウィンドウを除いて、フレーム内のす
べてのウィンドウを削除します。

ウィンドウの高さを調節するもっとも簡単な方法は、マウスを使うことです。モー
ド行で`Mouse-1'を押し下げてモード行を上下にドラッグすると、ウィンドウの
高さを変更できます。

上下に接しているウィンドウの分割を再調整するには、`C-x ^'
（`enlarge-window'）を使います。このコマンドは、現在選択されているウィン
ドウを1行だけ、あるいは、数引数分の行数だけ大きくします。負の引数を指定
すると、選択されているウィンドウは小さくなります。`C-x }'
（`enlarge-window-horizontally'）は、選択されているウィンドウを指定され
た桁数分だけ広くします。`C-x {'（`shrink-window-horizontally'）は、選択
されているウィンドウを指定された桁数分だけ狭くします。

ウィンドウを大きくするとき、その場所は隣のウィンドウから取ります。その結
果、ウィンドウが小さくなりすぎるとそのウィンドウは削除され、その場所を隣
接するウィンドウに与えます。最小の大きさは変数`window-min-height'と
`window-min-width'で指定します。

コマンド`C-x -'（`shrink-window-if-larger-than-buffer'）は、選択されてい
るウィンドウの高さが、表示しているバッファのテキスト全体を表示するために
必要な高さよりも大きい場合には、その高さを縮めます。余った行はフレーム内
の他のウィンドウに与えられます。

選択されているフレーム内のすべてのウィンドウの高さをすべて同じにするには、
`C-x +'（`balance-windows'）を使えます。

ミニバッファのテキストにちょうど合うようにミニバッファウィンドウの大きさ
を自動的に変更するミニバッファリサイズ（resize-minibuffer）モードについ
ては、*Note Minibuffer Edit::。


File: emacs-ja.info, Node: Frames, Next: International, Prev: Windows, Up: Top

フレームとXウィンドウシステム
*****************************

Xウィンドウシステムで使っているときには、1つのEmacsセッションでXのレベル
で複数のウィンドウを作ることができます。Emacsに属するXの各ウィンドウは、
Emacsのウィンドウを1つ以上含めことができる"フレーム"（frame）を表示しま
す。フレームは、最初は汎用のEmacsのウィンドウを1つ含みますが、上下左右に
小さなウィンドウに分割できます。フレームは通常、専用のエコー領域とミニバッ
ファを含みますが、それらを含まないものを作ることもできます。その場合は、
別のフレームのエコー領域やミニバッファを使います。

あるフレームでの編集は、別のフレームにも影響します。たとえば、あるフレー
ムでキルリングにテキストを入れると、別のフレームでヤンクできます。あるフ
レームで`C-x C-c'でEmacsを終ると、すべてのフレームを終了します。1つのフ
レームだけを削除するなら、`C-x 5 0'を使います。

混乱を避けるために、Emacsが実装している細分化できるものを『ウィンドウ』
と呼び、フレームを意味するときにはこの単語を使いません。

MS-DOS用にコンパイルしたEmacsは、ウィンドウシステムのある種の特徴をエミュ
レートするので、本章で説明する機能の多くを使うことができます。詳しくは、
*Note MS-DOS Input::。

* Menu:

* Mouse Commands::      Moving, cutting, and pasting, with the mouse.
* Secondary Selection:: Cutting without altering point and mark.
* Mouse References::    Using the mouse to select an item from a list.
* Menu Mouse Clicks::   Mouse clicks that bring up menus.
* Mode Line Mouse::     Mouse clicks on the mode line.
* Speedbar::            How to make and use a speedbar frame.
* Creating Frames::     Creating additional Emacs frames with various contents.
* Multiple Displays::   How one Emacs job can talk to several displays.
* Special Buffer Frames::  You can make certain buffers have their own frames.
* Frame Parameters::    Changing the colors and other modes of frames.
* Scroll Bars::	        How to enable and disable scroll bars; how to use them.
* Menu Bars::	        Enabling and disabling the menu bar.
* Faces::	        How to change the display style using faces.
* Font Lock::           Minor mode for syntactic highlighting using faces.
* Support Modes::       Font Lock support modes make Font Lock faster.
* Highlight Changes::   Using colors to show where you changed the buffer.
* Misc X::	        Iconifying and deleting frames. Region highlighting.
* Non-Window Terminals::  Multiple frames on terminals that show only one.



