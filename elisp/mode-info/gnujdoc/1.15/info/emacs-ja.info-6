Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999
Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU General
Public License" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU General Public License" may be included in a translation
approved by the Free Software Foundation instead of in the original
English.





File: emacs-ja.info, Node: Mouse Commands, Next: Secondary Selection, Up: Frames

編集用マウスコマンド
====================

リージョンを選択したりコピーしたりするマウスコマンドは、`xterm'プログラ
ムとほぼ互換です。Emacsと他のXクライアントプログラムとのあいだでコピーす
るには、Xのマウスコマンドと同じものを使えます。

これらのマウスコマンドでリージョンを選択して、そのあとすぐにファンクショ
ンキーDELETEを打つと、選択したリージョンを削除します。ファンクションキー
BACKSPACEやASCII文字DELは、これを行いません。マウスコマンドとDELETEのあ
いだに別のキーを打ったときも、これを行いません。

`Mouse-1'
     クリックした位置にポイントを移動する（`mouse-set-point'）。通常、左
     ボタン。

`Drag-Mouse-1'
     ドラッグにより選択したテキストにリージョンを設定し、キルリングにそ
     れをコピーする（`mouse-set-region'）。リージョンの始めと終りの両方
     をこのコマンド1つで指定できる。

     ドラッグ中に、ウィンドウの上下からマウスが出ると、マウスがウィンド
     ウ内に戻ってくるまで、ウィンドウを一定の割合でスクロールする。こう
     して、画面全体に入りきらないリージョンでも選択できる。一度にスクロー
     ルする行数は、マウスがウィンドウの縁からどの程度離れているかに依存
     する。変数`mouse-scroll-min-lines'には最小の行数を指定する。

`Mouse-2'
     クリックした場所に、もっとも最近にキルしたテキストをヤンクする
     （`mouse-yank-at-click'）。通常、中ボタン。

`Mouse-3'
     このコマンド`mouse-save-then-kill'は、クリックした場所とリージョン
     の状態に依存して、いくつかの機能がある。

     もっとも基本的な場合は、ある場所で`Mouse-1'をクリックしてから、別の
     場所で`Mouse-3'をクリックしたとき。こうすると、これらの2点のあいだ
     にあるテキストをリージョンとして選択する。さらに、新しいリージョン
     をキルリングへもコピーするので、別の場所へそれをコピーできる。

     テキスト上で`Mouse-1'をクリックしてから、スクロールバーでスクロール
     したあとで`Mouse-3'をクリックすると、スクロールする以前の
     （`Mouse-1'でクリックした）場所を覚えていて、そこをリージョンの片方
     の端点として使う。こうすると、画面に入りきらないリージョンでも選択
     できる。

     より一般的には、強調表示されたリージョンがないならば、`Mouse-3'は、
     ポイントとクリックした位置のあいだのテキストをリージョンとして選択
     する。これは、ポイントがあった位置にマークを設定し、クリックした位
     置にポイントを移動することで行う。

     強調表示されたリージョンがある場合、あるいは、ボタン1をドラッグして
     リージョンを設定してある場合、`Mouse-3'はクリックした場所に近い側の
     リージョンの端をクリック位置に移動して調整する。また、調整したリー
     ジョンのテキストは、キルリング内の古いリージョンのテキストを置き換
     える。

     もともと`Mouse-1'をダブルクリックあるいはトリプルクリックして、リー
     ジョンを単語や行単位で設定した場合には、`Mouse-3'によるリージョンの
     調整も単語や行単位で行われる。

     連続して2度同じ場所で`Mouse-3'を使うと、すでに選択してあるリージョ
     ンをキルする。

`Double-Mouse-1'
     このキーは、クリックした単語全体にリージョンを設定する。『シンボル』
     の構文（Cの下線のような）の文字をクリックすると、その文字を囲むシン
     ボル全体にリージョンを設定する。

     開き括弧や閉じ括弧の構文の文字をクリックすると、その文字で始まり／
     終る括弧で囲まれた塊（sexp）にリージョンを設定する。文字列区切りの
     構文（Cのシングルクォートやダブルクォート）の文字をクリックすると、
     （その文字が文字列の始まりか終りかを発見的方法を使って決めて）文字
     列定数を囲むリージョンを設定する。

`Double-Drag-Mouse-1'
     このキーは、ドラッグした範囲内にある単語を囲むリージョンを設定する。

`Triple-Mouse-1'
     このキーは、クリックした行全体を囲むリージョンを設定する。

`Triple-Drag-Mouse-1'
     このキーは、ドラッグした範囲内にある行すべてを囲むリージョンを設定
     する。

マウスを使ったもっとも単純なテキストのキル方法は、片方の端で`Mouse-1'を
押し、もう一方の端で`Mouse-3'を2回押すことです。*Note Killing::。バッファ
から削除しないでキルリングにテキストをコピーするには、`Mouse-3'を一度だ
け押します。あるいは、`Mouse-1'でテキストを横断してドラッグするだけです。
そうすると、どこででも、それをヤンクすることでコピーできます。

キルしたりコピーしたりしたテキストをどこか別の場所にヤンクするには、マウ
スをその場所に移動して`Mouse-2'を押します。*Note Yanking::。しかし、
`mouse-yank-at-point'が`nil'以外ならば、`Mouse-2'はポイント位置にヤンク
します。つまり、ウィンドウのどこをクリックしたのか、あるいは、フレームの
どのウィンドウをクリックしたのかは問題ではありません。デフォルトの値は
`nil'です。この変数は二次セレクションのヤンクにも影響します。

別のXのウィンドウへテキストをコピーするには、その部分をキルするかキルリ
ングに保存します。Xの管理下では、"一次セレクション"も設定します。そのあ
とで、別のXのウィンドウで動いているプログラムの『ペースト』や『ヤンク』
コマンドを使って、セレクションからテキストを挿入します。

別のXのウィンドウからテキストをコピーするには、そのウィンドウで動いてい
るプログラムの『カット』や『コピー』コマンドを使って目的のテキストをセレ
クションにします。そのあとで、`C-y'や`Mouse-2'を使ってEmacsにヤンクしま
す。

これらのカット／ペーストコマンドはMS-Windows上でも動作します。

Emacsがテキストをキルリングに入れたり、キルリングのテキストを先頭へ巡回
するとき、EmacsはXサーバーの一次セレクションに設定します。このために、別
のXクライアントがテキストを参照できるのです。テキストが十分に短い場合に
のみ（`x-cut-buffer-max'は最大文字数を指定する）、Emacsはカットバッファ
にもテキストを収めます。長い文字列をカットバッファへ置くには時間がかかり
ます。

キルリングの始めのテキストをヤンクするコマンドは、実際には、別のプログラ
ムの一次セレクションをまず調べ、そのあとで、カットバッファのテキストを調
べます。どちらにもヤンクするテキストがなれば、キルリングの内容を使います。



File: emacs-ja.info, Node: Secondary Selection, Next: Mouse References, Prev: Mouse Commands, Up: Frames

二次セレクション
================

"二次セレクション"は、Xにおいてテキストを選択する別の方法です。これは、
ポイントやマークを使わないので、ポイントやマークを設定せずにテキストを削
除するのに使えます。

`M-Drag-Mouse-1'
     ボタンを押した場所を片方の端、ボタンを離した場所をもう一方の端とし
     て、二次セレクションを設定する（`mouse-set-secondary'）。強調表示さ
     れドラッグするにつれて変化する。

     ドラッグ中にウィンドウの上下からマウスが出ると、ウィンドウへマウス
     が戻ってくるまで、ウィンドウを一定の割合でスクロールする。こうして、
     画面全体に入りきらないリージョンも選択できる。

`M-Mouse-1'
     "二次セレクション"の一方の端を設定する（`mouse-start-secondary'）。

`M-Mouse-3'
     `M-Mouse-1'で指定した場所を一方の端として使い、二次セレクションを設
     定する。（`mouse-secondary-save-then-kill'）。同じ位置での2回目のク
     リックは、ちょうど作成した二次セレクションをキルする。

`M-Mouse-2'
     クリックした位置に二次セレクションを挿入する
     （`mouse-yank-secondary'）。ヤンクしたテキストの最後にポイントを置
     く。

`M-Mouse-1'のダブルクリックやトリプルクリックは、`Mouse-1'のように単語や
行単位に作用します。

`mouse-yank-at-point'が`nil'以外ならば、`M-Mouse-2'はポイント位置にヤン
クします。そのときには、どこをクリックしたかは関係なく、どのウィンドウを
クリックしたかだけが関係します。*Note Mouse Commands::。



File: emacs-ja.info, Node: Mouse References, Next: Menu Mouse Clicks, Prev: Secondary Selection, Up: Frames

マウスで参照を辿る
==================

いくつかのEmacsバッファでは、いろいろなものの一覧を表示します。ファイル
一覧、バッファ一覧、補完候補一覧、パターンに一致したものの一覧などです。

これらのバッファにテキストをヤンクできても便利ということはないので、これ
らの多くは`Mouse-2'を特別に定義して、クリックした項目を使ったり眺めたり
するコマンドとしています。

たとえば、diredバッファのファイル名を`Mouse-2'でクリックすると、そのファ
イルを訪問します。`*Compilation*'バッファのエラーメッセージを`Mouse-2'で
クリックすると、そのエラーメッセージに対応するソースコードへ行きます。
`*Completions*'バッファの補完候補を`Mouse-2'でクリックすると、その補完候
補を選択します。

反応するテキストの上にマウスが移動するとテキストが強調表示されるので、
`Mouse-2'がいつ特別な意味を持つか普通はわかります。



File: emacs-ja.info, Node: Menu Mouse Clicks, Next: Mode Line Mouse, Prev: Mouse References, Up: Frames

メニューを出すマウスクリック
============================

CTRLやSHIFTキーで修飾されたマウスクリックは、メニューを立ち上げます。

`C-Mouse-1'
     バッファを選択するためのメニュー。

`C-Mouse-2'
     整形済みのテキストに使うフェイスやテキスト属性を指定するためのメ
     ニュー。*Note Formatted Text::。

`C-Mouse-3'
     モードに特有のメニュー。ほとんどのモードでは、このメニューは、すべ
     てのモード特有のメニューバーメニューを一緒にしたのと同じ項目を持つ。
     いくつかのモードでは、このボタン (1) (*Note Menu Mouse
     Clicks-Footnotes::) に異なるメニューを指定しているかもしれない。


`S-mouse-1'
     フレームの主要フォントの指定に関するメニュー。


File: emacs-ja.info  Node: Menu Mouse Clicks-Footnotes, Up: Menu Mouse Clicks

(1) いくつかのシステムでは、`Mouse-3'をモード特有のメニューに使
う。ユーザーを調査した結果、`Mouse-3'をリージョンの選択とキルに
使い続けることが好まれていることが判明した。ゆえに、このメニューに
対して`C-Mouse-3'を使うことにした。



File: emacs-ja.info, Node: Mode Line Mouse, Next: Speedbar, Prev: Menu Mouse Clicks, Up: Frames

モード行のマウスコマンド
========================

ウィンドウを選択したり操作するために、ウィンドウのモード行でマウスクリッ
クを使えます。

`Mouse-1'
     モード行で`Mouse-1'をクリックするとその上のウィンドウを選択する。モー
     ド行を`Mouse-1'でドラッグするとモード行を移動することができ、そのウィ
     ンドウの高さを変更できる。

`Mouse-2'
     モード行で`Mouse-2'をクリックすると、そのフレーム一杯にウィンドウを
     広げる。

`Mouse-3'
     モード行で`Mouse-3'をクリックすると、その上のウィンドウを削除する。

`C-Mouse-2'
     モード行で`C-Mouse-2'をクリックすると、モード行をクリックした場所で
     その上のウィンドウを左右に分割する。

スクロールバーで`C-Mouse-2'をクリックすると、対応するウィンドウを上下に
分割します。*Note Split Window::。



File: emacs-ja.info, Node: Creating Frames, Next: Multiple Displays, Prev: Speedbar, Up: Frames

フレームの作成
==============

プレフィックスキー`C-x 5'は、`C-x 4'と同じようなサブコマンドがあるという
点で似ています。違いは、`C-x 5'コマンドは、選択されているフレームで新た
にウィンドウを作るのではなく、新しいフレームを作ることです（*Note Pop Up
Window::）。既存の見えているフレームやアイコン化されたフレームが、要求さ
れた内容を表示しているなら、これらのコマンドは、必要ならフレームをいちば
ん手前にもってきたりアイコンを開いてから、既存のフレームを使います。

さまざまな`C-x 5'コマンドは、選択するバッファの探し方や作成方法が異なり
ます。

`C-x 5 2'
     新しいフレームを作る（`make-frame-command'）。
`C-x 5 b BUFNAME RET'
     別のフレームでバッファBUFNAMEを選択する。これは、
     `switch-to-buffer-other-frame'を実行する。
`C-x 5 f FILENAME RET'
     ファイルFILENAMEを訪問して、別のフレームでそのバッファを選択する。
     これは、`find-file-other-frame'を実行する。*Note Visiting::。
`C-x 5 d DIRECTORY RET'
     別のフレームでディレクトリDIRECTORYに対するdiredバッファを選択する。
     これは、`dired-other-frame'を実行する。*Note Dired::。
`C-x 5 m'
     別のフレームでメイルメッセージの作成を始める。これは、
     `mail-other-frame'を実行する。これは、`C-x m'の他のフレームを使う変
     形版。*Note Sending Mail::。
`C-x 5 .'
     別のフレームで現在のタグテーブルからタグを探す。これは、
     `find-tag-other-frame'を実行し、`M-.'の複数フレーム向けの変形版。
     *Note Tags::。
`C-x 5 r FILENAME RET'
     ファイルFILENAMEを読み出し専用で訪問し、別のフレームでそのバッファ
     を選択する。これは、`find-file-read-only-other-frame'を実行する。
     *Note Visiting::。

`default-frame-alist'にフレームパラメータを設定することで、新たに作成す
るフレームの見た目を制御できます。初期フレームだけに影響するパラメータを
指定するには、変数`initial-frame-alist'を使います。詳しくは、*Note 初期
フレームのパラメータ: (elisp)Initial Parameters。

すべてのEmacsフレームに主要フォントを指定するもっとも簡単な方法は、Xのリ
ソース（*Note Font X::）を使うことですが、つぎに示すように、`font'パラメー
タを指定するように`default-frame-alist'を変更してもできます。

     (add-to-list 'default-frame-alist '(font . "10x20"))



File: emacs-ja.info, Node: Speedbar, Next: Creating Frames, Prev: Mode Line Mouse, Up: Frames

スピードバーフレームの作成と使い方
==================================

Emacsのフレームは、"スピードバー"を持つことができます。スピードバーは、
縦長のウィンドウで、訪問したりタグを探したりするためのスクロール可能なファ
イルメニューとして働きます。スピードバーを作るには、`M-x speedbar'と打ち
ます。これは、選択されたフレームに対するスピードバーウィンドウを作ります。
そうすると、スピードバーのファイル名をクリックすると、対応するEmacsフレー
ムでそのファイルを訪問できます。あるいは、タグの名前をクリックすると、
Emacsフレームでそのタグの箇所へ飛んで行きます。

最初、スピードバーには、カレントディレクトリの直下の内容を1行につき1つの
ファイルで表示します。各行には、`[+]'か`<+>'の箱があって、それを
`Mouse-2'でクリックするとその項目の内容を『開け』ます。その行の名前がディ
レクトリならば、それを開くと、そのディレクトリの内容をその行の下に追加し
てスピードバーに表示します。その行が普通のファイルならば、それを開くと、
そのファイル内のタグ一覧をスピードバーに追加して表示します。ファイルが開
かれていると、`[+]'は`[-]'に変わります。ファイルを『閉じる』（内容を隠す）
ためにその箱をクリックできます。

rmailモード、infoモード、GUDモードを含むいくつかのメジャーモードには、選
択可能な有用な項目をスピードバーに追加する特別な方法があります。たとえば、
rmailモードでは、スピードバーにはrmailファイル一覧を表示します。カレント
メッセージを別のrmailファイルに移すには、目的のrmailファイルの`<M>'の箱
をクリックするだけです。

スピードバーは1つのEmacsフレームに属し、つねにそのフレームに作用します。
複数のフレームを使うときには、一部のフレームやすべてのフレームにスピード
バーを作れます。フレームのスピードバーを作るには、そのフレームで`M-x
speedbar'と打ちます。



File: emacs-ja.info, Node: Multiple Displays, Next: Special Buffer Frames, Prev: Creating Frames, Up: Frames

複数ディスプレイ
================

1つのEmacsは、複数のXディスプレイと通信できます。最初は、Emacsは1つのディ
スプレイだけを使います。環境変数`DISPLAY'や`--display'オプションに指定さ
れたものです（*Note Initial Options::）。他のディスプレイに接続するには、
コマンド`make-frame-on-display'を使います。

`M-x make-frame-on-display RET DISPLAY RET'
     ディスプレイDISPLAY上に新しいフレームを作成する。

1つのXサーバーは複数のスクリーンを扱えます。1つのサーバーに属する2つのス
クリーンにフレームを開くとき、Emacsは1つのキーボードを共有していることを
知っていて、これらのスクリーンから到着するすべてのコマンドを1つの入力ス
トリームとして扱います。

異なるXサーバー上にフレームを開くとき、Emacsはそれぞれのサーバーに対して
別々の入力ストリームを作ります。こうすることで、2つのディスプレイ上で2人
のユーザーが同時に打鍵でき、Emacsはそれらの入力をごっちゃにすることはあ
りません。各サーバーにはそれ自身が選択しているフレームがあります。特定の
Xサーバーで入力したコマンドは、そのサーバーが選択しているフレームに適用
されます。

これらの機能にも関わらず、異なるディスプレイで同じEmacsジョブを使ってい
る人達は、注意を怠ると、互いに干渉し合ってしまいます。たとえば、誰かが
`C-x C-c'と打つと、その人達が共有している（1つの）Emacsジョブは終了して
しまいます！



File: emacs-ja.info, Node: Special Buffer Frames, Next: Frame Parameters, Prev: Multiple Displays, Up: Frames

特別なバッファフレーム
======================

ウィンドウが1つのときにはEmacsが普通2つめのウィンドウを作るような特定の
バッファでは、それ専用の特別なフレームに表示することができます。こうする
には、変数`special-display-buffer-names'にバッファ名のリストを設定します。
そのリストに名前があるどのバッファも、Emacsコマンドが『別のウィンドウに』
表示したいときには、特別なフレームを自動的に取得します。

たとえば、つぎのように変数を設定したとすると、補完一覧、`grep'の出力、
TeXモードのシェルバッファは、それぞれ個別のフレームを取得します。

     (setq special-display-buffer-names
           '("*Completions*" "*grep*" "*tex-shell*"))

これらのフレームとその中のウィンドウは、別のバッファのために自動的に分割
されたり再利用されることはありません。手動で変更するまで、そのために作成
されたバッファを表示し続けます。特別なバッファを消去すると、そのフレーム
も自動的に削除されます。

より一般的には、正規表現のリストを`special-display-regexps'に設定できま
す。すると、バッファの名前がそれらの正規表現に一致すると、バッファは専用
のフレームを取得します。（繰り返すが、これは通常、別のウィンドウに表示す
るバッファにのみ適用する。）

変数`special-display-frame-alist'は、このようなフレームに対するフレーム
パラメータを指定します。これにはデフォルト値があるので、特に設定する必要
はありません。

Lispがわかる人のためにですが、`special-display-buffer-names'や
`special-display-regexps'の要素は、リストでもかまいません。その場合、最
初の要素はバッファ名か正規表現です。リストの残りは、フレームの作成方法を
指定します。これは、フレームパラメータの値を指定する連想リストにすること
もできます。これらの値は、`special-display-frame-alist'に指定されたパラ
メータの値より優先されます。あるいは、リストはつぎのような形式にすること
もできます。

     (FUNCTION ARGS...)

ここで、FUNCTIONはシンボルです。こうすると、FUNCTIONを呼んでフレームを作
ります。関数呼び出しの最初の引数はバッファで、残りの引数はARGSです。

似たような機能で、バッファをどの選択されているウィンドウに表示するか指定
できます。*Note Force Same Window::。同じウィンドウに表示する機能は、特
別なフレームに表示する機能に優ります。したがって、バッファ名を
`special-display-buffer-names'に追加しても何の効果もなかったら、その機能
が同じバッファ名に対しても使われていないか調べてください。



File: emacs-ja.info, Node: Frame Parameters, Next: Scroll Bars, Prev: Special Buffer Frames, Up: Frames

フレームパラメータの設定
========================

本節では、選択しているフレームの表示スタイルやウィンドウ管理のふるまいを
変更するコマンドを説明します。

`M-x set-foreground-color RET COLOR RET'
     選択しているフレームの前景色をCOLORと指定する。

`M-x set-background-color RET COLOR RET'
     選択しているフレームの背景色をCOLORと指定する。これは`modeline'フェ
     イスの前景色も変更するので、デフォルトと比較しても反転表示のままに
     なる。

`M-x set-cursor-color RET COLOR RET'
     選択しているフレームのカーソルの表示色をCOLORと指定する。

`M-x set-mouse-color RET COLOR RET'
     マウスカーソルが選択しているフレーム内にあるときのマウスカーソルの
     表示色をCOLORと指定する。

`M-x set-border-color RET COLOR RET'
     選択しているフレームの境界色をCOLORと指定する。

`M-x list-colors-display'
     定義されている表示色の名称とそれがどう見えるか表示する。このコマン
     ドは少し遅い。

`M-x auto-raise-mode'
     選択されているフレームをオートレイズするべきかどうか切り替える。オー
     トレイズとは、マウスカーソルがフレームに入るたびに、そのフレームを
     手前にもってくること。

     このオートレイズ機能はEmacs自身が実装していることに注意。ウィンドウ
     マネージャの中にも、オートレイズを実装しているものがある。Xのウィン
     ドウマネージャでEmacsフレームのオートレイズを指定しているときには、
     それが動作するはず。しかし、それはEmacsの制御を超えているので、それ
     に関しては`auto-raise-mode'は何の影響もない。

`M-x auto-lower-mode'
     選択されているフレームをオートローワするべきかどうか切り替える。オー
     トローワとは、マウスカーソルがフレームから出るたびに、そのフレーム
     をXのウィンドウスタックの底に移すこと。

     コマンド`auto-lower-mode'は、Xのウィンドウマネージャが実装するオー
     トローワには何の影響もない。それを制御するには、適切なウィンドウマ
     ネージャの機能を使う必要がある。

`M-x set-frame-font RET FONT RET'
     選択されたフレームに対する主要フォントとしてFONTを指定する。フェイ
     ス（*Note Faces::）が別のフォントを使うことを指定しているときを除い
     て、主要フォントは、フレームに表示するすべてのテキストに対して使わ
     れる。あなたのシステムで使えるフォント一覧を表示する方法については、
     *Note Font X::。

     ポップアップメニューから、フレームの主要フォントを設定することもで
     きる。このメニューを立ち上げるには`S-Mouse-1'を押す。

Xツールキットを使うEmacsの版では、表示色とフォントを設定する関数はメニュー
やメニューバーには影響しません。というのは、メニューやメニューバーは、そ
れら自身のウィジェットクラスを使って表示されているからです。メニューとメ
ニューバーの見た目を変更するには、Xのリソースを使う必要があります（*Note
Resources X::）。表示色に関しては、*Note Colors X::。フォントの選択につ
いては、*Note Font X::。

フレームパラメータとそのカスタマイズについては、*Note フレームパラメータ:
(elisp)Frame Parameters。



File: emacs-ja.info, Node: Scroll Bars, Next: Menu Bars, Prev: Frame Parameters, Up: Frames

スクロールバー
==============

Xを使っているときには、Emacsは通常、各Emacsウィンドウの左側に"スクロール
バー"（scroll bar）を作ります。スクロールバーは、ウィンドウの高さに延び
ていて、内側に動く矩形の箱を表示します。この箱は、現在表示されているバッ
ファ内の部分を表しています。スクロールバーの全体の高さは、バッファの全体
の長さを表します。

`Mouse-2'（通常、中ボタン）を使って、スクロールバーの内側の箱を上下に移
動したりドラッグできます。内側の箱をスクロールバーのいちばん上へ移動する
と、バッファの先頭を見ることができます。スクロールバーのいちばん下に内側
の箱を移動すると、バッファの末尾が見えます。

スクロールバーで左や右ボタンを使うと、制御された増分でスクロールできます。
`Mouse-1'（通常、左ボタン）は、クリックした場所の高さの行をウィンドウの
最上端の行へ移動します。`Mouse-3'（通常、右ボタン）は、ウィンドウの最上
端の行をクリックした場所の高さの行へ移動します。同じ位置で繰り返しクリッ
クすると、同じ分量のスクロールを繰り返します。

スクロール以外では、スクロールバーで`C-Mouse-2'をクリックすると、ウィン
ドウを上下に分割できます。クリックした場所の行で分割されます。

コマンド`M-x scroll-bar-mode'で、スクロールバー（scroll-bar）モードをオ
ン／オフできます。引数を指定しなければ、スクロールバーの使用をトグルしま
す。引数を指定した場合、引数が正のときだけスクロールバーを使うようにしま
す。このコマンドは、これから作成されるフレームを含めてすべてのフレームに
作用します。Xのリソース`verticalScrollBars'を使って、スクロールバー
（scroll-bar）モードの初期設定を制御できます。*Note Resources X::。

選択されているフレームに対してのみスクロールバーをオン／オフするには、
`M-x toggle-scroll-bar'コマンドを使います。



File: emacs-ja.info, Node: Menu Bars, Next: Faces, Prev: Scroll Bars, Up: Frames

メニューバー
============

`M-x menu-bar-mode'でメニューバーの表示をオン／オフできます。引数を指定
しないと、このコマンドはマイナモードであるメニューバー（menu-bar）モード
をトグルします。引数を指定した場合、引数が正ならメニューバー（menu-bar）
モードをオンにし、引数が正でないならオフにします。Xのリソース
`menuBarLines'を使って、メニューバー（menu-bar）モードの初期設定を制御で
きます。*Note Resources X::。熟練したユーザーは、メニューバーをしばしば
オフにし、特に文字端末上ではそうします。というのは、テキスト表示に1行余
分に使えるからです。

メニューバーでコマンドを起動する方法については、*Note Menu Bar::。



File: emacs-ja.info, Node: Faces, Next: Font Lock, Prev: Menu Bars, Up: Frames

複数タイプフェイスの利用
========================

XでEmacsを使っているとき、文字表示に複数のスタイルを設定できます。制御で
きるスタイルは、フォントの種類、前景色、背景色、下線を引くかどうかです。
MS-DOS用Emacsは、各フェイスの前景色と背景色を制御して、フェイスの一部だ
けを扱えます（*Note MS-DOS::）。

表示スタイルを制御する方法は、名前付き"フェイス"を定義することです。各フェ
イスでは、フォントの種類、前景色、背景色、下線フラグを指定できます。しか
し、これらすべてを指定する必要はありません。バッファ内のテキストの一部分
に対して使用するフェイスを指定することで、そのテキストの見た目を制御でき
ます。

テキスト中のある文字に対して使う表示スタイルは、いくつかのフェイスを組み
合わせて決定されます。重ね合わせやテキスト属性で指定されていない表示スタ
イルは、フレームそのものから得ます。

整形済みテキストを編集するモードであるエンリッチ（enriched）モードには、
フェイスを指定するためのコマンドやメニューがあります。バッファ内のテキス
トに対するフォントの指定方法については、*Note Format Faces::。前景色と背
景色の指定方法については、*Note Format Colors::。

フェイスの見た目を変更するには、カスタマイズバッファを使います*Note Face
Customization::。Xのリソースを使って、特定のフェイスの属性を指定できます
（*Note Resources X::）。

現在定義されているフェイスとその見た目を調べるには、`M-x
list-faces-display'と打ちます。あるフェイスを違うフレームでは違って見え
るようにできます。このコマンドは、コマンドを打ったフレーム上での見た目を
表示します。つぎは、標準的に定義されているフェイス一覧です。

`default'
     このフェイスは、他のフェイスを指定していない普通のテキストに使われ
     る。
`modeline'
     このフェイスはモード行に対して使われる。デフォルトでは、`default'フェ
     イスの反転表示を設定。*Note Display Vars::。
`highlight'
     このフェイスは、さまざまモードでのテキストの強調表示部分に対して使
     われる。
`region'
     このフェイスは、選択されているリージョン（暫定マーク
     （transient-mark）モードがオンのとき。下記参照）の表示に使われる。
`secondary-selection'
     このフェイスは、二次セレクションの表示に使われる（*Note Secondary
     Selection::）。
`bold'
     このフェイスは、ボールド体（太字体）があるならば、ボールド体を用い
     たデフォルトフォントの変種。
`italic'
     このフェイスは、イタリック体（斜体）があるならば、イタリック体を用
     いたデフォルトフォントの変種。
`bold-italic'
     このフェイスは、ボールドイタリック体（太字斜体）があるならば、ボー
     ルドイタリック体を用いたデフォルトフォントの変種。
`underline'
     このフェイスは、テキストに下線を引く。

暫定マーク（transient-mark）モードがオンのときは、マークが活性ならば、リー
ジョンのテキストは強調表示されます。これには`region'という名前のフェイス
を使います。このフェイスのスタイルを変更することで、強調表示のスタイルを
制御できます（*Note Face Customization::）。暫定マーク（transient-mark）
とマークの活性／不活性について詳しくは、*Note Transient Mark::。

フェイスを使う簡単な方法の1つは、フォントロック（font-lock）モードを使う
ことです。特定のバッファにつねにローカルであるこのマイナモードは、編集す
るテキストの構文に従ってフェイスを選択します。このモードは、ほとんどの言
語のコメントと文字列を認識できます。いくつかの言語では、それ以外のさまざ
まな重要な構造も認識して、適切に強調表示します。フォントロック
（font-lock）モードと構文の強調表示について詳しくは、*Note Font Lock::。

画面上で強調表示されたバッファは、コマンド`ps-print-buffer-with-faces'を
使って印刷できます。*Note Postscript::。



File: emacs-ja.info, Node: Font Lock, Next: Support Modes, Prev: Faces, Up: Frames

フォントロックモード
====================

フォントロック（font-lock）モードはマイナモードです。特定のバッファにつ
ねにローカルであり、編集しているテキストの構文に従ってさまざまなフェイス
を使って強調表示（または『フォント表示化』）します。このモードは、ほとん
どの言語のコメントや文字列を認識できます。いくつかの言語では、他のさまざ
まな重要な構成要素も認識し、正しく強調表示します。 たとえば、定義されて
いる関数名や予約語です。

コマンド`M-x font-lock-mode'は、引数に従ってフォントロック（font-lock）
モードをオン／オフし、引数がなければモードをトグルします。関数
`turn-on-font-lock'は、フォントロック（font-lock）モードを無条件でオンに
します。このコマンドは、モードフック関数で使うと便利です。たとえば、Cの
ファイルを編集しているときにはいつでもフォントロック（font-lock）モード
をオンにするには、つぎのようにします。

     (add-hook 'c-mode-hook 'turn-on-font-lock)

フォントロック（font-lock）モードを扱えるすべての（メジャー）モードで自
動的にフォントロック（font-lock）モードをオンにするには、関数
`global-font-lock-mode'をつぎのように使います。

     (global-font-lock-mode 1)

フォントロック（font-lock）モードでは、テキストを編集していると、自動的
に変更した行の強調表示を更新します。ほとんどの変更は、後続行の強調表示に
は影響しませんが、時折、影響することもあります。ある範囲の行を強調表示し
直すには、コマンド`M-g M-g'を使います（`font-lock-fontify-block'）。

ある種のメジャーモードでは、`M-g M-g'は、現在の関数定義全体をフォント表
示化し直します。（変数`font-lock-mark-block-function'は、現在の関数定義
の探し方を制御する。）別のメジャーモードでは、 `M-g M-g'は、ポイントのま
えとあとの16行をフォント表示化し直します。

数引数Nを指定すると、`M-g M-g'は、モードに関係なく、 ポイントのまえとあ
とのN行をフォント表示化し直します。

フォントロック（font-lock）モードの利点を十分に活用するには、ボールド体、
イタリック体、ボールドイタリック体のデフォルトフォントを選ぶ必要がありま
す。あるいは、カラーやグレースケールの画面が必要です。

変数`font-lock-maximum-decoration'は、複数のレベルを提供するモードでのフォ
ント表示化の好ましいレベルを指定します。レベル1は最低限のフォント表示化
です。いくつかのモードでは、もっとも高い3のレベルまであります。通常デフォ
ルトは『可能な限り大きい数』です。すべてのモードに適用する整数を指定でき
ます。あるいは、特定のメジャーモードに対して異なる数を指定できます。たと
えば、C/C++モードではレベル1を、それ以外ではデフォルトのレベルを指定する
には、つぎのようにします。

     (setq font-lock-maximum-decoration
           '((c-mode . 1) (c++-mode . 1)))

フォント表示化は、大きなバッファに対してはとても遅くなりえますから、抑制
することもできます。変数`font-lock-maximum-size'にバッファサイズを指定す
ると、その値を越えるバッファについてはフォント表示化を抑制します。

コメントと文字列のフォント表示化（あるいは、『構文の』フォント表示化）は、
バッファのテキストの構文解析に頼っています。
速度向上のために、CモードやLispモードを含むいくつかのモードでは、
特別な習慣に頼っています。
最左桁にある開き括弧は、つねに関数定義の開始を表し、
そのため、つねに文字列やコメントの外側だということです。
（*Note Defuns::。）
この習慣に従わないと、フォントロック（font-lock）モードは、
文字列やコメントの内側にある最左桁の開き括弧のうしろでは、
違ったフォント表示化をすることもありえます。

変数`font-lock-beginning-of-syntax-function' （つねにバッファにローカル）
は、フォントロック（font-lock）モードが、コメントや文字列の外側であるこ
とが保証される位置をどのように探すかを指定します。最左桁の括弧の習慣を使
うモードでは、変数のデフォルト値は、`beginning-of-defun'です。 つまり、
フォントロック（font-lock）モードは習慣を使うようにということです。この
変数に`nil'を設定すると、フォントロック（font-lock）モードは、もはや習慣
に頼りません。これでまちがった結果を避けられますが、その代償は、変更した
テキストをフォント表示化するには、バッファのテキストをバッファの先頭から
再走査する必要がある場合もあります。

多くのモードに対するフォントロックの強調表示パターンはすでにありますが、
フォント表示化するパターンを追加したいこともあるでしょう。関数
`font-lock-add-keywords'を使って、特定のモードに対する個人用の強調表示パ
ターンを追加できます。たとえば、Cのコメントで単語`FIXME:'を強調表示する
には、つぎのように使います。

     (font-lock-add-keywords
      'c-mode
      '(("\\<\\(FIXME\\):" 1 font-lock-warning-face t)))



File: emacs-ja.info, Node: Support Modes, Next: Highlight Changes, Prev: Font Lock, Up: Frames

フォントロックのモード
======================

フォントロックには、大きなバッファに対してフォントロック（font-lock）モー
ドを高速に動作させるモードがあります。高速ロック（fast-lock）モードと遅
延ロック（lazy-lock）モードです。これらは、フォントロック（font-lock）モー
ドの速度を向上するために2つの異なる方法を使います。

* Menu:

* Fast Lock Mode::      Saving font information in files.
* Lazy Lock Mode::      Fontifying only text that is actually displayed.
* Fast or Lazy::        Which support mode is best for you?



File: emacs-ja.info, Node: Fast Lock Mode, Next: Lazy Lock Mode, Up: Support Modes

高速ロックモード
----------------

大きなファイルを訪問したバッファに対してフォントロック（font-lock）モー
ドを速くするには、高速ロック（fast-lock）モードを使えます。高速ロック
（fast-lock）モードは、各ファイルに対するフォント情報を別のキャッシュファ
イル（cache file）に保存します。ファイルを訪問するたびに、最初からテキス
トをフォント表示化し直すかわりに、キャッシュファイルからフォント情報を読
み直します。

コマンド`M-x fast-lock-mode'は、引数に従って高速ロック（fast-lock）モー
ドをオン／オフします（引数がないければトグル）。フォントロック
（font-lock）モードを使うときに、いつでも高速ロック（fast-lock）モードを
オンにするには、つぎのようにします。

     (setq font-lock-support-mode 'fast-lock-mode)

小さなバッファに対しては、キャッシュファイルを書く価値がありません。それ
ゆえ、変数`fast-lock-minimum-size'は、フォント情報をキャッシュする最小の
ファイルサイズを指定します。

変数`fast-lock-cache-directories'は、
キャッシュファイルをどこに置くかを指定します。
その値は、ディレクトリ群のリストです。
`"."'は、編集しているファイルと同じディレクトリを表します。
デフォルト値は、`("." "~/.emacs-flc")'で、
可能ならば同じディレクトリを使い、
さもなければディレクトリ`~/.emacs-flc'を使うという意味です。 

変数`fast-lock-save-others'は、あなたが所持していないファイルに対するキャッ
シュファイルを高速ロック（fast-lock）モードが保存すべきかどうかを指定し
ます。値が`nil'以外ならば保存します（これがデフォルト）。



File: emacs-ja.info, Node: Lazy Lock Mode, Next: Fast or Lazy, Prev: Fast Lock Mode, Up: Support Modes

遅延ロックモード
----------------

大きなバッファに対してフォントロック（font-lock）モードを速くするには、
フォント表示化するテキストの量を減らす遅延ロック（lazy-lock）モードを使
えます。遅延ロック（lazy-lock）モードでは、バッファのフォント表示化は要
求駆動型です。表示されようとしているバッファの部分だけをフォント表示化し
ます。また、変更部分のフォント表示化は延期され、Emacsがある短い時間アイ
ドルであったときにのみフォント表示化します。

コマンド`M-x lazy-lock-mode'は、遅延ロック（lazy-lock）モードを引数に従っ
てオン／オフします（引数がなければトグル）。フォントロック（font-lock）
モードを使うときに、いつでも遅延ロック（lazy-lock）モードをオンにするに
は、つぎのようにします。

     (setq font-lock-support-mode 'lazy-lock-mode)

小さなバッファに対してバッファのフォント表示化を避ける価値はありません。
ですから、変数`lazy-lock-minimum-size'は、要求駆動型でバッファのフォント
表示化を行う最小のバッファサイズを指定します。これより小さなバッファは、
普通のフォントロック（font-lock）モードのように一度にフォント表示化しま
す。

バッファを変更したとき、遅延ロック（lazy-lock）モードは変更したテキスト
のフォント表示化を延期します。変数`lazy-lock-defer-time'は、変更部分のフォ
ント表示化を始めるまでにEmacsがアイドルであるべき秒数です。この値が0なら
は、普通のフォントロック（font-lock）モードと同じように、変更はすぐにフォ
ント表示化されます。

遅延ロック（lazy-lock）モードは、通常、新たに見えてくるバッファ部分が初
めて表示されるまえにその部分をフォント表示化します。しかし、
`lazy-lock-defer-on-scrolling'の値が`nil'以外ならば、新たに見えてくるテ
キストは、Emacsが`lazy-lock-defer-time'秒だけアイドルしたときにのみフォ
ント表示化されます。

CやEmacs Lispモードを含むいくつかのモードでは、ある1行の内容を変更すると
後続行の文脈が変わり、そのため、後続行をどうフォント表示化するかも変わり
ます。通常は、後続行を再フォント表示化するために`M-g M-g'を打つ必要があ
ります。しかし、変数`lazy-lock-defer-contextually'に`nil'以外を設定して
いると、遅延ロック（lazy-lock）モードでは、`lazy-lock-defer-time'秒後に
これを自動的に行います。

Emacsが長時間アイドルだと、遅延ロックは、バッファのまだ表示されていない
部分を、のちの表示に備えてフォント表示化します。これを"内密のフォント表
示化"（stealth fontification）と呼びます。

変数`lazy-lock-stealth-time'は、内密のフォント表示化を開始するまでに、
Emacsが何秒間アイドルであるべきかを指定します。値が`nil'だと、内密のフォ
ント表示化をしません。変数`lazy-lock-stealth-lines'と
`lazy-lock-stealth-verbose'は、内密のフォント表示化の粒度と冗長性を指定
します。



File: emacs-ja.info, Node: Fast or Lazy, Prev: Lazy Lock Mode, Up: Support Modes

高速ロックか遅延ロックか？
--------------------------

フォントロックで使えるモードの1つを選択する目安となる簡単な指針をあげま
す。

   * 高速ロック（fast-lock）モードは、ファイルの訪問とバッファの削除（と
     関連する事象）の最中に作業する。それゆえ、バッファの編集やウィンド
     ウのスクロールは、普通のフォントロック（font-lock）モードより速くも
     遅くもない。

   * 高速ロック（fast-lock）モードのキャッシュファイルの読み込みは、遅延
     ロック（lazy-lock）モードがウィンドウをフォント表示化するより遅い。
     よって、高速ロック（fast-lock）モードは、遅延ロック（lazy-lock）モー
     ドよりファイルの訪問が遅い。

   * 遅延ロック（lazy-lock）モードは、ウィンドウをスクロールする最中に、
     画面上に現れるテキストをフォント表示化する。よって、スクロールは、
     通常のフォントロック（font-lock）モードより遅い。

   * 遅延ロック（lazy-lock）モードは、バッファを編集中はフォント表示化し
     ない（変更部分のフォント表示化を延期する）。よって、編集は、通常の
     フォントロック（font-lock）モードより速い。

   * 高速ロック（fast-lock）モードは、版管理の下に置かれたファイルではだ
     まされることがある。よって、そのファイルに対するキャッシュファイル
     が存在していても、バッファのフォント表示化が起こりえる。

   * 高速ロック（fast-lock）モードは、ファイルを訪問しているバッファでの
     み動作する。遅延ロック（lazy-lock）モードは、どのバッファでも動作す
     る。

   * 高速ロック（fast-lock）モードは、キャッシュファイルを生成する。遅延
     ロック（lazy-lock）モードは、生成しない。

変数`font-lock-support-mode'は、これらのどちらのモードを使うかを指定しま
す。たとえば、C/C++モードでは高速ロック（fast-lock）モードを使い、それ以
外のモードでは遅延ロック（lazy-lock）モードを使うように指定するには、変
数をつぎのように設定します。

     (setq font-lock-support-mode
           '((c-mode . fast-lock-mode) (c++-mode . fast-lock-mode)
             (t . lazy-lock-mode)))



File: emacs-ja.info, Node: Highlight Changes, Next: Misc X, Prev: Support Modes, Up: Frames

変更部分強調表示モード
======================

バッファ内の最近に変更された部分を示すためにフェイス（典型的には表示色）
を用いるマイナモードをオンにするには、`M-x highlight-changes-mode'を使い
ます。



File: emacs-ja.info, Node: Misc X, Next: Non-Window Terminals, Prev: Highlight Changes, Up: Frames

その他のXウィンドウシステムでの機能
===================================

つぎのコマンドは、フレームを作成したり削除したり操作したりします。

`C-z'
     選択されているEmacsフレームをアイコン化する
     （`iconify-or-deiconify-frame'）。Emacsを休止するという`C-z'の通常
     の意味は、ウィンドウシステムでは有用ではない。そのため、別のバイン
     ドになっている。

     Emacsフレームのアイコンでこのコマンドを打つと、アイコンをフレームに
     開く。

`C-x 5 0'
     選択されているフレームを削除する（`delete-frame'）。フレームがたっ
     た1つの場合には、このコマンドは許されない。

`C-x 5 o'
     別のフレームを選択し、それをいちばん手前にもってきて、そのフレーム
     が選択されるようにマウスを飛び込ませる。このコマンドを繰り返すと、
     端末上のすべてのフレームを巡回する。



File: emacs-ja.info, Node: Non-Window Terminals, Prev: Misc X, Up: Frames

非ウィンドウ端末
================

Emacsが扱えるウィンドウシステムを使えない端末では、一度に1つのフレームし
か表示できません。しかし、複数のEmacsフレームを作って、それらのフレーム
間を切り替えられます。このような端末でのフレームの切り替えは、異なるウィ
ンドウ構成の端末での切り替えとたいへんよく似ています。

新しいフレームを作りそれに切り替えるには、`C-x 5 2'を使います。既存のフ
レーム間を巡回するには、`C-x 5 o'を使います。カレントフレームを削除する
には、`C-x 5 0'を使います。

各フレームにはそれを区別する番号があります。一度には1つのフレームだけし
か表示できない端末では、選択されているフレームの番号Nが、モード行の先頭
近くに`FN'という形式で現れます。

`FN'は、実際にはフレームの名前です。望むなら別の名前を指定でき、その名前
でフレームを選択できます。選択されたフレームに新しい名前を指定するには、
コマンド`M-x set-frame-name RET NAME RET'を使います。その名前でフレーム
を選択するには、`M-x select-frame-by-name RET NAME RET'を使います。指定
した名前は、フレームを選択するとモード行に表示されます。



File: emacs-ja.info, Node: International, Next: Major Modes, Prev: Frames, Up: Top

国際化文字集合の使い方
**********************

Emacsでは広範囲の国際化文字集合を使えます。ラテンアルファベットの変種で
あるヨーロッパの言語はもちろん、中国語、デバナーガリー（ヒンディー語とマ
ラッタ語）、エチオピア語、ギリシア語、IPA（International Phonetic
Alphabet、万国表音文字）、日本語、韓国語、ラオ語、ロシア語、タイ語、チベッ
ト語、ベトナム語の文字を含んでいます。これらの機能は、MULE
（『MULti-lingual Enhancement to GNU Emacs』）として知られるEmacsの修正
版から併合しました。

* Menu:

* International Intro::     Basic concepts of multibyte characters.
* Enabling Multibyte::      Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Multibyte Conversion::    How single-byte characters convert to multibyte.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Various ways to choose which conversion to use.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Single-Byte European Support::
                            You can pick one European character set
                            to use without multibyte characters.



File: emacs-ja.info, Node: International Intro, Next: Enabling Multibyte, Up: International

国際化文字集合の紹介
====================

これらの文字のユーザーは、ファイルに格納するために、たくさんの標準的なコー
ディングシステムを確立してきました。Emacsは内部的には単一のマルチバイト
文字符号化を使用しているので、1つのバッファや1つの文字列の中に、これらの
すべての文字を混ぜ合わせることができます。この符号化では、非ASCII文字を
0200から0377の範囲のバイトの並びとして表現します。Emacsは、ファイルを読
み書きするとき、サブプロセスとデータを交換するとき、（場合によっては）
`C-q'コマンドを使うときに、マルチバイト文字符号化と他のさまざまなコーディ
ングシステムのあいだで変換します（*Note Multibyte Conversion::）。

コマンド`C-h h'（`view-hello-file'）は、多くの言語で『hello』と書いたファ
イル`etc/HELLO'を表示します。これは、さまざまな字体を例示します。

これらの文字集合を使っている国々であっても、一般にキーボードには、それら
すべての文字に対するキーはありません。ですから、Emacsではさまざまな"入力
方式"（input methods） (1) (*Note International Intro-Footnotes::)を使っ
て、便利に文字を打ち込めるようにします。典型的には、1つの字体や1つの言語
について1つの入力方式があります。

プレフィックスキー`C-x RET'は、マルチバイト文字、コーディングシステム、
入力方式に関係するコマンドに使います。


File: emacs-ja.info  Node: International Intro-Footnotes, Up: International Intro

(1) 【訳注】GNU Emacsをインストールする時点で、対応する版のLEIM（Library
of Emacs Input Method）のソースをGNU Emacsのソースディレクトリに展開して
おくと、自動的にインストールされる。



File: emacs-ja.info, Node: Enabling Multibyte, Next: Language Environments, Prev: International Intro, Up: International

マルチバイト文字を使用可能にする
================================

Emacs全体やバッファごとにマルチバイト文字の使用可／使用不可を設定できま
す。バッファでマルチバイト文字を使用不可にすると、そのバッファ内の各バイ
トは1つの文字を表します。たとえコードが0200から0377のあいだであってもそ
うです。ヨーロッパの文字集合であるISO Latin-1とISO Latin-2を扱う古い機能
は、Emacs 19で動作していたように動き、他のISO 8859文字集合に対しても動作
します。

しかし、ISO Latinを使うために、マルチバイト文字を使用不可にする必要はあ
りません。Emacsのマルチバイト文字集合にはこれらの文字集合のすべての文字
が含まれ、EmacsはこれらのISOコードと相互に自動的に変換できます。

特定のファイルをユニバイト表現で編集するには、`find-file-literally'を使っ
てファイルを訪問します。*Note Visiting::。マルチバイト表現のバッファを同
じ文字の1バイト表現に変換するには、もっとも簡単な方法は、内容をファイル
に保存してから、バッファを削除し、`find-file-literally'でそのファイルを
訪問し直します。`C-x RET c'（`universal-coding-system-argument'）を使っ
て、ファイルを探したり保存するときのコーディングシステムとして`raw-text'
を指定することもできます。*Note Specify Coding::。`raw-text'としてファイ
ルを探しても、`find-file-literally'のようには、書式変換、圧縮の展開、モー
ドの自動選択を禁止しません。

デフォルトでマルチバイト文字を使用不可にするには、`--unibyte'オプション
（*Note Initial Options::）を指定してEmacsを始めるか、あるいは、環境変数
`EMACS_UNIBYTE'を設定します。`--unibyte'と同等な効果を得るには、
`enable-multibyte-characters'をカスタマイズするか、これと等価に、初期化
ファイル内で、変数`default-enable-multibyte-characters'を直接設定します。

環境変数の値、`/etc/passwd'の内容などの非ASCII 8ビット文字からの初期化中
にはマルチバイト文字列は作られません。しかし、`--unibyte'を指定したとし
ても、一般のLispファイルのように、初期化ファイルは、通常、マルチバイトと
して読み込みます。それらに含まれる非ASCII文字からマルチバイト文字列が生
成されるのを防ぐには、1行目の注釈に`-*-unibyte: t;-*-'を入れておきます。
gnusなどのパッケージの初期化ファイルでも同じことをします。

モード行には、カレントバッファでマルチバイト文字が使用可かどうか表示され
ます。使用可ならば、モード行の先頭付近のコロンのまえに2文字か数文字（ほ
とんどの場合ダッシュ2個）があります。マルチバイト文字が使用不可ならば、
コロンのまえにはダッシュが1個だけです。



File: emacs-ja.info, Node: Language Environments, Next: Input Methods, Prev: Enabling Multibyte, Up: International

言語環境
========

マルチバイト文字が使用可のときはいつでも、すべての扱える文字集合をEmacs
バッファの中で使えます。ある言語の文字を表示するために、Emacsバッファで
その言語を選択する必要はありません。しかし、さまざまなデフォルトを設定す
るために"言語環境"を選択しておくことは重要です。言語環境は、言語の選択と
いうより、（多かれ少なかれ）実際には好みの文字を表します。

言語環境は、テキストを読み込むときにどのコーディングシステムを認識するか
を制御します（*Note Recognize Coding::）。言語環境は、ファイル、到着メイ
ル、ニュース、Emacsへ読み込むその他のテキストに適用されます。言語環境は、
ファイルを作成したときに使うデフォルトのコーディングシステムを指定するこ
ともあります。各言語環境は、デフォルトの入力方式も指定します。

言語環境を選択するには、コマンド`M-x set-language-environment'を使います。
このコマンドを使ったときにどのバッファがカレントバッファであるかは関係あ
りません。というのは、その効力は、そのEmacsセッションに全体に適用される
からです。以下の言語環境を使えます。

     Chinese-BIG5、Chinese-CNS、Chinese-GB、Cyrillic-Alternativnyj、
     Cyrillic-ISO、Cyrillic-KOI8、Devanagari、English、Ethiopic、Greek、
     Hebrew、Japanese、Korean、Lao、Latin-1、Latin-2、Latin-3、Latin-4、
     Latin-5、Thai、Tibetan、Vietnamese。

いくつかのオペレーティングシステムでは、ローケル（locale）環境変数を設定
することで言語を指定できます。Emacsは、このよくある特別な場面を扱います。
文字種を表すローケル名が文字列`8859-N'を含むなら、Emacsは自動的に対応す
る言語環境を選択します。

ある言語環境LANG-ENVの効果についての情報を表示するには、コマンド`C-h L
LANG-ENV RET' （`describe-language-environment'）を使います。このコマン
ドは、その言語環境がどの言語に役立つのか、その言語で使われる文字集合、コー
ディングシステム、入力方式の一覧を表示します。また、その言語環境で使われ
る文字を例示する例文も表示します。デフォルトでは、このコマンドは選択され
ている言語環境を記述します。

どの言語環境もノーマルフック`set-language-environment-hook'でカスタマイ
ズできます。コマンド`set-language-environment'は、新しい言語環境を設定し
たあとでこのフックを実行します。フック関数では、変数
`current-language-environment'を検査すれば、言語環境を知ることができます。

`set-language-environment'は、新しい言語環境を設定し始めるまえに、まずフッ
ク`exit-language-environment-hook'を実行します。このフックは、（直前の言
語環境を設定した）`set-language-environment'で施したカスタマイズをもとに
戻すのに便利です。たとえば、`set-language-environment-hook'を使って設定
した特定の言語環境で特別なキーバインディングを定義したときには、それをそ
のキーのもとのバインディングに戻すために`exit-language-environment-hook'
を設定するべきです。



File: emacs-ja.info, Node: Input Methods, Next: Select Input Method, Prev: Language Environments, Up: International

入力方式
========

"入力方式"（input method）は、対話的に入力するために特別に設計された文字
変換の一種です。Emacsでは、典型的には、各言語向けに専用の入力方式があり
ます。ときには、同じ文字を使ういくつかの言語で入力方式を共有します。複数
の入力方式を使う言語も少しはあります。

入力方式のもっとも単純なものは、ASCII文字を別のアルファベットに対応させ
ることで動作します。ギリシア語とロシア語の入力方式はこのように動作します。

より強力な方法は合成で、文字の列を1つの文字に変換します。多くのヨーロッ
パの入力方式は、文字のうしろにアクセント文字が続く列（あるいはその逆順）
から、1つの非ASCII文字を生成する合成を使います。たとえば、いくつかの入力
方式では、文字の列`a''を1つのアクセント付き文字に変換します。これらの入
力方式には、その方式に固有の特別なコマンドはありません。印字文字の列を合
成するだけです。

音節文字用の入力方式では、典型的には、対応付けたあとで合成します。タイ語
と韓国語の入力方式は、この方法で動作します。まず、文字を音声記号に対応付
けます。そして、1つの音節全体を構成するそれらの列を1つの音節記号に対応付
けます。

中国語や日本語では、より複雑な方法が必要です。中国語の入力方式では、まず、
中国語の単語の発音表記を入力する（とりわけ入力方式`chinese-py'）か、1文
字の各部分部分の列（とりわけ入力方式`chinese-4corner'や`chinese-sw'）を
入力します。1つの発音表記は、普通、多くの異なる中国語の文字に対応してい
るので、特別なEmacsコマンドを使って候補群から1つを選ぶ必要があります。
`C-f'、`C-b'、`C-n'、`C-p'と数字キーは、この状況で候補を選ぶために使われ
る特別な定義になっています。TABは、すべての候補をバッファに表示します。

日本語の入力方式 (1) (*Note Input Methods-Footnotes::) では、まず、発音
表記を使って1つの単語全体を入力します。そして、単語がバッファに入ったあ
とで、Emacsは大きな辞書を使って1つ以上の文字へ変換します。1つの発音表記
は、たくさんの異なる日本語の単語に対応しているので、その中から選ぶ必要が
あります。候補を巡回するには、`C-n'や`C-p'を使います。

ときには、入力方式での処理を切り離したほうが便利なことがあります。そうす
れば、入力した文字は後続の入力文字と結合されません。たとえば、入力方式
`latin-1-postfix'では、キー列`e ''は結合されてアクセント付き`e'になりま
す。これらを別々の文字として入力したいときはどうするのでしょう？

1つの方法は、アクセントを2回打つことです。これは、アルファベットとアクセ
ントを別々に入力する特別な機能です。たとえば、`e ' ''は、2つの文字`e''に
なります。別の方法は、`e'のあとに結合されない別の文字を打ってから、すぐ
にそれを消すことです。たとえば、 `e'と`''を入力するには、`e e DEL''と打
ちます。

別の方法はより一般的ですが、打つのは簡単ではありません。2つの文字のあい
だで`C-\ C-\'を打って、結合を止めます。これは、コマンド`C-\' 
（`toggle-input-method'）を2回使っています。*Note Select Input Method::。

`C-\ C-\'は、インクリメンタルサーチの中では特に便利です。というのは、結
合する文字を待つことを止めて、すでに入力したものを探索し始めるからです。

 変数`input-method-highlight-flag'と`input-method-verbose-flag'は、入力
方式に何が進行中かをどのように表示させるかを制御します。
`input-method-highlight-flag'が`nil'以外ならば、バッファでは（入力途中の）
部分列を強調表示します。`input-method-verbose-flag'が`nil'以外ならば、
（ミニバッファの中でなければ）つぎに打鍵できる文字の一覧をエコー領域に表
示します。


File: emacs-ja.info  Node: Input Methods-Footnotes, Up: Input Methods

(1) 【訳注】言語環境が`Japanese'のときにデフォルトで使用されるLEIM
に含まれているもの。「ローマ字→ひらがな→漢字」と変換するが、あまい使い
やすくはない。WNN、かんな、SKKなどを使うには、Emacsの配布とは別の非公式
パッチを自前で当てる必要がある。ただし、これらを用いた場合、日本語を入力
できない場面もあることを承知しておく必要がある。



File: emacs-ja.info, Node: Select Input Method, Next: Multibyte Conversion, Prev: Input Methods, Up: International

入力方式の選択
==============

`C-\'
     選択されている入力方式をオン／オフする。

`C-x RET C-\ METHOD RET'
     カレントバッファに対して新しい入力方式を選択する。

`C-h I METHOD RET'
`C-h C-\ METHOD RET'
     入力方式METHODについて説明する（`describe-input-method'）。デフォル
     トでは、（あれば）現在の入力方式を説明する。この説明で、ある入力方
     式の使い方の詳細がわかるはず。

`M-x list-input-methods'
     使用可能なすべての入力方式の一覧を表示する。

カレントバッファに対する入力方式を選ぶには、`C-x RET C-\'
（`set-input-method'）を使います。このコマンドは、ミニバッファで入力方式
名を読みます。その名前は、通常、一緒に使うことを意図された言語環境で始ま
ります。変数`current-input-method'は、どの入力方式を選択したかを記録しま
す。
  
入力方式は、非ASCII文字を入力するために、さまざまなASCII文字の列を使いま
す。ときには、一時的に入力方式をオフにできると便利なこともあります。そう
するには、`C-\'（`toggle-input-method'）と打ちます。入力方式をふたたびオ
ンにするには、`C-\'をもう一度打ちます。

`C-\'を打ったときに、入力方式をまだ選択していないと、入力方式を指定する
ように聞いてきます。これは、入力方式を指定するために`C-x RET C-\'を使う
のと同じ効果があります。

言語環境を選択すると、さまざまなバッファで使うデフォルトの入力方式を指定
します。デフォルトの入力方式を指定してあれば、`C-\'と打てばカレントバッ
ファでそれを選択できます。変数`default-input-method'は、デフォルトの入力
方式を指定します（`nil'は入力方式なしの意味）。

アルファベット文字に対するいくつかの入力方式は、その文字向けに一般的に使
用されるさまざまなキーボード配列をエミュレートするようにキーボードを（実
質的に）マッピングし直すことで動作します。マッピングし直す方法は、あなた
の実際のキーボード配列に依存します。使っているキーボード配列を指定するに
は、コマンド`M-x quail-set-keyboard-layout'を使います。

使用可能なすべての入力方式の一覧を表示するには、`M-x list-input-methods'
と打ちます。この一覧には、モード行に表示される入力方式を表す文字列を含め
て、各入力方式についての情報が示されます。



File: emacs-ja.info, Node: Multibyte Conversion, Next: Coding Systems, Prev: Select Input Method, Up: International

ユニバイトとマルチバイトの非ASCII文字
=====================================

マルチバイト文字が使用可のときには、文字コード0240（8進数）から0377（8進
数）の文字は、実際にそのままではバッファ内に存在しません。正しい非ASCII
印字文字は、0400から始まるコードになります。

0240から0377の不正な範囲の自己挿入文字を打った場合、Emacsは、ISO Latin-N 
文字集合の1つを使おうとしていると仮定して、Latin-Nの文字を表すEmacsのコー
ドに変換します。言語環境の選択を介して、*どの*ISO Latin文字集合を使うの
か指定できます（*Note Language Environments::）。何も選んでないと、デフォ
ルトはLatin-1です。

`C-q'でこの範囲の8進コードを入力すると、同じことが起こります。



File: emacs-ja.info, Node: Coding Systems, Next: Recognize Coding, Prev: Multibyte Conversion, Up: International

コーディングシステム
====================

さまざまな言語を使うユーザーは、それらを表現するための標準的なコーディン
グシステムを数多く確立してきました。Emacsはこれらのコーディングシステム
を内部的には使用しません。そのかわり、データを読むときには、さまざまなコー
ディングシステムからEmacs独自のコーディングシステムに変換し、データを書
くときには、内部コーディングシステムから他のコーディングシステムに変換し
ます。ファイルの読み書き、端末とのやりとり、サブプロセスとのデータ交換に
おいて、変換できます。

Emacsは各コーディングシステムに名前を付けています。多くのコーディングシ
ステムは、1つの言語で使用されるので、コーディングシステムの名前は、言語
の名前で始まります。いくつかのコーディングシステムは、いくつもの言語で使
用されます。その場合、コーディングシステムの名前は、通常、`iso'で始まり
ます。印字文字をまったく変換しない特別なコーディングシステム、
`no-conversion'、`raw-text'、`emacs-mule'もあります。

非ASCII文字のさまざまな表現形の変換に加えて、コーディングシステムは行末
変換も行います。Emacsは、ファイル内の行の区切り方として、3つの異なる変換
を扱えます。つまり、改行、復帰改行、復帰です。

`C-h C CODING RET'
     コーディングシステムCODINGを説明する。

`C-h C RET'
     現在使用しているコーディングシステムを説明する。

`M-x list-coding-systems'
     使用可能なすべてのコーディングシステムの一覧を表示する。

コマンド`C-h C'（`describe-coding-system'）は、特定のコーディングシステ
ムについての情報を表示します。引数にコーディングシステム名を指定できます。
あるいは、引数が空のときには、カレントバッファに対するものとデフォルトの
両方について、さまざまな目的のために選択されている現在のコーディングシス
テムと、コーディングシステムを認識するための優先順位表を説明します。
（*Note Recognize Coding::）。

利用可能なすべてのコーディングシステムの一覧を表示するには、`M-x
list-coding-systems'と打ちます。モード行に表示される文字を含めて、各コー
ディングシステムについての情報の一覧を表示します（*Note Mode Line::）。

いかなる種類の変換も行わない`no-conversion'を除いて、この一覧に現れる各
コーディングシステムは印字文字をどのように変換する／しないを指定します。
しかし、行末変換は、各ファイルの内容に基づいて決定されます。たとえば、ファ
イルが行区切りに復帰改行を使用しているように思われるときには、その行末変
換を使います。

一覧の各コーディングシステムには、どのように行末変換するかを正確に指定す
る3つの変種があります。

`...-unix'
     行末変換を行わない。ファイルでは、行区切りに改行を使用していると仮
     定する。（これは、UNIXとGNUシステムで普通に使用される変換。）

`...-dos'
     ファイルでは、行区切りに復帰改行を使用していると仮定し、適当な変換
     を行う。（これは、Microsoftシステムで普通に使用される変換。 (1)
     (*Note Coding Systems-Footnotes::)）

`...-mac'
     ファイルでは、行区切りに復帰を使用していると仮定し、適当な変換を行
     う。（これは、Machintoshシステムで普通に使用される変換。）

これらのコーディングシステムの変種は、完全に予想できるので
`list-coding-systems'の表示からは簡潔にするために除かれています。たとえ
ば、コーディングシステム`iso-latin-1'には、`iso-latin-1-unix'、
`iso-latin-1-dos'、`iso-latin-1-mac' の変種があります。

コーディングシステム`raw-text'は、主にASCIIテキストのファイルに適してい
ますが、ファイルには、非ASCII文字の符号を意味しない127を越えるバイト値が
含まれるかもしれません。`raw-text'では、Emacsは、それらのバイトが適切に
解釈されるように値を変更しないでコピーし、カレントバッファの
`enable-multibyte-characters'に`nil'を設定します。`raw-text'は、出会った
データに基づく普通の方法で行末変換を処理し、使用する行末変換を指定する3
つの変種を持ちます。

対照的に、コーディングシステム`no-conversion'は、非ASCIIバイト値と行末に
対して、いかなる文字コード変換も指定しません。これは、バイナリファイル、
tarファイル、そのまま処理する必要があるその他のファイルを読み書きするの
に便利です。これも、`enable-multibyte-characters'に`nil'を設定します。

いかなる種類の変換もしないでファイルを編集するもっとも簡単な方法は、`M-x
find-file-literally'コマンドを使うことです。このコマンドは、
`no-conversion'を使い、あなたがファイルを見るまえにファイルの内容を変換
するかもしれないEmacsのその他の機能を抑制します。*Note Visiting::。

コーディングシステム`emacs-mule'は、Emacs内部の符号化のままで格納された
非ASCII文字を含むファイルであることを意味します。これは、出会ったデータ
に基づいて行末変換を扱い、行末変換の種類を指定する通常の3つの変種を持ち
ます。


File: emacs-ja.info  Node: Coding Systems-Footnotes, Up: Coding Systems

(1) MIMEの「text/*」の本体や、他のネットワーク転送の場面でも指定さ
れる。Emacsが直接には扱えないSGMLの参照構文である
record-start/record-end書式とは異なる。



File: emacs-ja.info, Node: Recognize Coding, Next: Specify Coding, Prev: Coding Systems, Up: International

コーディングシステムの認識
==========================

一度自分の好みを指定しておけば、ほとんどの場合、Emacsは、与えられたファ
イルに対してどのコーディングシステムを使うか認識できます。

いくつかのコーディングシステムは、データ内にどのようなバイト列が現れたか
で、認識したり区別できます。しかし、区別できないコーディングシステムやそ
の可能性もないコーディングシステムもあります。たとえば、Latin-1とLatin-2
を区別する方法はありません。これらは同じバイト値を異なる意味で使用してい
ます。

Emacsは、コーディングシステムの優先順位表を用いてこの事態を処理します。
使用するコーディングシステムを指定しなければ、Emacsはファイルを読むとき
はいつでも、優先順位のもっとも高いものから始めて順に下りながら、データに
合うコーディングシステムをみつけるまで各コーディングシステムに対してデー
タを検査します。そして、ファイルはそのコーディングシステムで表現されてい
ると仮定して、ファイルの内容を変換します。

コーディングシステムの優先順位表は、選択されている言語環境に依存します
（*Note Language Environments::）。たとえば、フランス語を使うのなら、た
ぶん、EmacsにはLatin-2よりLatin-1を選んでほしいでしょう。チェコ語を使う
なら、たぶん、Latin-2のほうがよいでしょう。これが、言語環境を指定する理
由の1つです。

しかし、コマンド`M-x prefer-coding-system'を使って、優先順位表の詳細を変
更できます。このコマンドはミニバッファからコーディングシステムの名前を読
み、それを優先順位表の先頭に追加して、他のすべてのものより優先するように
します。このコマンドを数回使うと、使用するごとに優先順位表の先頭に1つの
要素が追加されます。

`iso-8859-1-dos'のような行末変換を指定したコーディングシステムを使うと、
`iso-8859-1'を優先して認識し、その場合にはDOSの行末変換を使うことをEmacs
に指示することになります。

ときには、ファイルに対して使用するコーディングシステムをファイル名が示し
ていることがあります。変数`file-coding-system-alist'は、この対応関係を指
定します。このリストに要素を追加する特別な関数
`modify-coding-system-alist'があります。たとえば、すべての`.txt'の読み書
きに、コーディングシステム`china-iso-8bit'を使用したいなら、つぎのLisp式
を実行します。

     (modify-coding-system-alist 'file "\\.txt\\'" 'china-iso-8bit)

始めの引数は`file'、第2引数はこれを適用するファイルを決定する正規表現、
第3引数はこれらのファイルに対して使用するコーディングシステムです。

Emacsは、ファイルの内容に基づいて、使用する行末変換の種類を認識します。
復帰のみ、あるいは、復帰改行の列のみであれば、対応する行末変換を選択しま
す。変数`inhibit-eol-conversion'に`nil'以外を設定すると、行末変換の自動
的な使用を禁止できます。

ファイルの先頭の`-*-...-*-'や、ファイルの最後のローカル変数リストを使っ
て、個々のファイルに対してコーディングシステムを指定できます（*Note File
Variables::）。これを行うには、`coding'という名前の『変数』に値を定義し
ます。Emacsには、変数`coding'は実際にはありません。変数を設定するかわり
に、ファイルに対して指定されたコーディングシステムを使います。たとえば、
`-*-mode: C; coding: latin-1;-*-'は、Cモードを指定するとともに、Latin-1
のコーディングシステムの使用を指定します。ファイルでコーディングシステム
を明示的に指定した場合、それは`file-coding-system-alist'に優先します。

変数`auto-coding-alist'は、特定のパターンのファイル名に対してコーディン
グシステムを指定するもっとも強い方法です。この変数は、ファイル自身の
`-*-coding:-*-'にさえも優先します。Emacsはtarファイルやアーカイブファイ
ルに対してこの機能を使います。アーカイブ内のファイルの中にある
`-*-coding:-*-'で混乱して、ファイル全体にコーディングシステムを適用して
しまうことを防ぐのです。

Emacsがバッファに対するコーディングシステムを一度選択すると、そのコーディ
ングシステムを`buffer-file-coding-system'に入れておき、このバッファから
ファイルに書く操作では、デフォルトでこのコーディングシステムを使います。
これには、コマンド`save-buffer'や`write-region'も含まれます。異なるコー
ディングシステムを用いてこのバッファからファイルに書きたいときには、
`set-buffer-file-coding-system'を使って、そのバッファに対して異なるコー
ディングシステムを指定します（*Note Specify Coding::）。

メイル（mail）モード（*Note Sending Mail::）でメッセージを送るとき、
Emacsには、メッセージテキストの符号化に使うコーディングシステムを決定す
る異なる方法が4つあります。バッファの`buffer-file-coding-system'が`nil'
以外ならば、その値を試します。さもなければ、`sendmail-coding-system'の値
が`nil'以外ならば、その値を使います。3つめの方法は、新しいファイルに対す
るデフォルトのコーディングシステムが`nil'以外ならば、それを使います。こ
の値は、言語環境の選択で制御されます。これらの3つの値がすべて`nil'ならば、
Emacsは、Latin-1のコーディングシステムを使用して送出メイルを符号化します。

rmailで新しいメイルを受けとったとき、各メッセージが別々のファイルである
かのように、各メッセージは自動的にそのメイルが書かれたコーディングシステ
ムで変換されます。これには、指定したコーディングシステムの優先順位表を使
います。MIMEメッセージが文字集合を指定するときには、
`rmail-decode-mime-charset'が`nil'でない限り、rmailはその指定に従います。

rmailファイル自身を読んだり保存したりするときには、Emacsは、変数
`rmail-file-coding-system'で指定されたコーディングシステムを使います。そ
のデフォルト値は、`nil'です。rmailファイルは変換しないという意味です
（rmailファイルは、Emacsの内部文字コードで読み書きされる。）



File: emacs-ja.info, Node: Specify Coding, Next: Fontsets, Prev: Recognize Coding, Up: International

コーディングシステムの指定
==========================

Emacsが自動的に正しいコーディングシステムを選択しない場合には、コーディ
ングシステムを指定するつぎのコマンドを使用できます。

`C-x RET f CODING RET'
     カレントバッファに訪問したファイルにコーディングシステムCODINGを使
     う。

`C-x RET c CODING RET'
     このコマンドの直後に続くコマンドに対してコーディングシステムCODING
     を指定する。

`C-x RET k CODING RET'
     キーボード入力に対してコーディングシステムCODINGを使用する。

`C-x RET t CODING RET'
     端末出力に対してコーディングシステムCODINGを使用する。

`C-x RET p INPUT-CODING RET OUTPUT-CODING RET'
     カレントバッファでのサブプロセスの入力と出力にコーディングシステム
     INPUT-CODINGとOUTPUT-CODINGを使用する。

`C-x RET x CODING RET'
     ウィンドウシステムを介した他のプログラムとのセレクションの交換には、
     コーディングシステムCODINGを使用する。

`C-x RET X CODING RET'
     ウィンドウシステムで*1つ*のセレクションの交換には、コーディングシス
     テムCODINGを使用する。

コマンド`C-x RET f'（`set-buffer-file-coding-system'）はカレントバッファ
に対してファイルコーディングシステムを指定します。いいかえれば、訪問した
ファイルを保存したりふたたび読む込むときに使うコーディングシステムです。
コーディングシステムはミニバッファを使って指定します。このコマンドは、す
でに訪問したファイルに作用するので、ファイルを保存するときにしか影響しま
せん。

ファイルに対するコーディングシステムを指定する別の方法は、ファイルを訪問
するときです。まずコマンド`C-x RET c' 
（`universal-coding-system-argument'）を使います。このコマンドは、ミニバッ
ファを使ってコーディングシステム名を読みます。ミニバッファを出たあと、*
直後のコマンド*に対して指定したコーディングシステムが使用されます。

ですから、たとえば、その直後のコマンドが`C-x C-f'ならば、そのコーディン
グシステムを使ってファイルを読みます（そして、ファイルを保存するときのた
めにそのコーディングシステムを記録します）。 あるいは、その直後のコマン
ドが`C-x C-w'ならば、そのコーディングシステムを使ってファイルに書きます。
コーディングシステムを指定することで、影響される他のファイルコマンドは、
`C-x C-i'と`C-x C-v'、および、別のウィンドウを使う`C-x C-f'の変形です。

`C-x RET c'は、`M-x shell'（*Note Shell::）を含むサブプロセスを開始する
コマンドにも影響します。

しかしながら、その直後のコマンドがコーディングシステムを使用しないなら、
`C-x RET c'は最終的には何の効果もありません。

ファイルを変換しないで訪問するもっとも簡単な方法は、`M-x
find-file-literally'コマンドです。*Note Visiting::。

 変数`default-buffer-file-coding-system'は、新しいファイルを作成するとき
のコーディングシステムの選択を指定します。この変数は、新規作成のファイル
を訪問するとき、あるいは、バッファを作成してそれをファイルに保存するとき
に適用されます。言語環境を選択すると、典型的には、言語環境に対して最適の
デフォルトのコーディングシステムをこの変数に設定します。

コマンド`C-x RET t'（`set-terminal-coding-system'）は端末出力に対するコー
ディングシステムを指定します。端末出力のコーディングシステムを指定すると、
端末へのすべての文字出力はそのコーディングシステムに翻訳されます。

この機能は、特定の言語や文字集合向けに作られたある種の文字端末には便利で
す。たとえば、ISO Latin 文字集合の1つを扱えるヨーロッパの端末です。 マル
チバイトテキストを使っているときには、Emacsが端末で実際に扱える文字を知
るために、端末コーディングシステムを指定する必要があります。

Emacsがあなたの端末の正しいコーディングシステムを推測できない限り、デフォ
ルトでは、端末出力はまったく変換しません。

コマンド`C-x RET k'（`set-keyboard-coding-system'）はキーボード入力に対
するコーディングシステムを指定します。キーボードから入力した文字コードの
変換は、非ASCII図形文字を送出するキーを有する端末には便利です。たとえば、
いくつかの端末は、ISO Latin-1やその部分集合向けに設計されています。

デフォルトでは、キーボード入力はまったく変換しません。

コーディングシステムを使用してキーボード入力を変換することと、入力方式の
使用には似たところがあります。どちらも、1つの文字に変換するキーボード入
力列を定義しています。しかしながら、入力方式は人が対話的に使用するのに便
利なように設計されていて、変換される列は典型的にはASCII印字文字の列です。
コーディングシステムは、典型的には非図形文字の列を変換します。

コマンド`C-x RET x'（`set-selection-coding-system'）は、選択されたテキス
トをウィンドウシステムへ送るとき、および、他のアプリケーションで作られた
セレクションのテキストを受け取るときのコーディングシステムを指定します。
このコマンドは、再設定しない限り、以降のすべてのセレクションに作用します。
コマンド`C-x RET X'（`set-next-selection-coding-system'）は、Emacsが作る／
読むつぎのセレクションのコーディングシステムを指定します。

コマンド`C-x RET p'（`set-buffer-process-coding-system'）は、サブプロセ
スの入出力に対するコーディングシステムを指定します。このコマンドはカレン
トバッファに作用します。通常、各サブプロセスはそれ自身のバッファを持ちま
す。ですから、各サブプロセスの入出力の変換を指定するには、対応するバッファ
でこのコマンドを使用します。

デフォルトでは、プロセスの入出力はまったく変換しません。

変数`file-name-coding-system'は、ファイル名を符号化するためのコーディン
グシステムを指定します。この変数に（Lispシンボルや文字列で）コーディング
システム名を設定すると、Emacsは、すべてのファイル操作に対してそのコーディ
ングシステムを使ってファイル名を符号化します。これは、ファイル名に非
ASCII文字を使うことを可能にしています。あるいは、少なくとも、指定したコー
ディングシステムで符号化できる非ASCII文字を使えるはずです。

`file-name-coding-system'が`nil'ならば、Emacsは、選択されている言語環境
で決まるデフォルトのコーディングシステムを使います。デフォルトの言語環境
では、ファイル名の中の非ASCII文字は特別に符号化しません。Emacsの内部表現
でファイルシステム上に現れます。

*警告：*` 'Emacsセッションの途中で`file-name-coding-system' （や言語環境）
を変更すると、問題となる場合があります。つまり、それまでのコーディングシ
ステムで符号化された名前のファイルをすでに訪問していて、新しいコーディン
グシステムではその名前を符号化できない（あるいは異なって符号化される）と
きです。そのようなバッファを訪問先ファイル名で保存しようとすると、まちがっ
た名前のファイルに保存されるか、エラーになります。そのような問題が発生し
た場合には、 `C-x C-w'を使って、そのバッファに新しいファイル名を指定しま
す。



File: emacs-ja.info, Node: Fontsets, Next: Defining Fontsets, Prev: Specify Coding, Up: International

フォントセット
==============

Xウィンドウシステムのフォントは、典型的には、1つのアルファベットや文字集
合の形を定義しています。したがって、Emacsが扱える文字の範囲全体を表示す
るには、たくさんのフォントを集めたものが必要です。Emacsでは、そういった
フォントを集めたものを"フォントセット"（fontset）と呼びます。フォントセッ
トは、ある文字コード範囲を扱うフォントのリストで定義されます。

各フォントセットには、フォントと同様に名前があります。使用可能なXのフォ
ントは、Xサーバーが定義します。しかし、フォントセットはEmacsの中で定義さ
れます。いったんフォントセットを定義すれば、フォントを使える場面ではどこ
でも、その名前を指定してEmacs内のフォントセットを使用できます。もちろん、
Emacsのフォントセットでは、Xサーバーで使えるフォントだけを使えます。ある
文字が画面で中抜きの箱で表示されたなら、その文字に使用したフォントセット
には、その文字に対するフォントがないことを意味します。

Emacsは、"標準フォントセット"と"スタートアップフォントセット"の2つのフォ
ントセットを自動的に作ります。標準フォントセットは、非ASCII文字向けの広
い範囲のフォントをもっとも持ちそうなものです。しかし、これは、Emacsが使
うデフォルトではありません。（デフォルトでは、Emacsはボールドとイタリッ
クの変種のフォントをみつけようとする。）オプション`-fn'やXのリソース
`Font'（*Note Font X::）で使用する標準フォントセットを指定できます。たと
えば、つぎのようにします。

     emacs -fn fontset-standard

フォントセットが、すべての文字コードに対するフォントを指定する必要はあり
ません。フォントセットが、ある文字に対してフォントを指定していない、ある
いは、システムに存在しないフォントを指定している場合には、その文字を正し
く表示できません。そのかわりに、中抜きの箱を表示します。

フォントセットの高さと幅は、ASCII文字で決定されます（つまり、そのフォン
トセット内でASCII文字用に使われるフォント）。フォントセットのあるフォン
トが異なる高さや幅を持つ場合には、そのフォントを割り当てられた文字は、フォ
ントセットの大きさに切り詰められます。`highlight-wrong-size-font'が`nil'
以外ならば、これらのまちがった大きさの文字は箱で囲まれて表示されます。



File: emacs-ja.info, Node: Defining Fontsets, Next: Single-Byte European Support, Prev: Fontsets, Up: International

フォントセットの定義方法
========================

Emacsは`standard-fontset-spec'の値に従って、自動的に標準フォントセットを
作ります。フォントセットの名前はつぎのとおりです。

     -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

または、省略して`fontset-standard'です。

標準フォントセットのボールド、イタリック、ボールドイタリックの変種も自動
的に作られます。それらの名前は、`medium'のかわりに`bold'、`r'のかわりに
`i'、あるいは、両方ともそのようになります。

リソース`Font'やオプション`-fn'で、デフォルトのASCIIフォントを指定すると、
Emacsはそれから自動的にフォントセットを生成します。これが、"スタートアッ
プフォントセット"で、その名前は`fontset-startup'です。これは、フォント名
のフィールド、FOUNDRY、FAMILY、ADD_STYLE、AVERAGE_WIDTHを`*'で、
CHARSET_REGISTRYを`fontset'で、CHARSET_ENCODINGを`startup'で置き換えて得
られた文字列をフォントセットの指定に使用します。

たとえば、Emacsをつぎのように起動します。

     emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"

Emacsがつぎのフォントセットを生成して、Xウィンドウの初期フレームに使いま
す。

     -*-*-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

Xのリソース`Emacs.Font'で、フォントセット名を実際のフォント名のように指
定できます。しかし、`Emacs*Font'のようなワイルドカードを使ったリソースに
フォントセット名を指定しないように注意してください。ワイルドカードを使っ
た指定は、フォントセットを扱えないメニューのような、他のさまざまな目的に
も適用されます。

`Fontset-N'という名前のXのリソースを使って追加フォントセットを指定できま
す。ただし、Nは0から始まる整数です。リソースの値はつぎのような形式でなけ
ればなりません。

     FONTPATTERN, [CHARSETNAME:FONTNAME]...

FONTPATTERNは、最後の2つのフィールドを除いて、標準のXフォント名の形式で
なければなりません。最後の2つのフィールドは、`fontset-ALIAS'の形式を持つ
べきです。

フォントセットには2つの名前、長い名前と短い名前があります。長い名前は
FONTPATTERNです。短い名前は`fontset-ALIAS'です。どちらの名前でもフォント
セットを参照できます。

`CHARSET:FONT'という構成は、ある文字集合に対して（このフォントセットでは）
どのフォントを使用するかを指定します。ここでCHARSETは、文字集合の名前で、
FONTはその文字集合に使用するフォントです。1つのフォントセットの定義の中
では、この構成を何度でも使用できます。

他の文字集合に対しては、EmacsはFONTPATTERNに基づいて選択します。これには、
文字集合を記述する値で`fontset-ALIAS'を置き換えます。ASCII文字フォントに
対しては、`fontset-ALIAS'を`ISO8859-1'で置き換えます

これに加えて、いくつか連続したフィールドがワイルドカードであるなら、
Emacsはそれらを1つのワイルドカードにまとめます。これは、自動的に拡大縮小
したフォントの使用を避けるためです。大きめのフォントを縮小したフォントは
編集には使えません。また、小さめのフォントを拡大したフォントも便利ではあ
りません。というのは、Emacsがそうするように、もともと小さなフォントを使
うほうがよいからです。

したがって、FONTPATTERNがつぎのようであると、

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCII文字に対するフォント指定はつぎのようになります。

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

また、Chinese GB2312文字に対するフォント指定はつぎのようになります。

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

上のフォント指定に一致する中国語フォントがないかもしれません。多くのXの
配布には、FAMILYフィールドが`song ti'か`fangsong ti'の中国語フォントだけ
が含まれています。そういった場合、`Fontset-N'をつぎのように指定します。

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

そうすると、Chinese GB2312の文字を除くフォント指定ではFAMILYフィールドが
`fixed'となり、Chinese GB2312の文字に対するフォント指定ではFAMILYフィー
ルドが`*'となります。

フォントセットのリソース値を処理してフォントセットを作る関数は、
`create-fontset-from-fontset-spec'です。フォントセットを作るために、この
関数を明示的に呼ぶこともできます。

Xにおけるフォントの命名法について詳しくは、*Note Font X::。



File: emacs-ja.info, Node: Single-Byte European Support, Prev: Defining Fontsets, Up: International

1バイトヨーロッパ文字の使い方
=============================

ISO 8859 Latin-N文字集合は、さまざまなヨーロッパの言語で必要とされるアク
セント文字と句読点記号を扱うために、160から250の範囲の文字コードを定義し
ています。マルチバイト文字を使用不可にしても、Emacsは、一度にはこれらの
文字コードの*1つ*を扱えます。これらのコードの*どれ*を使うかを指定するに
は、`M-x set-language-environment'を起動して、`Latin-N'のような適切な言
語環境を指定します。

ユニバイト操作についてより詳しくは、*Note Enabling Multibyte::を参照して
ください。非ASCII文字を含んだ初期化ファイルをユニバイトで読むことを保証
したいときには特に注意してください。

端末や使っているフォントでこれらの文字を扱えるならば、Emacsはこれらの文
字を表示できます。これは自動的に行われます。あるいは、ウィンドウシステム
を使っている場合には、現在の言語環境に従ってそれらに対応するマルチバイト
文字を表示することで、Emacsはフォントセットを介して1バイト文字を表示でき
ます。これを行うには、変数`unibyte-display-via-language-environment'に
`nil'以外の値を設定します。

もし、端末でLatin-1文字集合を表示できなければ、Emacsは、これらの文字をそ
の文字が少なくとも何であるかを明確に理解できるようなASCII列として表示で
きます。これを行うには、ライブラリ`iso-ascii'をロードします。他のLatin-N
文字集合に対しても似たようなライブラリを実装できますが、まだ行っていませ
ん。

（文字128から159の）非ISO 8859文字は、通常、8進表示されます。ライブラリ
`disp-table'の関数`standard-display-8bit'を使えば、この表示を非標準の
「拡張」版のISO 8859文字集合に変更できます。

1バイト非ASCII文字を入力する異なる方法が3つあります。

   * キーボードが、非ASCII文字を表現する128以上の文字コードを生成できる
     ならば、Emacsがそれらを理解できるようにつぎの式を実行する。

          (set-input-mode (car (current-input-mode))
                          (nth 1 (current-input-mode))
                          0)

   * 選択した言語環境の入力方式を使う。*Note Input Methods::。ユニバイト
     のバッファで入力方式を使うと、入力した非ASCII文字は、ユニバイトに変
     換される。

   * Latin-1に対してだけだが、非ASCIIのLatin-1の印字文字の入力の『合成文
     字』プレフィックスとして`C-x 8'を使える。`C-x 8'は、（ミニバッファ
     や他のバッファでの）挿入、探索、キー列が許される他の文脈などで使え
     る。

     ライブラリ`iso-transl'をロードすることで`C-x 8'は動作する。ライブラ
     リをロードしておくと、ALT修飾キーがあるならば、`C-x 8'と同じ目的で
     使用できる。後続の文字を修飾するには、アクセント文字と一緒にALTを使
     う。さらに、Latin-1の『専用アクセント文字』キーがあると、
     `iso-transl'をロード後は、それらのキーも後続の文字を合成するように
     定義される。


