Info file: m4-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `m4-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.




START-INFO-DIR-ENTRY
* m4-ja: (m4-ja).		A powerful macro processor.
END-INFO-DIR-ENTRY

This file documents the GNU `m4' utility.

Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994 Free Software
Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Foundation.




File: m4-ja.info, Node: Top, Next: Preliminaries, Prev: (dir), Up: (dir)

GNU `m4'
********

GNU `m4'はUNIXに古くからあるマクロプロセッサの実装です。SVR4版とほぼ互換
性がありますが、いくつかの機能が拡張がされています(たとえば、9個を超える
位置パラメータをマクロで扱うことができます)。`m4'にはマクロの展開機能に
加え、ファイルのインクルード、シェルコマンドの実行、計算、その他のための
関数も組み込まれています。Autoconfで`configure'スクリプトを生成するには
GNU `m4'が必要ですが、スクリプトを実行するときには必要ありません。

Ren'e SeindalがGNU `m4'を最初に書きました。続いて、 Franc,ois Pinardやそ
の他のインターネット上のボランティアたちが変更を行ないました。これらの人
たちの氏名と電子メールアドレスは、GNU `m4'の配布用アーカイブファイルに含
まれている`THANKS'ファイルにすべて記載されています。

本GNU `m4'はリリース 1.4です。現在すでに安定していることを考えると、今後
のリリースではバグの修正や速度の向上、ドキュメントの改善だけをするべきで
しょう。しかし...

`m4'の実用性をさらに増す思われる、試験的なある機能(*Note Changeword::) 
を使うと、`m4'において何が"単語"（word）として認識されるかを決めている規
則を変更できるようになります。この機能を試してみたい人は、./configure
--enable-changeword としてコンパイル時にこの機能が組み込まれるようにして
ください。現在の実装では`m4'の動作がかなり遅くなってしまうので、これをそ
のまま採用するには抵抗があります。したがって将来この機能が削除されるとい
うことも考えられるので、まだこの機能に依存した使い方はしないでください。


* Menu:

* Preliminaries::               序論
* Syntax::                      字句・構文解析の規則

* Macros::                      マクロを呼び出す方法
* Definitions::                 新たにマクロを定義する方法
* Conditionals::                条件分岐、ループ、再帰

* Debugging::                   マクロや入力をデバッグする方法

* Input Control::               入力制御
* File Inclusion::              ファイルのインクルード
* Diversions::                  出力の切替え（divert）と逆切替え（undivert）

* Text handling::               テキスト操作用の組み込みマクロ
* Arithmetic::                  計算用の組み込みマクロ
* UNIX commands::               UNIXコマンド実行用の組み込みマクロ
* Miscellaneous::               その他の組み込みマクロ
* Frozen files::                凍結状態（frozen state）の高速ロード

* Compatibility::               他の版のm4との互換性
* Concept index::               さまざまな概念の索引
* Macro index::                 m4マクロすべての索引

 -- The Detailed Node Listing ---

序論

* Intro::                       `m4'序説
* History::                     `m4'の由来

* Invoking m4::                 `m4'の起動(オプション一覧)
* Bugs::                        問題やバグへの対処方法
* Manual::                      このマニュアルの読み方

字句・構文解析の規則

* Names::                       入力トークン: マクロ名
* Quoted strings::              入力トークン: クォートされた文字列
* Other tokens::                入力トークン: その他
* Comments::                    m4への入力中のコメント

マクロを呼び出す方法

* Invocation::                  マクロの呼び出し
* Inhibiting Invocation::       マクロの呼び出しを抑制する
* Macro Arguments::             マクロの引数
* Quoting Arguments::           マクロの引数をクォートする
* Macro expansion::             マクロの展開

新たにマクロを定義する方法

* Define::                      新しいマクロを定義する
* Arguments::                   マクロの引数
* Pseudo Arguments::            マクロの疑似引数
* Undefine::                    マクロの削除
* Defn::                        マクロ名の変更
* Pushdef::                     マクロの一時的な再定義

* Indir::                       マクロの間接的な呼び出し
* Builtin::                     組み込みマクロの間接的な呼び出し

条件分岐、ループ、再帰

* Ifdef::                       マクロが定義済みかを判定する
* Ifelse::                      If-else 構文と多重分岐
* Loops::                       m4におけるループと再帰

マクロや入力をデバッグする方法

* Dumpdef::                     マクロの定義を表示する
* Trace::                       マクロの呼び出しをトレースする
* Debug Levels::                デバッグ出力の制御
* Debug Output::                デバッグ出力の保存

入力制御

* Dnl::                         空白（whitespace）を入力から削除する
* Changequote::                 引用符（quote characters）の変更
* Changecom::                   コメントデリミタ（comment delimiters）の変更
* Changeword::                  単語（word）の字句構造を変更する
* M4wrap::                      入力の一部を入力が終るまで保存（save）しておく

ファイルのインクルード

* Include::                     名前を指定してファイルをインクルードする
* Search Path::                 インクルードするファイルのサーチ

出力の切替え（divert）と逆切替え（undivert）

* Divert::                      出力を切替える（divert）
* Undivert::                    出力を逆切替えする（undivert）
* Divnum::                      出力切替え先番号（diversion number）
* Cleardiv::                    出力切替え先のテキストを破棄する

テキスト操作用の組み込みマクロ

* Len::                         文字列の長さを計算する
* Index::                       部分文字列で検索する
* Regexp::                      正規表現で検索する
* Substr::                      部分文字列を抽出する
* Translit::                    文字の置換
* Patsubst::                    正規表現でテキストの置換をする
* Format::                      文字列を(printf風に)フォーマットする

計算用の組み込みマクロ

* Incr::                        インクリメント演算子とデクリメント演算子
* Eval::                        整数式を計算する

UNIXコマンド実行用の組み込みマクロ

* Syscmd::                      単一のコマンドを実行する
* Esyscmd::                     コマンドの出力を読む
* Sysval::                      終了コード
* Maketemp::                    一時ファイル用の名前を生成する

その他の組み込みマクロ

* Errprint::                    エラーメッセージを表示する
* M4exit::                      m4を終了させる

他の版の`m4'との互換性

* Extensions::                  GNU m4で拡張された機能
* Incompatibilities::           System V m4にあってGNU m4にない機能
* Other Incompat::              その他の非互換性




File: m4-ja.info, Node: Preliminaries, Next: Syntax, Prev: Top, Up: Top

序論
****

この章ではGNU `m4'とは何か、その由来、このマニュアルの読み方と使い方、
`m4'を起動する方法、バグを報告する方法などを説明します。マニュアルの続き
を読むにあたっての助言をもってこの章は終ります。

ここから後の章では`m4'言語のすべての機能を詳しく説明します。

* Menu:

* Intro::                       `m4'序説
* History::                     `m4'の由来
* Invoking m4::                 `m4'の起動(オプション一覧)
* Bugs::                        問題やバグへの対処方法
* Manual::                      このマニュアルの読み方



File: m4-ja.info, Node: Intro, Next: History, Prev: Preliminaries, Up: Preliminaries

`m4'序説
========

マクロを展開しながら入力を出力へコピーするという意味で、`m4'はマクロプロ
セッサだと言えます。マクロには`m4'に最初から組み込まれている組み込み
（builtin）マクロと、ユーザが自分で定義するユーザ定義（user-defined）マ
クロの2種類があります。マクロは何個でも引数を取ることができます。`m4'に
は単なるマクロの展開機能に加え、ファイルのインクルード、UNIXコマンドの実
行、整数演算、さまざまな方法でのテキスト操作、再帰、その他のための関数が
そろっています。`m4'はコンパイラのフロントエンドとして、またマクロプロセッ
サそのものとしても使うことができます。

`m4'マクロプロセッサは、ほとんどすべてのUNIXで利用することができます。通
常その存在に気づいているのは、ほんのわずかな人たちだけです。しかし実際に
気づいた人たちは往々にして熱心なユーザとなります。GNU Autoconfで
`configure'スクリプトを*生成*するにはGNU `m4'が必要なため、GNU Autoconf
の人気が高まったのがきっかけとなってGNU `m4'をインストールする人が増えま
した。もっとも、そういう人が自分で`m4'のプログラミングをすることは無いで
しょう。GNU `m4'はわずかな違いを除けばSystem V, Release 3 版とほぼ互換性
があります。詳細は*Note Compatibility::を参照してください。

ユーザの中には`m4'中毒になってしまった人たちもいます。そういう人たちは最
初は簡単なことに`m4'を使い、徐々に複雑な`m4'マクロの書き方を習得しながら、
大きなこと大きなことへと挑戦していくのです。いちど病みつきになってしまえ
ば、簡単な問題を解くためにさえ洗練された`m4'アプリケーションを書こうとし
て、実際の仕事よりも自分の`m4'スクリプトのデバッグに多くの時間をさくこと
になるのです。熱中しやすいプログラマーは`m4'で健康を損なうおそれがあるの
で注意しましょう。



File: m4-ja.info, Node: History, Next: Invoking m4, Prev: Intro, Up: Preliminaries

`m4'の由来
==========

ここに記されている歴史に関する覚え書きはきわめて不完全なものであり、なん
ら権威あるものでもありません。事情に通じている方は、どうかこの節をふさわ
しいものにするのを手伝ってください。

`GPM'は`m4'の重要な祖先です。C. Stratchey: "A General Purpose Macro
generator", Computer Journal 8,3 (1965), pp. 225 ff を参照してください。
`GPM'は、David Gries classic "Compiler Construction for Digital
Computers"でも簡潔に説明されています。

`GPM'は*純粋*だったのに対して、`m4'は実生活にまつわる本物の複雑さを扱う
ことを意図したものでした。そのため、たとえばマクロは前もって宣言しなくて
も認識されるようになり、改行文字などの空白（whitespace）をスキップするの
は簡単になり、多くの構成要素が借り物ではなく内蔵されるようになりました。

もともと`m4'はRational FORTRANプリプロセッサすなわち`ratfor'(`cpp'に相当)
のエンジンでした。



File: m4-ja.info, Node: Invoking m4, Next: Bugs, Prev: History, Up: Preliminaries

`m4'の起動(オプション一覧)
==========================

`m4'コマンドの形式は次のようになります。

     `m4' [OPTION...] [MACRO-DEFINITIONS...] [INPUT-FILE...]

オプションは、短いオプション名を使うときは`-'で始め、長いオプション名を
使うときは`--'で始めます。長いオプション名は、そのオプションだと明確に特
定できる先頭部分を書くだけで十分です。`m4'は次のオプションを受けつけます。

`--version'
     プログラムのバージョン番号を標準出力に出力し、INPUT-FILESはいっさい
     読まずに、ただちに`m4'の実行を終了します。

`--help'
     ヘルプ情報の要約を標準出力へ出力し、INPUT-FILESはいっさい読まずに、
     ただちに`m4'の実行を終了します。

`-G'
`--traditional'
     System V版と比べて、この実装で拡張された機能をすべて抑制します。こ
     れらの一覧は*Note Compatibility::を参照してください。

`-E'
`--fatal-warnings'
     すべての警告(warning)を致命的なものと見なし、最初の警告が発行された
     時点で`m4'の実行を停止し終了します。

`-dFLAGS'
`--debug=FLAGS'
     デバッグ・レベルをFLAGSに設定します。デバッグ・レベルはデバッグ用関
     数が表示する情報の形式と量の制御に使われます。FLAGSの形式と意味につ
     いての詳細は*Note Debug Levels::を参照してください。

`-lNUM'
`--arglength=NUM'
     マクロをトレースすることによって生じる出力の量を制限します。詳細は
     *Note Debug Levels::を参照してください。

`-oFILE'
`--error-output=FILE'
     デバッグやトレースの出力を名前が指定されたファイルへリダイレクト
     （redirect）します。エラーメッセージは通常どおり標準エラー出力へ出
     力します。詳細は*Note Debug Output::を参照してください。

`-IDIR'
`--include=DIR'
     インクルード指定されたファイルが現在の作業ディレクトリ（the current
     working directory）で見つからない場合に、`m4'がDIRを探すようにしま
     す。詳細は*Note Search Path::を参照してください。

`-e'
`--interactive'
     起動時に`m4'を対話的な状態（interactive）にします。これは、すべての
     出力をバッファリング無しで行ない、割り込み（interrupt）を無視すると
     いうことを意味します。

`-s'
`--synclines'
     Cプリプロセッサやそれに類するツールで使うための同期情報を含む行を生
     成します。これは`m4'をコンパイラのフロントエンドとして使うときなど
     に便利です。ソースファイル名と行番号の情報は、`#line LINENUM
     "FILENAME"'という形式の指令（directive）によって表され、出力の途中
     へ必要に応じて挿入されます。この指令（directive）は次の行が入力ファ
     イルFILENAMEの第LINENUM行そのものであるか、もしくはその行の展開によ
     るものであることを意味します。`"FILENAME"'の部分は、ファイル名が前
     の指令（directive）と変わらない場合はしばしば省かれます。

     このような同期指令は、必ずそれ自身で完全な一行に対してのみ与えられ
     ます。ある出力行の途中に同期情報の食い違いがあるときは、対応する同
     期指令の出力は次の行へと持ち越されます。

`-P'
`--prefix-builtins'
     `m4'の内部に登録されている*すべて*の組み込みマクロの名前を接頭辞
     `m4_'が付いたものに変更します。このオプションを使ったときには、たと
     えば`define'の代わりに`m4_define'、`__file__'の代わりに
     `m4___file__'と書かなければなりません。

`-WREGEXP'
`--word-regexp=REGEXP'
     マクロ名の字句構成規則を指定します。このオプションは試験的なもので
     あり、このオプションを含まないGNU `m4'の実装も存在する可能性があり
     ます。(*Note Changeword::)

`-HN'
`--hashsize=N'
     シンボルを表引きするための内部ハッシュテーブルの項目数をNにします。
     この数は素数にするべきです。デフォルトは509項目です。極端に多くのマ
     クロを定義しないかぎり、この値を増やす必要は無いはずです。

`-LN'
`--nesting-limit=N'
     入れ子になったマクロの呼び出しをN段階に制限し、この制限を超えたとき
     は、プログラムの実行を停止します。指定がない状態では、入れ子は250段
     階に制限されています。

     このオプションの正確な効力は、動的な再帰構造というよりは、テキスト
     上での入れ子構造に対して発揮されるものだと理解したほうがより正しい
     でしょう。このオプションは、機械的な方法で`m4'への複雑な入力を生成
     したときに役に立ったという例もありますが、大部分のユーザにとっては
     無用の長物でしょう。目障りだということになったときは、このオプショ
     ンは(まだ試験段階です)削除されてしまうかも知れません。

     このオプションを使っても、再走査(rescanning)による無限ループを抜け出す
     ことは*できません*。その一方で、再走査ループは必ずしもメモリや
     スタック領域を大量に消費するわけではありません。
     再走査ループをうまく使えば、複雑で時間のかかる処理を`m4'に
     やらせることができます。
     この領域に制限をもうけるのは、`m4'の能力を弱めてしまうことになるでしょう。
     異常な使い方の例はいくらでもあります。
     `define(`a', `a')a'はもっとも単純なものの例です
     (しかし*Note Compatibility::)。
     GNU `m4'がこのようなケースを検出するのを期待するのは、
     コンパイラシステムが無限ループを検出し、診断メッセージをだすのを
     期待することに似ています。つまり、決定不能ではないとしても、
     一般にとても*ハード*な問題です。

`-Q'
`--quiet'
`--silent'
     マクロの呼び出しで、引数が不足していたり余分にあるときの警告を抑制
     します。

`-B'
`-S'
`-T'
     これらのオプションはSystem V版`m4'との互換性のために存在しますが、
     この実装では何の効果もありません。

`-NN'
`--diversions=N'
     これらのオプションはGNU `m4'の以前のバージョンとの互換性のためだけ
     に存在し、同時に使うことができる出力切替え先（diversion）の数を制御
     するために使われていました。現在は固定された制限値がなくなったので、
     何の働きもしません。


`-D'や`-U'オプションを使うと、コマンドライン上でマクロを定義したり削除し
たりすることができます。これらは次の形式をとります。

`-DNAME'
`-DNAME=VALUE'
`--define=NAME'
`--define=NAME=VALUE'
     どの入力ファイルを読むよりも前に、NAMEをシンボルテーブルに登録しま
     す。`=VALUE'が省略されたときは、値は空文字列として解釈します。VALUE
     はどんな文字列でもよく、したがって、マクロは入力内で定義するときと
     同じように引数を取るものとして定義することもできます。

`-UNAME'
`--undefine=NAME'
     NAMEのすでに定義された意味を削除します。当然、この方法で削除できる
     のは定義済みのマクロだけです。

`-tNAME'
`--trace=NAME'
     NAMEを未定義として、しかしトレースが行われるように、シンボルテーブ
     ルへ登録します。その結果、このマクロは定義された時点からトレースさ
     れるようになります。

`-FFILE'
`--freeze-state FILE'
     実行が終了すると、凍結状態（frozen state）の内容を指定されたFILE
     (*Note Frozen files::)へ書き出します。

`-RFILE'
`--reload-state FILE'
     実行の前に、指定された凍結ファイルFILE (*Note Frozen files::)から内
     部状態を復元します。


コマンドライン上の残りの引数は、入力ファイルの名前として解釈します。ファ
イル名の指定がないときは、標準入力から読み込みます。ファイル名`-'は、標
準入力を意味するものとして解釈します。

入力ファイルは、指定された順番に読み込みます。標準入力は1度しか読むこと
ができませんので、ファイル名`-'はコマンドライン上で1度しか使えません。



File: m4-ja.info, Node: Bugs, Next: Manual, Prev: Invoking m4, Up: Preliminaries

問題やバグへの対処方法
======================

GNU `m4'に関して問題が起こったり、バグと思われることを見つけたときは、ど
うか、それを報告してください。バグを報告する前に、実際にそれが本物のバグ
なのか確かめてください。注意深くドキュメントを読み直して、あなたのしよう
としたことが実際にできると本当に書いてあるか確かめてください。もし、ある
事ができるのかどうか明確でないときは、それも報告してください。それはドキュ
メントのバグです!

バグを報告したり、自分で直そうとする前に、そのバグを発現させる、できるだ
け小さな入力ファイルを作れないか試してください。作ることができたときは、
その入力ファイルと`m4'が出す正確な結果を私たちに送ってください。また、あ
なたはどうなるはずだと思ったのかも添えてください。これは、問題の原因が実
はドキュメントにあるものなのか判断するのに役立ちます。

問題を正確に把握したら、電子メールを(インターネット) `bug-m4@gnu.org'ま
たは(UUCP) `mit-eddie!prep.ai.mit.edu!bug-gnu-utils'へ送ってください。あ
なたが使っている`m4'のバージョン番号も書いてください、コマンド`m4
--version'で調べられます。

バグの報告以外の提案もいつでも歓迎します。ドキュメントの不明確なところや
分かりにくい機能についての質問があれば、それも送ってください。



File: m4-ja.info, Node: Manual, Prev: Bugs, Up: Preliminaries

このマニュアルの読み方
======================

このマニュアルには`m4'の入力と出力の例がたくさん含まれており、入力、出力
および`m4'からのエラーメッセージを区別するための簡単な表記法が用いられて
います。これらの例は通常の文章とは間隔をあけて、固定幅フォントで次のよう
に表示されます。

     This is an example of an example!

入力と出力を区別するため、`m4'からの出力にはすべて`=>'が、エラーメッセー
ジにはすべて`error-->'が先頭につきます。したがって次のようになります。

     Example of input line (入力行の例)
     =>Output line from m4 (m4からの出力行の例)
     error-->and an error message (エラーメッセージの例)

`m4'に最初から定義されているマクロの説明では、マクロの呼び出しのプロトタ
イプが、引数に分かりやすい名前をつけて示されます。これは次のようになりま
す。

     regexp(STRING, REGEXP, opt REPLACEMENT)

`m4'ではマクロの引数はすべて文字列ですが、数字、ファイル名、正規表現とし
てなど特別な解釈のされかたをするものもあります。

3番目の引数の前にある`opt'は、この引数が省略可能であることを表しています。
省略したときは、空文字列として解釈されます。引数リストの最後にある省略記
号(`...')は、その後にいくつでも引数を続けてよいことを示してます。




File: m4-ja.info, Node: Syntax, Next: Macros, Prev: Preliminaries, Up: Top

字句・構文解析の規則
********************

`m4'は入力を読み込むと、それを"トークン"（token）に分割します。トークン
（token）は名前（name）、クォートされた文字列(quoted string)、それらの構
成要素とならない個々の文字のどれか1つの種類に属します。また、`m4'への入
力にはコメントを含めることができます。

* Menu:

* Names::                       入力トークン: マクロ名
* Quoted strings::              入力トークン: クォートされた文字列
* Other tokens::                入力トークン: その他
* Comments::                    m4への入力中のコメント



File: m4-ja.info, Node: Names, Next: Quoted strings, Prev: Syntax, Up: Syntax

入力トークン: マクロ名
======================

名前（name）はアルファベット、数字、`_'(アンダースコア) を自由に並べたも
ののうち、先頭の文字が数字でないものです。名前にマクロの定義が存在すると
きは、マクロの呼び出しとして認識され、展開の対象となります(*Note
Macros::)。

正しい名前（name）の例を挙げると`foo', `_tmp', `name01'などがあります。



File: m4-ja.info, Node: Quoted strings, Next: Other tokens, Prev: Names, Up: Syntax

入力トークン: クォートされた文字列
==================================

クォートされた文字列（quoted string）は、引用符``'と`''に囲まれた文字列
のうち、文字列の内部で開始引用符``'と終了引用符`''の数が釣り合っているも
のです。クォートされた文字列（quoted string）のトークンとしての値は、い
ちばん外側にある引用符を一対だけ取った文字列です。したがって、

     `'

の値は空文字列です。そして、

     ``quoted''

の値は次の文字列になります。

     `quoted'

引用符を表す文字は、組み込みマクロ`changequote'を使って、いつでも替える
ことができます。詳細は*Note Changequote::を参照してください。



File: m4-ja.info, Node: Other tokens, Next: Comments, Prev: Quoted strings, Up: Syntax

入力トークン: その他
====================

名前（name）とクォートされた文字列（quoted string）の構成要素にならない
文字はすべて、それ自身で一つのトークンとなります。



File: m4-ja.info, Node: Comments, Prev: Other tokens, Up: Syntax

コメント
========

`m4'では通常`#'と改行文字で区切られた部分がコメントとなります。これらコ
メントデリミタ（comment delimiters）の間にあるすべての文字は処理の対象と
ならず無視されます。しかし、コメントデリミタ（comment delimiters）を含む
コメント全体は、出力へそのまま流されて行きます。つまり`m4'においてコメン
トは破棄*されません*。

コメントを入れ子にすることはできません。したがって、`#'の後の最初の改行
文字でコメントは終りとなります。コメント開始文字をクォートすることによっ
て、コメント開始文字としての働きを抑制できます。

コメントデリミタ（comment delimiters）は組み込みマクロ`changecom'を使っ
て、いつでも好きな文字列に変更できます。詳細は*Note Changecom::を参照し
てください。




File: m4-ja.info, Node: Macros, Next: Definitions, Prev: Syntax, Up: Top

マクロを呼び出す方法
********************

この章ではマクロの呼び出し、マクロの引数、マクロの展開が行われる過程につ
いて説明します。

* Menu:

* Invocation::                  マクロの呼び出し
* Inhibiting Invocation::       マクロの呼び出しを抑制する
* Macro Arguments::             マクロの引数
* Quoting Arguments::           マクロの引数をクォートする
* Macro expansion::             マクロの展開



File: m4-ja.info, Node: Invocation, Next: Inhibiting Invocation, Prev: Macros, Up: Macros

マクロの呼び出し
================

マクロを呼び出すときの形式には次のものがあります。

     name

これは引数を伴わないマクロの呼び出しです。

     name(arg1, arg2, ..., argN)

これはN個の引数を伴うマクロの呼び出しです。マクロはいくつでも引数を取る
ことができます。すべての引数は文字列ですが、マクロによって引数の解釈のし
かたが違うことがあります。

開きカッコ`('は、スペースを入れずにNAMEの*直後に*書かなければいけません。
そうしないと、そのマクロは引数なしで呼び出されてしまいます。

引数なしでマクロを呼び出すためには、カッコを付けては*いけません*。たとえ
ば、

     name()

これは、空の文字列を1つだけ引数として持つマクロの呼び出しであり、引数を
伴わないマクロの呼び出しではありません。



File: m4-ja.info, Node: Inhibiting Invocation, Next: Macro Arguments, Prev: Invocation, Up: Macros

マクロの呼び出しを抑制する
==========================

先行するマクロプロセッサ(Stratcheyの`GPM'など)に比べて、`m4'言語の革新的
なところは、先頭に特別な文字をつけて書くといったことをしなくても、マクロ
の呼び出しを識別できる能力です。この機能は多くの場合において便利なのです
が、ときには不必要なマクロの呼び出しの原因となることがあります。そこで、
GNU `m4'には名前（name）がマクロの呼び出しとして認識されるのを抑制するい
くつかの機構やテクニックがあります。

まず、多くの組み込みマクロは引数なしで呼び出しても意味がないので、それら
の名前の直後に開きカッコがないときは、組み込みマクロは呼び出されません。
これによって、`include'や`eval'がマクロとして認識されてしまうといったよ
くあるケースに対処できます。後ほど、この文書に出てくる"このマクロは引数
が与えられたときだけ認識されます"という文は、この動作を意味します。

また、コマンドオプション(`--prefix-builtins', または`-P') を使うと、組み
込みマクロを呼び出すときは、その名前の先頭に`m4_'をつけなければ認識され
なくなります。たとえば`m4_dnl'や、さらには`m4_m4exit'と書かなければなら
なくなります。ちなみに、このオプションはユーザ定義のマクロには何の効果も
もちません。

`changeword'機能がコンパイル時に組み込まれた`m4'を使用しているときは、マ
クロ名の認識に使われる字句構成規則をはるかに柔軟に指定することができます。
この規則は組み込みマクロとユーザ定義マクロ両方の名前に作用します。この試
験的な機能の詳細は*Note Changeword::を参照してください。

もちろん、ある名前がマクロの呼び出しとして認識されるのを防ぐ、もっとも単
純な方法は、その名前をクォートする(引用符で囲む)ことです。この節の残り部
分では、クォートすることがマクロの呼び出しにどのように影響するのか、また
マクロの呼び出しを抑制するにはそれをどのように使えよいのかを、もうすこし
詳しく見ていきます。

マクロの呼び出しを抑制したいときは名前全体をクォートするのが普通ですが、
名前の数文字をクォートするだけでも同じ効果があります。また、空文字列を
クォートするだけでもよいのですが、この場合は名前の*内部*でないと効果はあ
りません。たとえば、

     `divert'
     `d'ivert
     di`ver't
     div`'ert

これらの結果はすべて文字列`divert'となりますが、

     `'divert
     divert`'

こちらは両方とも組み込みマクロ`divert'が呼ばれます。

マクロを評価して生じた出力は常に再走査(rescan)されます。
次の例では、`m4'に`substr(abcde, 3, 2)'を入力として
与えたときと同様に、文字列`de'が生成されます。

     define(`x', `substr(ab')
     define(`y', `cde, 3, 2)')
     x`'y

クォートされた文字列（quoted string）の両端にあるクォートされていない文
字列は、マクロ名として認識される対象となります。次の例では、空文字列を
クォートすることによって`dnl'マクロが認識されるようになります。

     define(`macro', `di$1')
     macro(v)`'dnl

もし引用符がなかったら、文字列`divdnl'とそれに続く改行文字が生成されるだ
けでしょう。

クォートすることで、マクロ展開による文字列とその周囲の文字を連結したもの
がマクロの名前として認識されるのを防ぐことができます。たとえば、

     define(`macro', `di$1')
     macro(v)`ert'

この入力からは、文字列`divert'が生み出されます。もし引用符がなければ、組
み込みマクロ`divert'が呼びだされるでしょう。



File: m4-ja.info, Node: Macro Arguments, Next: Quoting Arguments, Prev: Inhibiting Invocation, Up: Macros

マクロの引数
============

ある名前（name）が認識され、その名前に対するマクロの定義が存在するとき、
それはマクロとして展開されます。

その名前の直後に開きカッコ`('があるときは、引数をすべて集めてから、マク
ロが呼び出されます。足りない引数があるときは、空文字列が与えられたものと
して解釈されます。余分な引数は無視されます。

組み込みマクロの呼び出しで引数の数が不足しているとき、通常なら`m4'は警告
を発しますが、コマンドライン・オプション`-Q'を使えば、この警告を抑制でき
ます。ユーザ定義マクロに対する引数の個数チェックはありません。

引数の収集が行われているときでも、通常と同じようにマクロの展開は行われま
す。そして展開後のテキストに出現した、コンマ、引用符、カッコなどはすべて
個々の引数の定義に寄与します。したがってFOOが`, b, c'に展開されるとき、
次のマクロの呼び出し、

     bar(a foo, d)

は、4つの引数、`a ', `b', `c', `d' を伴うマクロの呼び出しとなります。な
ぜ最初の引数に空白（whitespace）が含まれているのか理解するには、引数の前
にある空白はすべて削除されるのに対して、引数の後ろにある空白は削除されな
いことを覚えておくとよいでしょう。



File: m4-ja.info, Node: Quoting Arguments, Next: Macro expansion, Prev: Macro Arguments, Up: Macros

マクロの引数をクォートする
==========================

個々の引数の前にある、クォートされていない空白（whitespace）は削除されま
す。各引数の内部では、クォートされていないカッコはすべて対になっていなけ
ればなりません。たとえば、FOOがマクロのとき、

     foo(() (`(') `(')

これはひとつの引数を伴ったマクロの呼び出しで、
その引数の値は`() (() ('です。

引数自体がマクロ展開の対象になって欲しいのでない限り、マクロへの引数はす
べてクォートするのが普通です。したがって、上記のカッコを含む例の`正しい'
書き方は次のようになります。

     foo(`() (() (')

しかし、ときにはいくつかの引数をクォートしないでおく必要がある場合もあり、
また、そうすることに何ら問題はありません。ただ、注意を怠ると人生がすこし
ばかり厳しいものになるだけです。



File: m4-ja.info, Node: Macro expansion, Prev: Quoting Arguments, Up: Macros

マクロの展開
============

マクロの呼び出しが引数を伴うときはその収集が行われたあと、マクロは展開さ
れます。そして展開後のテキストは入力に(クォートされずに)戻され、そして再
び読み込まれます(再走査)。したがって、マクロを1つ呼び出したことで得られ
たテキストの中に、完全なマクロの呼び出しやその一部が含まれている場合、そ
こから更に多くのマクロが呼ばれることもあるわけです。

非常に簡単な例を挙げると、FOOが`bar'へ展開され、BARが`Hello world'へ展開
されるとすると、入力

     foo

は最初に`bar'へ展開された後、再び走査が行われ`Hello world'へ展開されます。



File: m4-ja.info, Node: Definitions, Next: Conditionals, Prev: Macros, Up: Top

新たにマクロを定義する方法
**************************

マクロはいくつかの異なる方法で定義、再定義、削除することができます。また
現在の定義を失うことなく一時的にマクロを再定義しておいて、後で元の定義に
戻すこともできます。

* Menu:

* Define::                      新しいマクロを定義する
* Arguments::                   マクロの引数
* Pseudo Arguments::            マクロの疑似引数
* Undefine::                    マクロの削除
* Defn::                        マクロ名の変更
* Pushdef::                     マクロの一時的な再定義

* Indir::                       マクロの間接的な呼び出し
* Builtin::                     組み込みマクロの間接的な呼び出し



File: m4-ja.info, Node: Define, Next: Arguments, Prev: Definitions, Up: Definitions

マクロの定義方法
================

通常はマクロを定義したり再定義するときは、組み込みマクロ`define'を使いま
す。

     define(NAME [, EXPANSION])

これはNAMEがEXPANSIONに展開されるように定義します。もしEXPANSIONが与えら
れなかったときは、空文字列だと見なされます。

`define'は展開されると消滅します。

次の例では、マクロFOOが`Hello World.'に展開されるように定義しています。

     define(`foo', `Hello world.')
     =>
     foo
     =>Hello world.

出力に空行がある理由は、マクロ定義の直後にある改行文字が定義の一部ではな
く、従って出力にそのままコピーされるためです。これは`dnl'マクロを使うこ
とで避けることができます。詳しくは*Note Dnl::を参照してください。

マクロ`define'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Arguments, Next: Pseudo Arguments, Prev: Define, Up: Definitions

マクロの引数
============

マクロは引数を取ることができます。N番目の引数は`$n'として展開用テキスト
の中で示し、マクロが展開されるときにN番目の実引数（actual argument）に置
き換えられます。次の例は2つの引数を取るマクロです。2つの引数の順番を単純
に交換します。

     define(`exch', `$2, $1')
     =>
     exch(arg1, arg2)
     =>arg2, arg1

これは`define'への引数の順番を逆にしたいときなどに使えます。

     define(`exch', `$2, $1')
     =>
     define(exch("expansion text", "macro"))
     =>
     macro
     =>expansion text

二重になった引用符の説明については*Note Quoting Arguments::を参照してく
ださい。

GNU `m4'では`$'に続く数字は複数の桁でもよいので、マクロはいくつでも引数
を取ることができます。これと違いUNIXの`m4'では1桁の数字しか認識されませ
ん。

特殊なケースとして、0番目の引数`$0'は常に現在展開されているマクロの名前
となります。

     define(`test', "Macro name: $0")
     =>
     test
     =>Macro name: test

クォートされたテキストを展開後のテキストに含めたい時は、クォートは入れ子
にできることを思い出しましょう。したがって、

     define(`foo', `This is macro `foo'.')
     =>
     foo
     =>This is macro foo.

展開されたテキストに含まれる`foo'は、クォートされた文字列（quoted string）
であり名前（name）ではないので、再走査によって展開は*されず*、引用符がは
ぎ取られるだけです(*Note Syntax::)。



File: m4-ja.info, Node: Pseudo Arguments, Next: Undefine, Prev: Arguments, Up: Definitions

マクロの特殊な引数
==================

与えられた実引数（actual arguments）の個数や全ての実引数をまとめて表すた
めの特別な表記方法があります。

マクロを呼び出すときに与えられた実引数の個数は、展開用テキストの中で`$#'
として表します。したがって与えられた実引数の個数を表示するマクロは次のよ
うになります。

     define(`nargs', `$#')
     =>
     nargs
     =>0
     nargs()
     =>1
     nargs(arg1, arg2, arg3)
     =>3

展開用テキストの中で`$*'という表記をすることで、全ての実引数を(クォート
はせずに)コンマで区切ったものを表すことができます。

     define(`echo', `$*')
     =>
     echo(arg1,    arg2, arg3 , arg4)
     =>arg1,arg2,arg3 ,arg4

引数をそれぞれクォートしなければならないことがよくありますが、そんなとき
は`$@'という表記を使います。これは各引数がクォートされることを除けば`$*'
と同じです。

     define(`echo', `$@')
     =>
     echo(arg1,    arg2, arg3 , arg4)
     =>arg1,arg2,arg3 ,arg4

引用符はどこに行ったのでしょうか? もちろん展開後のテキストを再走査したと
きに`m4'が食べてしまったのです。違いを見るために、次のようにしてみましょ
う。

     define(`echo1', `$*')
     =>
     define(`echo2', `$@')
     =>
     define(`foo', `This is macro `foo'.')
     =>
     echo1(foo)
     =>This is macro This is macro foo..
     echo2(foo)
     =>This is macro foo.

これが理解できないときは*Note Trace::を参照してください。

展開用テキストに記号`$'が存在し、それに続く部分が`m4'に理解できるもので
ないときは、`$'は他のテキストと同じようにマクロ展開後のテキストへ単にコ
ピーされます。

     define(`foo', `$$$ hello $$$')
     =>
     foo
     =>$$$ hello $$$

マクロを`$12'などに展開させたいときは、`$'の後に一組の引用符を置きます。
これによって、`m4'がその`$'記号を引数への参照だと解釈してまうのを防ぐこ
とができます。



File: m4-ja.info, Node: Undefine, Next: Defn, Prev: Pseudo Arguments, Up: Definitions

マクロの削除
============

`undefine'を使えばマクロの定義を削除することができます。

     undefine(NAME)

これによってマクロNAMEが削除されます。展開されてしまうのを防ぐためにマク
ロの名前は必ずクォートしなくてはなりません。

`undefine'は展開されると消滅します。

     foo
     =>foo
     define(`foo', `expansion text')
     =>
     foo
     =>expansion text
     undefine(`foo')
     =>
     foo
     =>foo

NAMEがマクロとして定義されていなくても問題はありません。その場合は
`undefine'が何もしないだけです。

`undefine'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Defn, Next: Pushdef, Prev: Undefine, Up: Definitions

マクロ名の変更
==============

すでに定義済みのマクロの名前を替えることができます。それには組み込みマク
ロ`defn'が必要となります。

     defn(NAME)

これはNAMEの*定義をクォートしたもの*に展開されます。引数が定義済みのマク
ロでないときは展開されると消滅します。

NAMEがユーザ定義マクロの場合、クォートされた定義とは単にクォートされた展
開用テキストのことです。NAMEが組み込みマクロの場合、展開後のテキストは、
`m4'の内部にある組み込みマクロの定義を指す特殊なトークンとなります。この
トークンは、`define' (および `pushdef') の第2引数としてのみ意味を持ち、
その他の文脈では無視されます。

通常の使用方法は、次の例で`undefine'の名前を`zap'に換える方法を見るのが
一番分かりやすいでしょう。

     define(`zap', defn(`undefine'))
     =>
     zap(`undefine')
     =>
     undefine(`zap')
     =>undefine(zap)

このように`defn'はユーザ定義マクロの定義や組み込みマクロの定義をコピーす
るために使うことができます。たとえ元のマクロが削除されても、もう一方の名
前を使って定義にアクセスすることができます。

`defn'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Pushdef, Next: Indir, Prev: Defn, Up: Definitions

マクロの一時的な再定義
======================

あるマクロを一時的に再定義しておき、後で元の定義に戻すことができます。そ
れには`define'と`undefine'に良く似た、組み込みマクロ`pushdef'と`popdef'
を使います。

     pushdef(NAME [, EXPANSION])
     popdef(NAME)

これらのマクロはスタック（stack）に似た仕組みで機能します。`pushdef'は、
あるマクロを一時的に再定義します。このときNAMEの前の定義は、新しい定義に
よって置き換えられる前に保存されます。もし前の定義が存在しない場合は、
`pushdef'は`define'とまったく同じように機能します。

あるマクロに複数の定義が存在する場合(その中の一つだけがアクセス可能です)、
`popdef'を使って一番上の定義を削除することができます。前の定義が無い場合、
`popdef'は`undefine'のように機能します。

     define(`foo', `Expansion one.')
     =>
     foo
     =>Expansion one.
     pushdef(`foo', `Expansion two.')
     =>
     foo
     =>Expansion two.
     popdef(`foo')
     =>
     foo
     =>Expansion one.
     popdef(`foo')
     =>
     foo
     =>foo

`define'によって、複数の定義を持つマクロを再定義したときは、一番上の定義
が新しい定義で*置き換え*られます。`undefine'によって定義を削除するときは、
一番上のもの一つだけではなく、*すべて*の定義が削除されます。

     define(`foo', `Expansion one.')
     =>
     foo
     =>Expansion one.
     pushdef(`foo', `Expansion two.')
     =>
     foo
     =>Expansion two.
     define(`foo', `Second expansion two.')
     =>
     foo
     =>Second expansion two.
     undefine(`foo')
     =>
     foo
     =>foo

`pushdef'と`defn'を使えば、組み込みマクロを一時的に再定義することができ
ます。

マクロ`pushdef'と`popdef'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Indir, Next: Builtin, Prev: Pushdef, Up: Definitions

マクロの間接的な呼び出し
========================

`indir'を使うと、どんなマクロでも間接的に呼び出すことができます。

     indir(NAME, ...)

`indir'はマクロNAMEを残りの引数と共に呼び出します。これを"不正な"名前を
持つマクロを呼ぶのに使うことができます(`define' はそういう名前でも定義で
きます。)

     define(`$$internal$macro', `Internal macro (name `$0')')
     =>
     $$internal$macro
     =>$$internal$macro
     indir(`$$internal$macro')
     =>Internal macro (name $$internal$macro)

ここでの要点は、大きなマクロ・パッケージで、間違って呼ばれてしまうことの
ないマクロを定義できるということです。それらは組み込みマクロ`indir'によっ
て*だけ*呼びだすことができます。




File: m4-ja.info, Node: Builtin, Prev: Indir, Up: Definitions

組み込みマクロの間接的な呼び出し
================================

`builtin'を使えば、組み込みマクロを間接的に呼び出すことができます。

     builtin(NAME, ...)

これは組み込みマクロNAMEを、残りの引数と共に呼び出します。たとえNAMEに本
来の定義を隠している別の定義が与えられていても、本来の定義を呼び出します。

マクロ`builtin'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Conditionals, Next: Debugging, Prev: Definitions, Up: Top

条件分岐、ループ、再帰
**********************

単純なテキストに展開されるようなマクロだけでは、引数を取ることができると
しても、十分ではありません。実行時に下される判断にもとづいて、異なる展開
がおこなわれるようなマクロが必要でしょう。たとえば、何らかの条件構文が必
要です。また、ある処理を何回も繰り返したり、条件が真の間だけ繰り返したり
するために、ある種のループ構文も必要でしょう。

* Menu:

* Ifdef::                       マクロが定義済みかを判定する
* Ifelse::                      If-else 構文と多重分岐
* Loops::                       m4におけるループと再帰



File: m4-ja.info, Node: Ifdef, Next: Ifelse, Prev: Conditionals, Up: Conditionals

マクロが定義済みかを判定する
============================

`m4'には2つの異なる条件構文が組み込まれています。その1つは`ifdef'です。

     ifdef(NAME, STRING-1, opt STRING-2)

これにより、あるマクロが定義されているかどうかをテストできるようになりま
す。NAMEがマクロとして定義されていれば`ifdef'はSTRING-1に展開され、そう
でないときはSTRING-2に展開されます。STRING-2が省略されたときは(通常の規
則に従い)空文字列として解釈されます。

     ifdef(`foo', "foo' is defined', "foo' is not defined')
     =>foo is not defined
     define(`foo', `')
     =>
     ifdef(`foo', "foo' is defined', "foo' is not defined')
     =>foo is defined

マクロ`ifdef'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Ifelse, Next: Loops, Prev: Ifdef, Up: Conditionals

文字列の比較
============

もう一方の条件構文`ifelse'はずっとパワフルです。与える引数の個数によって
長いコメントの挿入のためや、if-else構文、多重分岐などとして使うことがで
きます。

     ifelse(COMMENT)
     ifelse(STRING-1, STRING-2, EQUAL, opt NOT-EQUAL)
     ifelse(STRING-1, STRING-2, EQUAL, ...)

`ifelse'に1つだけ引数を与えた場合、それは単に捨てられて、何も出力されま
せん。これは`dnl'を何度も使わずにブロック・コメントを挿入するために良く
使われる、`m4'におけるイディオムです。GNU `m4'ではこの特殊な使用法が認め
られているので、引数が足りないことに対する警告はこのケースでは発せられま
せん。

`ifelse'に3つ、または4つの引数を与えて呼び出すと、STRING-1とSTRING-2が
(文字毎に比べて)等しければEQUALに展開されます。等しくなければNOT-EQUALに
展開されます。

     ifelse(foo, bar, `true')
     =>
     ifelse(foo, foo, `true')
     =>true
     ifelse(foo, bar, `true', `false')
     =>false
     ifelse(foo, foo, `true', `false')
     =>true

また`ifelse'には4つ以上の引数を与えることができます。この場合、`ifelse'
は伝統的なプログラミング言語における`case'文や`switch'文と同じように機能
します。STRING-1とSTRING-2が等しければ`ifelse'はEQUALに展開され、等しく
なければ最初の3つの引数が捨てられたあと、まったくおなじ手続きが繰り返さ
れます。例で示したほうがいいでしょう。

     ifelse(foo, bar, `third', gnu, gnats, `sixth', `seventh')
     =>seventh

もちろん、通常はこれらの例よりもうすこし高度な使い方をするでしょう。
`ifelse'のよくある使い方のひとつは、さまざまな種類のループ処理を実装する
マクロの中で使用する場合です。

マクロ`ifelse'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Loops, Prev: Ifelse, Up: Conditionals

ループと再帰
============

`m4'ではループ処理が直接的にはサポートされていませんが、再帰的なマクロを
定義することはできます。使用しているハードウェアとオペレーティング・シス
テムによるもの以外、再帰の深さに制限はありません。

ループ処理は再帰とすでに説明した条件構文を使うことで実現できます。

マクロの実引数を反復処理するときには組み込みマクロ`shift'を使うことがで
きます。


     shift(...)

このマクロは任意の個数の引数を受け取り、最初の引数を除く残りの引数をそれ
ぞれクォートしてから、それらをコンマで区切ったものに展開します。

     shift(bar)
     =>
     shift(foo, bar, baz)
     =>bar,baz

`shift'を使った次の例では引数の順番を逆にするマクロを定義しています。

     define(`reverse', `ifelse($#, 0, , $#, 1, "$1",
     			  `reverse(shift($@)), `$1")')
     =>
     reverse
     =>
     reverse(foo)
     =>foo
     reverse(foo, bar, gnats, and gnus)
     =>and gnus, gnats, bar, foo

それほど興味深いマクロではありませんが、`shift'と`ifelse'そして再帰を使
えばループ処理をどんなに簡単に実現できるか示しています。

次に挙げるのは、単純なforループを実現するマクロの例です。単純な数え上げ
のためなどに使えます。

     forloop(`i', 1, 8, `i ')
     =>1 2 3 4 5 6 7 8

それぞれの引数は順に、反復変数（iteration variable）の名前、開始値、終了
値、そして反復するたびに展開されるテキストです。このマクロにおいて、マク
ロ`i'はループ処理の内部でだけ定義されています。`i'が以前に値を持っていた
場合は、ループが終ればまたその値にもどります。

`forloop'は次のように入れ子にすることもできます。

     forloop(`i', 1, 4, `forloop(`j', 1, 8, `(i, j) ')
     ')
     =>(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8)
     =>(2, 1) (2, 2) (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) (2, 8)
     =>(3, 1) (3, 2) (3, 3) (3, 4) (3, 5) (3, 6) (3, 7) (3, 8)
     =>(4, 1) (4, 2) (4, 3) (4, 4) (4, 5) (4, 6) (4, 7) (4, 8)
     =>

`forloop'マクロはとても簡潔に実装することができます。`forloop'マクロ自体
は単なるラッパー(wrapper)で、第1引数が持つ元の定義を保存してから、内部マ
クロ`_forloop'を呼び、再び保存しておいた第1引数の定義を再確立します。

マクロ`_forloop'は第4引数を一度展開し、これで反復が終りかどうか調べます。
もし終りでなければ、反復変数を(すでに定義済みのマクロ`incr'を使って) 1増
やしてから、自分自身を再帰的に呼び出します。

`forloop'の実際の実装は次のようになります:

     define(`forloop',
            `pushdef(`$1', `$2')_forloop(`$1', `$2', `$3', `$4')popdef(`$1')')
     define(`_forloop',
            `$4`'ifelse($1, `$3', ,
     		   `define(`$1', incr($1))_forloop(`$1', `$2', `$3', `$4')')')

注意深い引用符の使い方に注目してください。マクロの引数でクォートされてい
ないのは3つだけで、それぞれに固有の理由があります。これら3つの引数がクォー
トされていないのはなぜか、その*理由*を見つけてください、これらがクォート
されていると、どうなるのかも確かめてみてください。


これら2つのマクロは便利ではありますが、一般の使用に耐えるほど堅牢ではあ
りません。開始値が終了値より小さい場合や、第1引数が名前でなかった場合な
ど、初歩的なエラー対策さえ欠いています。これら不備の訂正は、読者への課題
として残しておきます。



File: m4-ja.info, Node: Debugging, Next: Input Control, Prev: Conditionals, Up: Top

マクロや入力をデバッグする方法
******************************

`m4'のマクロを書いていると、(たいていのプログラミング言語の場合と同様に) 
往々にしてそれらは思ったようには動いてくれないものです。`m4'にはデバッグ
をサポートするしくみがいくつか存在します。

* Menu:

* Dumpdef::                     マクロの定義を表示する
* Trace::                       マクロの呼び出しをトレースする
* Debug Levels::                デバッグ出力の制御
* Debug Output::                デバッグ出力の保存



File: m4-ja.info, Node: Dumpdef, Next: Trace, Prev: Debugging, Up: Debugging

マクロの定義を表示する
======================

ある名前（name）が展開されるとどうなるのか調べたいときは、組み込みマクロ
`dumpdef'を使用することができます。

     dumpdef(...)

このマクロは任意の個数の引数を取ります。引数を与ずに呼びだすと、既知の名
前すべての定義を表示します。それ以外の場合は与えた引数の定義を表示します。
出力は標準エラー出力に直接行われます。

`dumpdef'は展開されると消滅します。

     define(`foo', `Hello world.')
     =>
     dumpdef(`foo')
     error-->foo:	`Hello world.'
     =>
     dumpdef(`define')
     error-->define:	<define>
     =>

最後の例は組み込みマクロの定義が表示される様子です。

表示の詳細を調整するための情報については*Note Debug Levels::を参照してく
ださい。



File: m4-ja.info, Node: Trace, Next: Debug Levels, Prev: Dumpdef, Up: Debugging

マクロの呼び出しをトレースする
==============================

組み込みマクロ`traceon'と`traceoff'を使うと、マクロの呼び出しと展開をト
レース（trace）することができます。

     traceon(...)
     traceoff(...)

`traceon'と`traceoff'を引数なしで呼ぶと、すべての定義済みのマクロに対し
てトレースがそれぞれオンまたはオフとなります。引数を指定した場合、その名
前のマクロに対してだけ作用します。

`traceon'と`traceoff'は展開されると消滅します。

トレース中のマクロが呼ばれるたびに、そのマクロの呼び出しに関する情報が引
数の収集が終ったあとに表示されます。マクロの呼び出しが展開後に消滅しない
ときは展開の結果が表示されます。出力は標準エラー出力へ直接行われます。

     define(`foo', `Hello World.')
     =>
     define(`echo', `$@')
     =>
     traceon(`foo', `echo')
     =>
     foo
     error-->m4trace: -1- foo -> `Hello World.'
     =>Hello World.
     echo(gnus, and gnats)
     error-->m4trace: -1- echo(`gnus', `and gnats') -> "gnus',`and gnats"
     =>gnus,and gnats

ダッシュ(-)の間にある数字は展開の深さを表します。たいていは最も外側のレ
ベルでの展開を表す1となりますが、クォートされていないマクロの呼び出しを
引数が含む場合には増えていきます。

表示の詳細を調整するための情報については*Note Debug Levels::を参照してく
ださい。



File: m4-ja.info, Node: Debug Levels, Next: Debug Output, Prev: Trace, Up: Debugging

デバッグ出力の制御
==================

`m4'に`-d'オプションを与えることにより、これまでの節に記載されているマク
ロを使ったときに表示される情報の詳しさを制御します。

このオプションに続けて次のうち1つまたは複数のフラグを指定します。

`t'
     今回起動する`m4'におけるマクロの呼び出しを全てトレースします。

`a'
     マクロの呼び出しに伴う実引数を表示します。`t'フラグと共に指定したと
     きは全てのマクロの呼び出しが対象となりますが、それ以外の場合は
     `traceon'マクロによってトレースしているマクロだけが対象となります。

`e'
     マクロの呼び出しが展開後に消滅しない場合、展開後のテキストを表示し
     ます。`t'フラグと共に指定したときは全てのマクロの呼び出しが対象とな
     りますが、それ以外の場合は`traceon'マクロによってトレースしているマ
     クロだけが対象となります。

`q'
     実引数やマクロの展開後のテキストを表示するときに現在の引用符でクォー
     トします。

`c'
     ひとつのマクロの呼び出しにつき複数のトレース行を表示します。マクロ
     が認識された時点で引数を集める前に1行表示し、引数を集め終った後に2
     行目を、マクロの呼び出しが完了したあとに3行目を表示します。

`x'
     トレースの各出力行にマクロの呼び出し毎に異なる`識別番号(id)'を加え
     ます。これは上記の`c'フラグを使うときに便利です。

`f'
     トレースの各出力行に、現在の入力ファイルの名前を表示します。

`l'
     トレースの各出力行に、現在の入力行番号を表示します。

`p'
     指定した名前のファイルをパス・サーチ機構(*Note Search Path::)を使っ
     て見つけたときは、実際に使われるファイル名を表示します。

`i'
     現在の入力ファイルが替わるたびに、ファイル名と入力行番号を表示しま
     す。

`V'
     上記すべてのフラグを表す簡略表記です。

`-d'オプションに何もフラグを指定しない場合、デフォルトで`aeq'が使われま
す。前2つの節にある例は、これらデフォルトのフラグを使うことを想定してい
ます。

組み込みマクロ`debugmode'を使うと、実行時にデバッグ出力のフォーマットを
制御できます。

     debugmode(opt FLAGS)

引数FLAGSは上に列挙されている文字をいくつか指定します。特殊なケースとし
て引数を`+'で始めると、それらのフラグが現在のデバッグ・フラグ群に追加さ
れます。また引数を`-'で始めると現在のデバッグ・フラグ群から削除されます。
引数をまったく与えない場合、デバッグ・フラグは(`-d'を与えない場合と同様
に) すべてゼロに設定されます。引数として空文字列を与えるとフラグはデフォ
ルトの値にリセットされます。



File: m4-ja.info, Node: Debug Output, Prev: Debug Levels, Up: Debugging

デバッグ出力の保存
==================

デバッグとトレースの出力は、`m4'に`-o'オプションを与えるか組み込みマクロ
`debugfile'を使うことで、ファイルにリダイレクト（redirect）することがで
きます。

     debugfile(opt FILENAME)

このマクロにより、ここから後に発生するデバッグとトレースの出力はすべて
FILENAMEへ送られます。FILENAMEが空文字列のときはデバッグとトレースの出力
は捨てられます。`debugfile'が引数無しで呼ばれたときは、デバッグとトレー
スの出力は標準エラー出力へ送られます。



File: m4-ja.info, Node: Input Control, Next: File Inclusion, Prev: Debugging, Up: Top

入力制御
********

この章では`m4'への入力を制御するための、さまざまな組み込みマクロを説明し
ます。

* Menu:

* Dnl::                         入力中の空白（whitespace）を削除する
* Changequote::                 引用符（quote characters）を変更する
* Changecom::                   コメントデリミタ（comment delimiters）を変更する
* Changeword::                  単語（word）の字句構造を変更する
* M4wrap::                      入力の一部を入力が終るまで保存（save）しておく



File: m4-ja.info, Node: Dnl, Next: Changequote, Prev: Input Control, Up: Input Control

入力中の空白（whitespace）を削除する
====================================

組み込みマクロ`dnl'は最初の改行文字までにある文字をすべて読み込んでから
改行文字も含めてそれらを捨てます。

     dnl

次の例のように`define'の呼び出しの後に続く改行を取り除くために、`define'
と一緒によく使います。

     define(`foo', `Macro `foo'.')dnl A very simple macro, indeed.
     foo
     =>Macro foo.

コメントの扱かわれ方とは対照的に(*Note Comments::)、次の改行までの入力が
改行を含めて捨てられます。


通常`dnl'の後ろには、行末もしくはその他の空白（whitespace）が続きます。
GNU `m4'は`dnl'に続いて開きカッコがあるとき、それを警告する診断メッセー
ジを出します。この場合`dnl'は閉じカッコを探しながら、すべての引数を集め
処理します。この引数の収集が原因となる予想可能な副作用はすべて起こります。
このとき`dnl'は何も出力しません。閉じカッコのあとに続く次の改行までの入
力は、それがどの行にあっても、改行を含めてやはり捨てられます。



File: m4-ja.info, Node: Changequote, Next: Changecom, Prev: Dnl, Up: Input Control

引用符（quote characters）を変更する
====================================

デフォルトの引用符は組み込みマクロ`changequote'によって変更できます。

     changequote(opt START, opt END)

STARTは新しい開始引用符でENDは新しい終了引用符です。もし欠けている引数が
あるときは、デフォルトの引用符(``' と `'') がその欠けている引数の代わり
に使用されます。

`changequote'は展開されると消滅します。

     changequote([, ])
     =>
     define([foo], [Macro [foo].])
     =>
     foo
     =>Macro foo.

適切な文字がないときはSTARTやENDを好きな長さにしてかまいません。

     changequote([[, ]])
     =>
     define([[foo]], [[Macro [[[foo]]].]])
     =>
     foo
     =>Macro [foo].

引用符を両方とも空文字列にすると、事実上クォート機構が無効になり、テキス
トをクォートする方法が無くなります。

     define(`foo', `Macro `FOO'.')
     =>
     changequote(, )
     =>
     foo
     =>Macro `FOO'.
     `foo'
     =>`Macro `FOO'.'

`changequote'を使って現在の引用符を替えない限り、終了引用符と対になって
いない開始引用符を含む文字列をクォートする方法は`m4'には存在しません。

入力に含まれる名前と混同されてしまうので、どちらの引用符も記号でない普通
の文字や`_' (アンダースコア)で始めるべきではありません。そうした場合は
クォート機構が無効になります。



File: m4-ja.info, Node: Changecom, Next: Changeword, Prev: Changequote, Up: Input Control

コメントデリミタ（comment delimiters）を変更する
================================================

デフォルトのコメントデリミタ（comment delimiters）は組み込みマクロ
`changecom'で変更できます。

     changecom(opt START, opt END)

STARTが新しいコメント開始デリミタ（start-comment delimiter）で、ENDが新
しいコメント終了デリミタ（end-comment delimiter）です。欠けている引数が
あるときは、デフォルトのコメント区切り記号(`#' と 改行文字)がその欠けて
いる引数の代わりに使用されます。コメント区切り記号は任意の長さにすること
ができます。

`changecom'は展開されると消滅します。

     define(`comment', `COMMENT')
     =>
     # A normal comment
     =># A normal comment
     changecom(`/*', `*/')
     =>
     # Not a comment anymore
     =># Not a COMMENT anymore
     But: /* this is a comment now */ while this is not a comment
     =>But: /* this is a comment now */ while this is not a COMMENT

クォートされた文字列であるかのようにコメントが出力にコピーされている様子
に注目しましょう。コメント内部のテキストが展開されるようにしたいときは、
コメント開始デリミタをクォートしてください。

引数なしで`changecom'を呼ぶとコメント機構が完全に無効になります。

     define(`comment', `COMMENT')
     =>
     changecom
     =>
     # Not a comment anymore
     =># Not a COMMENT anymore



File: m4-ja.info, Node: Changeword, Next: M4wrap, Prev: Changecom, Up: Input Control

単語（word）の字句構造を変更する
================================

     マクロ`changeword'とそれに関連する機能すべてが実験段階にあります。
     GNU `m4'をインストールする際`configure'に`--enable-changeword'オプ
     ションを与えたときだけこの機能を使用することができます。これから先、
     この機能が変更されたり、削除されてしまうことさえありえます。したがっ
     て、*この機能に依存した使い方はしないで下さい*。この機能について意
     見を寄せていただくときはバグを報告するときと同じ方法で行ってくださ
     い。

`m4'によって処理されるファイルは、クォートされた文字列、単語(潜在的なマ
クロ名)、そして単純なトークン(その他の単一の文字すべて) に分割されます。
初めに単語は次の正規表現によって定義されています。

     [_a-zA-Z][_a-zA-Z0-9]*

`changeword'を使えばこの正規表現を変更できます。たとえば数字が含まれてい
るファイルに置換をかけたい場合など、`m4'の字句構成規則を緩めると便利なと
きもあるでしょう。

     changeword(`[_a-zA-Z0-9]+')
     define(1, 0)
     =>1

字句構成規則を厳しくすると組み込みマクロのうちいくつかが使えなくなってし
まうことが多いので、緩める場合ほど便利にはなりません。次の例のように、間
違って組み込みマクロを呼んでしまうのを避けるために使うことはできるでしょ
う。

     define(`_indir', defn(`indir'))
     changeword(`_[_a-zA-Z0-9]*')
     esyscmd(foo)
     _indir(`esyscmd', `ls')

`m4'は単語を一度に一文字ずつ構築するので、`changeword'に渡すことができる
正規表現には制限があります。これは、もし指定した正規表現が`foo'を受理す
るなら`f'と`fo'も受理しなければならないというものです。

`changeword'には、もう一つ機能があります。指定した正規表現に角括弧でくく
られた部分が1つ以上存在する場合、最初の角括弧でくくられた部分の外側にあ
るテキストが、シンボルを表引きする前に捨てられます。

     changecom(`/*', `*/')
     changeword(`#\([_a-zA-Z0-9]*\)')
     #esyscmd(ls)

こうすると、`m4'はすべてのマクロの呼び出しの先頭に`#'記号を必要とするよ
うになるので、`m4'でシェル・スクリプトを処理するときに`shift'コマンドが
`m4'に飲み込まれてしまわないようにできます。また種々の一般的な単語を失う
ことなくプレーン・テキストを処理できるようになります。

`m4'のマクロ置換はテキストに基づいていますが、TeXのものはトークンに基づ
いています。`changeword'によって、この違いを浮き彫りにすることができます。
たとえば次の例は同じアイデアをTeXと`m4'で表現したものです。初めはTeX バー
ジョンからです。

     \def\a{\message{Hello}}
     \catcode`\@=0
     \catcode`\\=12
     =>@a
     =>@bye

つぎに`m4'バージョンです。

     define(a, `errprint(`Hello')')
     changeword(`@\([_a-zA-Z0-9]*\)')
     =>@a

TeXの例において、最初の行はマクロ`a'が`Hello'メッセージを表示するように
定義しています。2行目は\の代わりに@をエスケープ文字として使えるように定
義しています。3行目は\をエスケープ文字ではなく通常の表示可能文字として定
義しています。4行目はマクロ`a'を呼び出しています。したがって、このファイ
ルに対してTeXを走らせると`Hello'メッセージを表示します。

`m4'の例を`m4'に与えると`errprint(Hello)'を表示します。この理由はTeXはマ
クロが*定義されたとき*にマクロ定義の字句解析を行うのに対し、`m4'は単純に
テキストを保存しておき、字句解析は実際にマクロが*使われる*まで後回しにす
るからです。

`changeword'を使用すると、`m4'の速度が7倍ほど遅くなることに注意してくだ
さい。



File: m4-ja.info, Node: M4wrap, Prev: Changeword, Up: Input Control

入力の保存（save）
==================

通常の入力が終りになるまで、テキストを`保存（save）'しておくことができま
す。保存されたテキストは通常の入力が終った段階で`m4'に再び読み込まれます。
通常この機能は一時ファイルの削除など正常終了前に行うクリーンアップ動作を
開始するために使われます。

入力テキストを保存するためには組み込みマクロ`m4wrap'を使います。

     m4wrap(STRING, ...)

STRINGと残りの引数は入力が終端に達したときに再び読み込まれるように安全な
場所に保存されます。

     define(`cleanup', `This is the `cleanup' actions.
     ')
     =>
     m4wrap(`cleanup')
     =>
     This is the first and last normal input line.
     =>This is the first and last normal input line.
     ^D
     =>This is the cleanup actions.

保存されている入力は通常の入力が終端に達したときだけ再び読み込まれます。
`m4'を終了するために`m4exit'が使われたときは再読み込みは行われません。

保存されたテキストの中で`m4wrap'を呼びだしても差し支えありませんが、その
とき保存されたテキストが再読み込みされる順番は決まっていません。`m4wrap'
が再帰的に使われていない場合、保存された各テキストはそれぞれが保存された
のと逆の順番(LIFO--last in, first out)で再読み込みが行われます。



File: m4-ja.info, Node: File Inclusion, Next: Diversions, Prev: Input Control, Up: Top

ファイルのインクルード
**********************


`m4'では入力のどこででも名前を指定してファイルをインクルード（include）
することができます。

* Menu:

* Include::                     名前を指定してファイルをインクルードする
* Search Path::                 インクルードするファイルのサーチ



File: m4-ja.info, Node: Include, Next: Search Path, Prev: File Inclusion, Up: File Inclusion

名前を指定してファイルをインクルードする
========================================

`m4'にはファイルをインクルードするための組み込みマクロが2つあります。

     include(FILENAME)
     sinclude(FILENAME)

どちらもFILENAMEという名前のファイルを`m4'に読み込ませます。そのファイル
の終りに達すると以前の入力ファイルから入力を再開します。

したがって`include'と`sinclude'は展開後にFILENAMEの内容となります。

`include'に指定したファイルが存在しないとエラーとなります。ファイルが存
在しない事についてのエラー・メッセージを避けたいときは`sinclude'を使いま
す。`sinclude'は、もしファイルが存在すればそのファイルをインクルードし、
存在しなければ消滅します。

     include(`no-such-file')
     =>
     error-->30.include:2: m4: Cannot open no-such-file: No such file or directory
     sinclude(`no-such-file')
     =>

これ以降ファイル`incl.m4'の内容は仮に以下のものだとします。
     Include file start
     foo
     Include file end

通常、ファイルのインクルードはファイルの内容を入力ストリームに挿入するた
めに使用されます。インクルードされたファイルの内容は`m4'によって読まれ、
そのファイルに含まれるマクロの呼び出しは展開されます。

     define(`foo', `FOO')
     =>
     include(`incl.m4')
     =>Include file start
     =>FOO
     =>Include file end
     =>

`include'と`sinclude'がファイルの内容に展開されることを利用して、ファイ
ル全体に作用するマクロを定義することができます。次の例では`bar'が
`incl.m4'の内容に展開されるように定義しています。

     define(`bar', include(`incl.m4'))
     =>
     This is `bar':  >>>bar<<<
     =>This is bar:  >>>Include file start
     =>foo
     =>Include file end
     =><<<

もっとも、これは`include'のごく普通の使い方ではありません。なぜならファ
イルにはクォート、コンマ、括弧といった`m4'のパーサ（parser）が動作する方
法に干渉するものが含まれている可能性があるからです。

組み込みマクロ`include'と`sinclude'は引数が与えられたときだけ認識されま
す。



File: m4-ja.info, Node: Search Path, Prev: Include, Up: File Inclusion

インクルードするファイルのサーチ
================================

GNU `m4'ではインクルード対象のファイルが現在の作業ディレクトリ（current
working directory）とは別のディレクトリにあってもかまいません。

ファイルが現在の作業ディレクトリで見つからずファイル名が絶対ファイル名
（absolute file name）でないとき、GNU `m4'は指定されたサーチ・パス
（search path）を使ってそのファイルを探します。最初に`-I'オプションで指
定された各ディレクトリの中をコマンド・ラインに書かれている順番に探します。
次に環境変数`M4PATH'が設定されているときは、それをコロン(:)で区切られた
ディレクトリのリストとして解釈し、それらの中を順に探します。

インクルード・ファイルの自動サーチがトラブルの原因となったときは、`p'デ
バッグ・フラグ(*Note Debug Levels::)が問題の切り分けに役立つでしょう。



File: m4-ja.info, Node: Diversions, Next: Text handling, Prev: File Inclusion, Up: Top

出力の切替え（divert）と逆切替え（undivert）
********************************************

出力切替え（diversions）は出力を一時的に保存しておく方法です。`m4'では好
きなときに出力を一時ファイルへ切替え（divert）ておき、後で再び出力ストリー
ムへと逆切替え（"undiverted"）することができます。

切り替え先番号は0から数え上げます。切替え先0は通常の出力ストリームです。
同時に存在できる切替え先の数は主としてそれらを記述するために使われるメモ
リによって制限されます。これはGNU `m4'が切替え先の情報とそこへの出力をメ
モリに置いておこうとするためです。しかし全ての切替え先に必要なメモリの総
量には制限があります(現在は512Kです)。この最大値を超えそうになったときは、
一番大きな切替え先の内容を入れるために一時ファイルが作られ、その分のメモ
リが他の切替え先のために開放されます。したがって理論上は切替え先の数が利
用可能なファイル・ディスクリプタの数によって制限されることがありえます。


* Menu:

* Divert::                      出力を切替える（divert）
* Undivert::                    出力を逆切替え（undivert）する
* Divnum::                      出力切替え先番号（diversion number）
* Cleardiv::                    出力切替え先のテキストを破棄する



File: m4-ja.info, Node: Divert, Next: Undivert, Prev: Diversions, Up: Diversions

出力を切替える（divert）
========================

出力は`divert'を使って切替えます。

     divert(opt NUMBER)

NUMBERは使用する切替え先です。NUMBERを省略したときはゼロとして解釈されま
す。

`divert'は展開されると消滅します。

`m4'への入力がすべて処理されると、その時点で存在するすべての切替え先が自
動的に番号の順で逆切替え（undivert）されて、そこにたまっていたテキストが
出力されます。

     divert(1)
     This text is diverted.
     divert
     =>
     This text is not diverted.
     =>This text is not diverted.
     ^D
     =>
     =>This text is diverted.

同じ引数で`divert'を何回か呼び出すと、切替え先にある以前のテキストは上書
きされずに、新しいテキストが以前のテキストの後に追加されてゆきます。

存在するはずのない切替え先へ出力を切替えるとそこから後の出力は単に捨てら
れます。よくある不要な出力の例はマクロ定義の後にある改行です。次はそれら
を避ける方法です。

     divert(-1)
     define(`foo', `Macro `foo'.')
     define(`bar', `Macro `bar'.')
     divert
     =>

これは`m4'でのプログラミング上の一般的な慣用句のひとつです。



File: m4-ja.info, Node: Undivert, Next: Divnum, Prev: Divert, Up: Diversions

出力を逆切替え（undivert）する
==============================

切替え先に出力されたテキスト（diverted text）は組み込みマクロ`undivert'
を使って明示的に逆切替え（undivert）することができます。

     undivert(opt NUMBER, ...)

このマクロは引数で指定された切替え先を、指定された順に逆切替えして出力し
ます。引数が与えられなかったときは、すべての切替え先を番号順に逆切替えし
ます。


`undivert'は展開されると消滅します。

     divert(1)
     This text is diverted.
     divert
     =>
     This text is not diverted.
     =>This text is not diverted.
     undivert(1)
     =>
     =>This text is diverted.
     =>

最後にある2つの空行に注目してください。1つは`undivert'に続く改行によるも
ので、もう一方はなんと`divert'に続く改行によるものです!  切替え先のテキ
ストはしばしばこのような空行で始まります。

切替え先のテキスト（diverted text）は逆切替え(undiverted)されると、`m4'
によって再走査*されずに*、現在の出力(切替え先)に直接コピーされます。した
がってある切替え先（diversion）に出力中に、逆切替え（undivert）しても問
題ありません。

逆切替えをすると、その切替え先にあるテキストは破棄されるのでそのテキスト
を取り出せるのは1回だけです。

     divert(1)
     This text is diverted first.
     divert(0)undivert(1)dnl
     =>
     =>This text is diverted first.
     undivert(1)
     =>
     divert(1)
     This text is also diverted but not appended.
     divert(0)undivert(1)dnl
     =>
     =>This text is also diverted but not appended.

現在の切替え先（current diversion）を逆切替え（undivert）しようとしても
黙殺されます。

GNU `m4'では名前を指定したファイルを逆切替え（undivert）することができま
す。数字以外の引数を与えると、その名前をもつファイルの内容が現在の出力
(切替え先)に解釈されずにコピーされます。これによって組み込みマクロ
`include'の機能が補完されます(*Note Include::)。次の例で違いを説明します。
ファイル`foo'の内容は`bar'だとします。

     define(`bar', `BAR')
     =>
     undivert(`foo')
     =>bar
     =>
     include(`foo')
     =>BAR
     =>



File: m4-ja.info, Node: Divnum, Next: Cleardiv, Prev: Undivert, Up: Diversions

出力切替え先番号（diversion number）
====================================

組み込みマクロ`divnum'は現在の切替え先（current diversion）の番号に展開
されます。

     divnum

     Initial divnum
     =>Initial 0
     divert(1)
     Diversion one: divnum
     divert(2)
     Diversion two: divnum
     divert
     =>
     ^D
     =>
     =>Diversion one: 1
     =>
     =>Diversion two: 2

逆切替えされて出力されるテキスト自身が切替え先に出力されてしまうのを防ぐ
ために最後にある引数無しの`divert'の呼び出しが必要です。(訳者注: 誤訳の
可能性あり。原文はThe last call of `divert' without argument is
necessary, since the undiverted text would otherwise be diverted
itself.)



File: m4-ja.info, Node: Cleardiv, Prev: Divnum, Up: Diversions

出力切替え先のテキストを破棄する
================================

出力を切替えているときは切替え先のテキストが実際に必要となるかどうかは分
からないことがよくあります。テキストが溜っている切替え先は入力が終りに達
した段階でメインの出力ストリームにすべて出力されるので、切替え先にたまっ
ているテキストを破棄するためのなんらかの手段が必要です。すべての切替え先
のテキストを破棄したいときは`m4'への入力を`divert(-1)'とそれに続く明示的
な`undivert' で終えるのが最も簡単でしょう。

     divert(1)
     Diversion one: divnum
     divert(2)
     Diversion two: divnum
     divert(-1)
     undivert
     ^D

このとき出力はいっさいありません。

特定の切替え先のテキストは次のマクロで消去できます。

     define(`cleardivert',
     `pushdef(`_num', divnum)divert(-1)undivert($@)divert(_num)popdef(`_num')')
     =>

`undivert'と同じように呼び出しますが、その効果は引数として与えられた切替
え先のテキストを消去することです。(このマクロにはひどいバグがあります! 
それを見つけて直せるか挑戦してみてください。)



File: m4-ja.info, Node: Text handling, Next: Arithmetic, Prev: Diversions, Up: Top

テキスト操作用の組み込みマクロ
******************************

`m4'には部分文字列の抽出、検索、置換など様々な方法でテキストを操作するた
めの組み込みマクロがあります。

* Menu:

* Len::                         文字列の長さを計算する
* Index::                       部分文字列で検索する
* Regexp::                      正規表現で検索する
* Substr::                      部分文字列を抽出する
* Translit::                    文字の置換
* Patsubst::                    正規表現でテキストの置換をする
* Format::                      文字列を(printf風に)フォーマットする



File: m4-ja.info, Node: Len, Next: Index, Prev: Text handling, Up: Text handling

文字列の長さを計算する
======================

文字列の長さは`len'で計算できます。

     len(STRING)

このマクロはSTRINGの長さを表す10進数に展開されます。

     len()
     =>0
     len(`abcdef')
     =>6

組み込みマクロ`len'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Index, Next: Regexp, Prev: Len, Up: Text handling

部分文字列で検索する
====================

部分文字列の検索は`index'で行います。

     index(STRING, SUBSTRING)

このマクロはSTRINGの中でSUBSTRINGが最初に出現する位置のインデックスに展
開されます。STRINGの先頭にある文字のインデックスは0です。SUBSTRINGが
STRINGに含まれないとき、`index'は`-1'に展開されます。

     index(`gnus, gnats, and armadillos', `nat')
     =>7
     index(`gnus, gnats, and armadillos', `dag')
     =>-1

組み込みマクロ`index'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Regexp, Next: Substr, Prev: Index, Up: Text handling

正規表現で検索する
==================

正規表現の検索は組み込みマクロ`regexp'で行います。

     regexp(STRING, REGEXP, opt REPLACEMENT)

このマクロはREGEXPでSTRINGの中を検索します。正規表現の構文はGNU Emacsの
ものと同じです。*Note Syntax of Regular Expressions: (emacs)Regexps.

REPLACEMENTを省略すると、`regexp'はSTRINGの中でREGEXPに最初にマッチした
部分のインデックスに展開されます。REGEXPがSTRINGのどこにもマッチしない場
合は-1に展開されます。

     regexp(`GNUs not Unix', `\<[a-z]\w+')
     =>5
     regexp(`GNUs not Unix', `\<Q\w*')
     =>-1

REPLACEMENTを与えたときは、`regexp'はこの引数の値に展開されます。このと
きREPLACEMENTに含まれる`\N'はREGEXP中のN番目のカッコでくくられた部分式に
マッチしたテキストに置き換えられ、`\&'は正規表現全体にマッチしたテキスト
に置き換えられます。

     regexp(`GNUs not Unix', `\w\(\w+\)$', `*** \& *** \1 ***')
     =>*** Unix *** nix ***

組み込みマクロ`regexp'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Substr, Next: Translit, Prev: Regexp, Up: Text handling

部分文字列を抽出する
====================

部分文字列は`substr'を使って抽出します。

     substr(STRING, FROM, opt LENGTH)

このマクロはSTRINGのインデックスFROMから始まるLENGTH文字分の部分文字列に
展開されます。LENGTHを省いたときはSTRINGの最後までになります。文字列の最
初のインデックスは常に0です。

     substr(`gnus, gnats, and armadillos', 6)
     =>gnats, and armadillos
     substr(`gnus, gnats, and armadillos', 6, 5)
     =>gnats

組み込みマクロ`substr'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Translit, Next: Patsubst, Prev: Substr, Up: Text handling

文字の置換
==========

文字の置き換えは`translit'で行います。

     translit(STRING, CHARS, REPLACEMENT)

STRINGの各文字のうちCHARSに出て来る文字をそれぞれREPLACEMENT中で同じ位置
にある文字に置き換えたものに展開されます。

REPLACEMENTがCHARSより短いときは余分な文字は展開後のテキストから削除され
ます。REPLACEMENTを省略すると展開後のテキストはSTRINGからCHARSに含まれる
文字すべてを削除したものになります。

CHARSとREPLACEMENTのどちらにも文字範囲を含めることができます。たとえば
`a-z' (すべての小文字アルファベット)や`0-9' (すべての数字)などです。
CHARSやREPLACEMENTにダッシュ`-'そのものを含めるときは最初か最後に置いて
ください。

範囲の最後の文字が最初の文字より`小さい'場合もエラーではありません。そう
いうケースでは範囲が逆に広がります。つまり`9-0'は文字列`9876543210'を意
味します。

     translit(`GNUs not Unix', `A-Z')
     =>s not nix
     translit(`GNUs not Unix', `a-z', `A-Z')
     =>GNUS NOT UNIX
     translit(`GNUs not Unix', `A-Z', `z-a')
     =>tmfs not fnix

最初の例は大文字のアルファベットをすべて削除します。2番目の例は小文字を
大文字に変換します。3番目の例は大文字すべてを小文字に変換しながら`反射'
させます。最初の2つの例のほうがはるかに一般的です。

組み込みマクロ`translit'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Patsubst, Next: Format, Prev: Translit, Up: Text handling

正規表現でテキストの置換をする
==============================

文字列の全置換（global substitution）は`patsubst'で行います。

     patsubst(STRING, REGEXP, opt REPLACEMENT)

STRING中でREGEXPにマッチする部分を探し、それらをすべてREPLACEMENTに置換
します。正規表現の構文はGNU Emacsのものと同じです。

STRINGの中でREGEXPに適合するどの箇所にも含まれない部分は展開後のテキスト
にそのまま残ります。マッチする箇所が見つかるたびに、サーチはそのマッチし
た箇所の終りから続行されます。したがってSTRING内のある文字が2回置換され
ることは決してありません。REGEXPが長さ0の文字列にマッチしたときは、無限
ループを避けるためサーチの開始位置は1文字前に進められます。

置き換えが行われるときは、REPLACEMENTに含まれる`\N'をREGEXP内のカッコで
くくられたN番目の部分式にマッチしたテキストに置き換え、`\&'を正規表現全
体にマッチしたテキストに置き換えたものが展開後のテキストに挿入されます。

引数REPLACEMENTは省略することができます。そのときはREGEXPにマッチしたテ
キストは削除されます。

     patsubst(`GNUs not Unix', `^', `OBS: ')
     =>OBS: GNUs not Unix
     patsubst(`GNUs not Unix', `\<', `OBS: ')
     =>OBS: GNUs OBS: not OBS: Unix
     patsubst(`GNUs not Unix', `\w*', `(\&)')
     =>(GNUs)() (not)() (Unix)
     patsubst(`GNUs not Unix', `\w+', `(\&)')
     =>(GNUs) (not) (Unix)
     patsubst(`GNUs not Unix', `[A-Z][a-z]+')
     =>GN not 

次はもうすこし現実的な例です。文字列の中にマクロ`upcase'と`downcase'の呼
び出しを挿入することで、単独の単語または文全体をキャピタライズ
（capitalize）します。

     define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl
     define(`downcase', `translit(`$*', `A-Z', `a-z')')dnl
     define(`capitalize1',
          `regexp(`$1', `^\(\w\)\(\w*\)', `upcase(`\1')`'downcase(`\2')')')dnl
     define(`capitalize',
          `patsubst(`$1', `\w+', `capitalize1(`\&')')')dnl
     capitalize(`GNUs not Unix')
     =>Gnus Not Unix

組み込みマクロ`patsubst'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Format, Prev: Patsubst, Up: Text handling

書式付き出力
============

書式付き出力は`format'を使って行うことができます。

     format(FORMAT-STRING, ...)

このマクロはC言語の関数`printf'とよく似た動作をします。最初の引数は書式
指定文字列で`%'指定を含めることができます。`format'は展開されると書式付
の文字列になります。

2, 3の例を使って説明するのが一番でしょう。

     define(`foo', `The brown fox jumped over the lazy dog')
     =>
     format(`The string "%s" is %d characters long', foo, len(foo))
     =>The string "The brown fox jumped over the lazy dog" is 38 characters long

*Note Loops::で定義されている`forloop'マクロを使って表形式の出力をすると
きは`format'を次のように使うことができます。

     forloop(`i', 1, 10, `format(`%6d squared is %10d
     ', i, eval(i**2))')
     =>     1 squared is	    1
     =>     2 squared is	    4
     =>     3 squared is	    9
     =>     4 squared is	   16
     =>     5 squared is	   25
     =>     6 squared is	   36
     =>     7 squared is	   49
     =>     8 squared is	   64
     =>     9 squared is	   81
     =>    10 squared is	  100

組み込みマクロ`format'はANSI Cの`printf'関数をモデルとしており、
次の標準的な`%'指定をサポートしています: `c', `s', `d',
`o', `x', `X', `u', `e', `E', `f'。
またフィールド幅と精度指定、モディファイア `+', `-', ` ',
`0', `#', `h', `l'をサポートしています。
`printf'の動作について更に詳しいことは
C ライブラリ・マニュアルを見てください。




File: m4-ja.info, Node: Arithmetic, Next: UNIX commands, Prev: Text handling, Up: Top

計算用の組み込みマクロ
**********************

`m4'にはCに似た文法の整数演算機構が組み込まれています。単純なインクリメ
ントとデクリメント操作のための組み込みマクロが便利な省略記法として用意さ
れています。

* Menu:

* Incr::                        インクリメント演算子とデクリメント演算子
* Eval::                        整数式を計算する



File: m4-ja.info, Node: Incr, Next: Eval, Prev: Arithmetic, Up: Arithmetic

インクリメント演算子とデクリメント演算子
========================================

整数のインクリメントとデクリメントは組み込みマクロ`incr'と`decr' によっ
てサポートされています。

     incr(NUMBER)
     decr(NUMBER)

NUMBERの数値を1だけ増やした値または1だけ減らした値に展開されます。

     incr(4)
     =>5
     decr(7)
     =>6

組み込みマクロ`incr'および`decr'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Eval, Prev: Incr, Up: Arithmetic

整数式を計算する
================

整数式は`eval'を使って計算します。

     eval(EXPRESSION, opt RADIX, opt WIDTH)

このマクロはEXPRESSIONの値に展開されます。

式（expression）には次の演算子を含めることができます。リストは優先順位の
高い順に並んでいます。

`-'
     単項差（unary minus）
`**'
     累乗（exponentiation）
`*  /  %'
     積（multiplication）、商（division）、剰余（modulo）
`+  -'
     和（addition）、差（subtraction）
`<<  >>'
     左シフト（shift left）、右シフト（shift right）
`==  !=  >  >=  <  <='
     関係演算子（relational operator）
`!'
     論理否定（logical negation）
`~'
     ビットごとの論理否定（bitwise negation）
`&'
     ビットごとの論理積（bitwise and）
`^'
     ビットごとの排他的論理和（bitwise exclusive-or）
`|'
     ビットごとの論理和（bitwise or）
`&&'
     論理積（logical and）
`||'
     論理和（logical or）

累乗（exponentiation）を除いたすべての演算子は左結合（left associative）
をします。

`m4'の実装には`^'を累乗（exponentiation）演算子の代用として使うものが多
くありますが、`^'をビットごとの排他的論理和（bitwise exclusive-or）に使っ
ている実装も多くあります。GNU `m4'はこの点について動作の変更を行いました。
かつて`^'は累乗を行う演算子でしたが、現在はビットごとの排他的論理和を行
う演算子となっています。

特別な接頭辞（prefix）がついていない数字は10進数となります。
`0'のみの接頭辞は8進数の始まりを表します。
`0x'は16進数の始まりを表します。
`0b'は2進数の始まりを表します。
`0r'は1から36までの任意の基数で表現した数字の始まりを表します。
`0r'の後には10進数で表現した基数、コロン（:）、
および数値を表す数字列を続けなくてはなりません。
いずれの基数で表すにしても数字としては`0', `1', `2',
...を使い、`9'から上は`a', `b' ... `z'までを
数字として使います。アルファベットの大文字と小文字は基数を表す接頭辞およ
び数値を表す数字列のなかで区別なく使用することができます。

部分式をグループ化するために必要なときはカッコを使うことができます。関係
演算子は関係が真のときは`1'を返し、偽のときは`0'を返します。

`eval'の使用例をいくつか次に挙げます。

     eval(-3 * 5)
     =>-15
     eval(index(`Hello world', `llo') >= 0)
     =>1
     define(`square', `eval(($1)**2)')
     =>
     square(9)
     =>81
     square(square(5)+1)
     =>676
     define(`foo', `666')
     =>
     eval(`foo'/6)
     error-->51.eval:14: m4: Bad expression in eval: foo/6
     =>
     eval(foo/6)
     =>111

最後から2番目の例が示しているように`eval'がマクロ名を勝手に展開すること
はありません。例えそれらが有効な式(もしくは有効な式の一部)に展開されるに
してもです。したがって全てのマクロは`eval'に渡される前に展開済である必要
があります。

RADIXを指定すると展開後のテキストではその基数が使われます。デフォルトの
基数は10です。`eval'の結果は常に符号付き（signed）であると解釈されます。
引数WIDTHは最低限の出力幅を指定します。展開後のテキストが要求された幅に
なるように結果には0が埋め草（zero-padded）として付加されます。

     eval(666, 10)
     =>666
     eval(666, 11)
     =>556
     eval(666, 6)
     =>3030
     eval(666, 6, 10)
     =>0000003030
     eval(-666, 6, 10)
     =>-000003030

RADIXは36より大きくてはいけないことに注意してください。

組み込みマクロ`eval'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: UNIX commands, Next: Miscellaneous, Prev: Arithmetic, Up: Top

UNIXコマンド実行用の組み込みマクロ
**********************************

UNIXコマンドを`m4'内部から呼び出すための組み込みマクロが`m4'にはいくつか
存在します。

* Menu:

* Syscmd::                      単一のコマンドを実行する
* Esyscmd::                     コマンドの出力を読む
* Sysval::                      終了コード
* Maketemp::                    一時ファイル用の名前を生成する



File: m4-ja.info, Node: Syscmd, Next: Esyscmd, Prev: UNIX commands, Up: UNIX commands

単一のコマンドを実行する
========================

`syscmd'を使えば任意のシェル・コマンドを実行することができます。

     syscmd(SHELL-COMMAND)

シェル・コマンドとしてSHELL-COMMANDを実行します。

`syscmd'は展開後、SHELL-COMMANDからの出力には*ならず*に消滅します。
SHELL-COMMANDからの出力やエラー・メッセージは`m4'には読み込まれません。
コマンドの出力を処理する必要があるときは*Note Esyscmd::を参照してくださ
い。

コマンドの実行に先立ち、`m4'は自分の出力バッファをフラッシュします。
SHELL-COMMANDにおけるデフォルトの標準入力、標準出力、および標準エラー出
力は`m4'のものと同じです。

`syscmd'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Esyscmd, Next: Sysval, Prev: Syscmd, Up: UNIX commands

コマンドの出力を読む
====================

UNIXコマンドの出力を`m4'に読み込ませたいときは`esyscmd'を使ってください。

     esyscmd(SHELL-COMMAND)

シェル・コマンドSHELL-COMMANDの標準出力の内容に展開されます。

`m4'はコマンドの実行に先立ち自分の出力バッファをフラッシュします。
SHELL-COMMANDのデフォルトの標準入力および標準エラー出力は`m4'のものと同
じになります。SHELL-COMMANDのエラー出力は展開テキストの一部にはなりませ
ん― `m4'のエラー出力と一緒に出てくるでしょう。

次の例ではGNU `m4'ディストリビューションの`checks'ディレクトリにいると仮
定します。

     define(`vice', `esyscmd(grep Vice ../COPYING)')
     =>
     vice
     =>  Ty Coon, President of Vice
     =>

`esyscmd'の展開によるテキストの後ろに改行がついている様子に注意してくだ
さい。

`esyscmd'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Sysval, Next: Maketemp, Prev: Esyscmd, Up: UNIX commands

終了コード
==========

シェル・コマンドの実行が成功したか調べるときは`sysval'を使ってください。

     sysval

このマクロは`syscmd'や`esyscmd'で実行した最後のシェル・コマンドの終了ス
テータス（exit status）に展開されます。

     syscmd(`false')
     =>
     ifelse(sysval, 0, zero, non-zero)
     =>non-zero
     syscmd(`true')
     =>
     sysval
     =>0



File: m4-ja.info, Node: Maketemp, Prev: Sysval, Up: UNIX commands

一時ファイル用の名前を生成
==========================

`syscmd'や`esyscmd'に指定されたコマンドが出力やその他の目的で一時ファイ
ルを必要とすることもあるでしょう。一時ファイルの名前を生成するために組み
込みマクロ`maketemp'が用意されています。

     maketemp(TEMPLATE)

このマクロはTEMPLATEを元に作られた現時点で存在しないファイルの名前に展開
されます。TEMPLATEは文字列`XXXXXX'で終らなければなりません。この6つの`X'
はファイル名をユニークにするために`m4'のプロセスidを含む何らかの文字列に
よって置き換えられます。

     maketemp(`/tmp/fooXXXXXX')
     =>/tmp/fooa07346
     maketemp(`/tmp/fooXXXXXX')
     =>/tmp/fooa07346

例にあるように`maketemp'を複数回呼び出すと同じ文字列に展開されることがあ
ります。これは選択の基準がファイルが存在するかどうかだからです。
`maketemp'を次に呼び出すより前にファイルが作成されていないときは、2つの
`maketemp'マクロの呼び出しは同じ名前に展開される可能性があります。

`maketemp'は引数が与えられたときだけ認識されます。



File: m4-ja.info, Node: Miscellaneous, Next: Frozen files, Prev: UNIX commands, Up: Top

その他の組み込みマクロ
**********************

この章では、これまでのどの章にも分類できない様々な組み込みマクロを説明し
ます。

* Menu:

* Errprint::                    エラーメッセージを表示する
* M4exit::                      m4を終了させる



File: m4-ja.info, Node: Errprint, Next: M4exit, Prev: Miscellaneous, Up: Miscellaneous

エラーメッセージを表示する
==========================

エラー・メッセージは`errprint'を使って表示することができます。

     errprint(MESSAGE, ...)

このマクロはMESSAGEと残りの引数の標準エラー出力への表示だけを行います。

`errprint'は展開されると消滅します。

     errprint(`Illegal arguments to forloop
     ')
     error-->Illegal arguments to forloop
     =>

末尾の改行は自動的に印字され*ません*。したがって例にあるように引数の一部
として与えなければなりません。(BSDフレーバーの`m4'は`errprint'呼び出しご
とに改行を1つ末尾に付加します。)

エラーの場所を特定するための組み込みユーティリティ・マクロが2つあります。

     __file__
     __line__

これらは現在の入力ファイルの名前をクォートしたものとそのファイル内での現
在の入力行番号に展開されます。

     errprint(`m4:'__file__:__line__: `Input error
     ')
     error-->m4:56.errprint:2: Input error
     =>



File: m4-ja.info, Node: M4exit, Prev: Errprint, Up: Miscellaneous

`m4'を終了させる
================

すべての入力を読み込んでしまう前に`m4'を終了したいときは`m4exit'を使うこ
とができます。

     m4exit(opt CODE)

このマクロはCODEを終了コード（exit code）として`m4'を終了させます。CODE
を省略したときは終了コードは0になります。

     define(`fatal_error', `errprint(`m4: '__file__: __line__`: fatal error: $*
     ')m4exit(1)')
     =>
     fatal_error(`This is a BAD one, buster')
     error-->m4: 57.m4exit: 5: fatal error: This is a BAD one, buster

この例ではFATAL_ERRORマクロが呼び出された後、`m4'は終了コード1で終了しま
す。このマクロはエラー終了を行うためだけのものです、なぜなら通常の終了手
続き、例えば出力切替え先のテキスト（diverted text）の逆切替え（undivert）
や保存されているテキスト(*Note M4wrap::)の再読み込みなどが行われないから
です。



File: m4-ja.info, Node: Frozen files, Next: Compatibility, Prev: Miscellaneous, Up: Top

凍結状態（frozen state）の高速ロード
************************************

何百もの定義や手間がかかるその他の初期化を含んだ共通の基盤を土台として、
複数のさらに大きな`m4'アプリケーションを構築することができます。通常はそ
の共通の基盤を1つ以上のファイルに格納しておいて`m4'を起動するたびにユー
ザの入力ファイル名の前にそれらのファイル名を羅列するか、ユーザの入力ファ
イルから`include'します。

巨大なアプリケーションの共通基盤を何度も何度も繰り返し読み込むのは時間が
かかることでしょう。`m4'には大きな共通基盤を使うアプリケーションの開始時
間をスピードアップするための機構が用意されています。ユーザが次のコマンド
ラインを繰り返し使うとします。

     m4 base.m4 input.m4

ここで`input.m4'は起動のたびにいろいろな内容を持ち、`base.m4'はかなり固
定的な内容を持っているとします。こういうときは、次のようにした方がいいで
しょう。

     m4 -F base.m4f base.m4

このように一度実行しておき、必要になるたびに次のように実行します。

     m4 -R base.m4f input.m4

最初の`-F'オプションを含んでいる呼び出しは`base.m4'を読んで実行すること
で、さまざまなアプリケーション・マクロの定義やその他の初期化を行います。
入力ファイル`base.m4'の処理が完全に終ってから、GNU `m4'は凍結（"frozen"）
ファイルを`base.m4f'として生成します。このファイルは`m4'の内部状態のある
種のスナップ・ショットとなっています。

後者の`-R'オプションを含んでいる呼び出しでは、どの入力ファイルが読み込ま
れるよりも*前*に、`base.m4f'から`m4'のメモリの内部状態をリロード（reload）
しておくことができます。このようにして、まっさらな状態の`m4'から始めるか
わりに前に起動したときの結果を効率的に回復したあとで入力を読み込みます。
この例では`base.m4'を新たに読んだときと効果は同じですが、それをずっと速
く行うことができます。

`m4'の1回の起動で作ったり読み込んだりできる凍結ファイルはそれぞれ1つだけ
です。一度に2つの凍結ファイルの内容を回復することはできません。しかし
`-R'と`-F'オプションを同時につかうことで、凍結ファイルをすこしずつ更新し
ていくことはできます。

     m4 file1.m4 file2.m4 file3.m4 file4.m4

これは多少の注意を払えば同じ出力を段々と蓄積していく次の一連のコマンドに
分けることができるでしょう。

     m4 -F file1.m4f file1.m4
     m4 -R file1.m4f -F file2.m4f file2.m4
     m4 -R file2.m4f -F file3.m4f file3.m4
     m4 -R file3.m4f file4.m4

多少の注意を払う必要があるというのは、これがどんな場合にもうまく動くよう
にするためのあらゆる対策がなされているわけではないからです。とりわけ、マ
クロのトレース属性には対応していませんし`changeword'の現在の設定に関して
もそうです。`m4'のいくつかのオプションが1度目で使用されて、次は使用され
なかった場合にどのように作用するかも完全には検討されていません。一方で
`pushdef'された定義のスタックが正しく扱われることは保証されています。ま
た`undefine'された定義、組み込みマクロの名前変更、引用符やコメント記号の
変更についても同様です。

`m4'の実行が凍結されるとき、実行終了時に起こる自動的な出力の逆切替え
（undiversion）は抑制されます。そのかわり全ての正の番号をもつ出力切替え
先の内容は凍結ファイルに保存されます。使用中の出力切替え先の番号も伝えら
れます。

リロード（reload）しようとしている凍結ファイルがカレント・ディレクトリに
ある必要はありません。凍結ファイルを探す方法はインクルード・ファイル
（`include'）の場合と同じです。(*Note Search Path::)

凍結ファイルは複数のアーキテクチャで共有することができます。1つのマシン
で凍結ファイルを作り、それを他のマシンで使うときは2番目のマシンで同じか
新しいバージョンのGNU `m4'を使っているなら確実です。これらのファイルは単
純な(編集可能な)テキストファイルで、アルファベット大文字で始まり改行文字
(NL)で終る指令から成り立っています。指令があるはずの場所に`#'があるとき
はコメント行の始まりとなり、空行とあわせて無視されます。次の説明では
LENGTHは常に対応するSTRINGを参照します。数字は常に10進数で表されます。指
令の一覧です。

`V NUMBER NL'
     凍結ファイルのフォーマットを確認します。NUMBERは1にします。

`C LENGTH1 , LENGTH2 NL STRING1 STRING2 NL'
     STRING1とSTRING2を開始コメントと終了コメント文字列として使います。

`Q LENGTH1 , LENGTH2 NL STRING1 STRING2 NL'
     STRING1とSTRING2を開始クォートと終了クォート文字列として使います。

`F LENGTH1 , LENGTH2 NL STRING1 STRING2 NL'
     `pushdef'を使い、STRING1が組み込みマクロとして名前STRING2をもつ関数
     に展開されるように定義します。

`T LENGTH1 , LENGTH2 NL STRING1 STRING2 NL'
     `pushdef'を使い、STRING1がテキストSTRING2に展開されるように定義しま
     す。

`D NUMBER, LENGTH NL STRING NL'
     番号NUMBERの出力切替え先を選択し、それを現在の出力切替え先（current
     diversion）にして、STRINGを現在の出力切替え先にコピーします。NUMBER
     は存在しない出力切替え先を表す負数にすることができます。現在の出力
     切替え先の選択だけをしたいときは、STRINGを空文字列にして、このコマ
     ンドを使います。出力切替え先番号NUMBERとして0を使うと、リロード時に
     STRINGが標準出力へ出力されるでしょう、しかし`m4'内部からこのように
     このコマンドが生成されることはありません。




File: m4-ja.info, Node: Compatibility, Next: Concept index, Prev: Frozen files, Up: Top

他の版の`m4'との互換性
**********************

この章では`m4'の本実装とUNIXとりわけSystem V, Release 3における実装との
相違点を説明します。


* Menu:

* Extensions::                  GNU m4で拡張された機能
* Incompatibilities::           System V m4にあってGNU m4にない機能
* Other Incompat::              その他の非互換性



File: m4-ja.info, Node: Extensions, Next: Incompatibilities, Prev: Compatibility, Up: Compatibility

GNU `m4'で拡張された機能
========================

本バージョンの`m4'にはSystem V `m4'に存在しない機能がいくつかあります。
これらの追加された機能はコマンドライン・オプション`-G'を使うことで、他の
コマンドライン・オプションによって無効にされない限り、すべて抑制されます。

   * マクロの引数を表す`$'N表記において、Nは複数の数字を含むことができま
     すが、System V `m4'は1つの数字しか受けつけません。これによりGNU
     `m4'ではマクロが引数を9つだけでなくいくつでも取ることができます。
     (*Note Arguments::)

   * `include'と`sinclude'でインクルードされるファイルは、作業ディレクト
     リで見つからないときは指定されたサーチ・パスのなかから捜し出されま
     す。サーチ・パスは`-I'オプションと環境引数`M4PATH'で指定します。
     (*Note Search Path::)

   * `undivert'への引数は数字以外でもよく、そのときはその名前を持つファ
     イルを解釈しないまま出力に含めます。(*Note Undivert::)

   * 書式付き出力が、Cのライブラリ関数`printf'をモデルとした組み込みマク
     ロ`format'を通じてサポートされています。(*Note Format::)

   * 正規表現を使った探索とテキストの置換が組み込みマクロ`regexp' (*Note
     Regexp::)と`patsubst' (*Note Patsubst::)によってサポートされていま
     す。

   * シェル・コマンドの出力を`esyscmd' (*Note Esyscmd::)で`m4'に読み込む
     ことができます。

   * `builtin' (*Note Builtin::)により任意の組み込みマクロへ間接的にアク
     セスできます。

   * `indir' (*Note Indir::)を通じてマクロを間接的に呼び出せます。

   * 組み込みマクロ`__file__'と`__line__' (*Note Errprint::) を通じて現
     在の入力ファイルの名前と現在の入力行番号へアクセスできます。

   * `dumpdef'とマクロ・トレースの出力書式を`debugmode' (*Note Debug
     Levels::)で制御することができます。

   * トレースとデバッグの出力先を`debugfile' (*Note Debug Output::) で制
     御可能です。

上記の拡張に加えGNU `m4'には次のコマンドライン・オプションが実装されてい
ます ― `-F', `-G', `-I', `-L', `-R', `-V', `-W', `-d', `-l', `-o', `-t'。
これらオプションの説明は*Note Invoking m4::を参照してください。

またGNU `m4'のデバッグとトレース機構は他バージョンの`m4'にあるものより遥
かに大規模です。



File: m4-ja.info, Node: Incompatibilities, Next: Other Incompat, Prev: Extensions, Up: Compatibility

System V `m4' にあってGNU `m4'にない機能
========================================

System Vバージョンの`m4'にはGNU `m4'にまだ実装されていない機能がいくつか
あります。

   * System V `m4'は`defn'への複数の引数をサポートしています。GNU `m4'は
     これを実装していません。この機能の有用性が筆者にははっきりしません。



File: m4-ja.info, Node: Other Incompat, Prev: Incompatibilities, Up: Compatibility

その他の非互換性
================

System Vバージョンの`m4'と本実装との間には他にいくつか非互換な部分があり
ます。

   * テキストが出力切替え先（diversion）に送られるときのときの同期行の実
     装がGNU `m4'とSystem V `m4'では異なります。GNU `m4'はテキストが出力
     切替え先に送られるときに同期行を出力しますが、System V `m4'ではこれ
     が、出力切替え先のテキストが引き戻されるときになります。

     問題は出力切替え先に送られる、または送られていたテキストにどの行番
     号とファイル名をつけ加えるかです。System V `m4'は出力切替え先に送ら
     れていたすべてのテキストが`undivert'の呼び出しを含むソース行によっ
     て生成されたと見なしますが、GNU `m4'は出力切替え先に送られる時にテ
     キストが生成されたと見なします。

     私は同期行オプションを使うのは大抵`m4'をコンパイラのフロントエンド
     として使うときだと考えます。もし出力切替え先に送られた行がコンパイ
     ラエラーを引き起こしたら、エラーメッセージは出力切替え先のテキスト
     が挿入しなおされた場所ではなく、出力切替え先に送られた場所をおそら
     く指し示すべきでしょう。

   * GNU `m4'は自己参照的な定義を防ごうとはしません。

          define(`x', `x')
          define(`x', `x ')

     `x'が`x'を返すように定義することに、本質的に間違っているところはあ
     りません。間違っているのはクォートされていない`x'を展開することです。
     他のプログラミング言語で変数を使うのと同じように、`m4'で文字列を保
     持するためにマクロ使い、さらにそれを次のようにチェックする人もいる
     でしょう:

          ifelse(defn(`HOLDER'), `VALUE', ...)

     このような場合、マクロが自分自身の名前を保持するのを禁止するのは余
     計なお世話でしょう。もちろん、これはGNU `m4'ユーザが自分で首をくく
     るためのロープを放置しておくことにはなります!  再走査によるハング
     （hang）は、伝統的なプログラミング言語において無限ループに対すると
     きのような、注意深いプログラミングによって避けることができるでしょ
     う。

   * GNU `m4'は`-G'オプション無しだと、`__gnu__'が空行に展開されるように
     定義します。

     UNIX システム上においてGNU `m4'は`-G'オプションをつけるとマクロ
     `__unix__'、つけないときはマクロ`unix'を定義します。両方とも空文字
     列に展開されます。



File: m4-ja.info, Node: Concept index, Next: Macro index, Prev: Compatibility, Up: Top

Concept index
*************


* Menu:

* GNU拡張:                      Extensions.             5.
* GNU extensions:               Extensions.             5.
* 互換性:                       Compatibility.          5.
* compatibility:                Compatibility.          5.
* GNU拡張:                      Frozen files.           5.
* 凍結状態（frozen state）の高速ロード: Frozen files.   5.
* GNU extensions:               Frozen files.           5.
* reloading a frozen file:      Frozen files.           5.
* dumping into frozen file:     Frozen files.           5.
* initialization, frozen states: Frozen files.          5.
* frozen files for fast loading: Frozen files.          5.
* fast loading of frozen files: Frozen files.           5.
* m4を終了させる:               M4exit.                 5.
* exiting from `m4':            M4exit.                 5.
* エラーメッセージの表示:       Errprint.               5.
* messages, printing error:     Errprint.               5.
* error messages, printing:     Errprint.               5.
* printing error messages:      Errprint.               5.
* 一時ファイル名:               Maketemp.               5.
* files, names of temporary:    Maketemp.               5.
* temporary filenames:          Maketemp.               5.
* UNIXコマンドの終了コード:     Sysval.                 5.
* commands, exit code from UNIX: Sysval.                5.
* UNIX commands, exit code from: Sysval.                5.
* exit code from UNIX commands: Sysval.                 5.
* GNU拡張:                      Esyscmd.                5.
* GNU extensions:               Esyscmd.                5.
* UNIXコマンドの実行:           UNIX commands.          5.
* commands, running UNIX:       UNIX commands.          5.
* UNIX commands, running:       UNIX commands.          5.
* running UNIX commands:        UNIX commands.          5.
* executing UNIX commands:      UNIX commands.          5.
* 整数式の評価:                 Eval.                   5.
* 整数式の計算:                 Eval.                   5.
* expressions, evaluation of integer: Eval.             5.
* evaluation, of integer expressions: Eval.             5.
* integer expression evaluation: Eval.                  5.
* デクリメント演算子:           Incr.                   5.
* インクリメント演算子:         Incr.                   5.
* increment operator:           Incr.                   5.
* decrement operator:           Incr.                   5.
* 整数演算:                     Arithmetic.             5.
* 計算, 演算:                   Arithmetic.             5.
* integer arithmetic:           Arithmetic.             5.
* arithmetic:                   Arithmetic.             5.
* GNU拡張:                      Format.                 5.
* 書式付き出力:                 Format.                 5.
* GNU extensions:               Format.                 5.
* output, formatted:            Format.                 5.
* formatted output:             Format.                 5.
* GNU拡張:                      Patsubst.               5.
* パターンマッチ:               Patsubst.               5.
* 正規表現で置換:               Patsubst.               5.
* GNU extensions:               Patsubst.               5.
* substitution by regular expression: Patsubst.         5.
* pattern substitution:         Patsubst.               5.
* regular expressions:          Patsubst.               5.
* 文字の置き換え:               Translit.               5.
* 文字の置換:                   Translit.               5.
* characters, translating:      Translit.               5.
* translating characters:       Translit.               5.
* 部分文字列を切り出す:         Substr.                 5.
* 部分文字列を抽出:             Substr.                 5.
* substrings, extracting:       Substr.                 5.
* extracting substrings:        Substr.                 5.
* GNU拡張:                      Regexp.                 5.
* 正規表現:                     Regexp.                 5.
* GNU extensions:               Regexp.                 5.
* regular expressions:          Regexp.                 5.
* 文字列の長さ:                 Len.                    5.
* strings, length of:           Len.                    5.
* length of strings:            Len.                    5.
* 出力切替え先のテキストを破棄する: Cleardiv.           5.
* diverted text, discarding:    Cleardiv.               5.
* discarding diverted text:     Cleardiv.               5.
* 出力切替え先番号（diversion number）: Divnum.         5.
* diversion numbers:            Divnum.                 5.
* GNU拡張:                      Undivert.               56.
* ファイルのインクルード:       Undivert.               56.
* inclusion, of files:          Undivert.               56.
* file inclusion:               Undivert.               56.
* GNU extensions:               Undivert.               56.
* 出力をファイルへ切替える（divert）: Divert.           5.
* files, diverting output to:   Divert.                 5.
* output, diverting to files:   Divert.                 5.
* diverting output to files:    Divert.                 5.
* GNU拡張:                      Search Path.            5.
* インクルードファイルのサーチパス: Search Path.        5.
* GNU extensions:               Search Path.            5.
* included files, search path for: Search Path.         5.
* search path for included files: Search Path.          5.
* inclusion, of files:          File Inclusion.         5.
* ファイルのインクルード:       File Inclusion.         5.
* file inclusion:               File Inclusion.         5.
* 入力を保存:                   M4wrap.                 5.
* input, saving:                M4wrap.                 5.
* saving input:                 M4wrap.                 5.
* 単語の字句構造:               Changeword.             5.
* words, lexical structure of:  Changeword.             5.
* lexical structure of words:   Changeword.             5.
* 出力にコピーされるコメント:   Changecom.              29.
* comments, copied to output:   Changecom.              29.
* コメントデリミタを変更:       Changecom.              5.
* comment delimiters, changing: Changecom.              5.
* changing comment delimiters:  Changecom.              5.
* 引用符を変更:                 Changequote.            5.
* quote delimiters, changing the: Changequote.          5.
* changing the quote delimiters: Changequote.           5.
* 入力の空白を削除:             Dnl.                    5.
* deleting whitespace in input: Dnl.                    5.
* GNU拡張:                      Debug Output.           5.
* デバッグ出力を保存:           Debug Output.           5.
* GNU extensions:               Debug Output.           5.
* output, saving debugging:     Debug Output.           5.
* debugging output, saving:     Debug Output.           5.
* saving debugging output:      Debug Output.           5.
* GNU拡張:                      Debug Levels.           58.
* GNU extensions:               Debug Levels.           58.
* デバッグ出力の制御:           Debug Levels.           5.
* debugging output, controlling: Debug Levels.          5.
* controlling debugging output: Debug Levels.           5.
* マクロの展開をトレース:       Trace.                  5.
* expansion, tracing macro:     Trace.                  5.
* macro expansion, tracing:     Trace.                  5.
* tracing macro expansion:      Trace.                  5.
* マクロの定義を表示:           Dumpdef.                5.
* definitions, displaying macro: Dumpdef.               5.
* macros, displaying definitions: Dumpdef.              5.
* displaying macro definitions: Dumpdef.                5.
* ループの回数を数える:         Loops.                  40.
* counting loops:               Loops.                  40.
* loops, counting:              Loops.                  40.
* forloops:                     Loops.                  40.
* ループ:                       Loops.                  9.
* loops:                        Loops.                  9.
* 再帰的なマクロ:               Loops.                  5.
* macros, recursive:            Loops.                  5.
* recursive macros:             Loops.                  5.
* 多重分岐:                     Ifelse.                 32.
* multibranches:                Ifelse.                 32.
* 文字列の比較:                 Ifelse.                 5.
* comparing strings:            Ifelse.                 5.
* 条件構文:                     Ifdef.                  5.
* conditionals:                 Ifdef.                  5.
* GNU拡張:                      Builtin.                5.
* 組み込みマクロを間接的に呼び出す: Builtin.            5.
* GNU extensions:               Builtin.                5.
* builtins, indirect call of:   Builtin.                5.
* call of builtins, indirect:   Builtin.                5.
* indirect call of builtins:    Builtin.                5.
* GNU拡張:                      Indir.                  5.
* マクロを間接的に呼び出す:     Indir.                  5.
* GNU extensions:               Indir.                  5.
* macros, indirect call of:     Indir.                  5.
* call of macros, indirect:     Indir.                  5.
* indirect call of macros:      Indir.                  5.
* マクロを一時的に再定義:       Pushdef.                5.
* redefinition of macros, temporary: Pushdef.           5.
* temporary redefinition of macros: Pushdef.            5.
* macros, temporary redefinition of: Pushdef.           5.
* マクロの名前をかえる方法:     Defn.                   5.
* renaming macros:              Defn.                   5.
* macros, how to rename:        Defn.                   5.
* マクロを削除する方法:         Undefine.               5.
* undefining macros:            Undefine.               5.
* deleting macros:              Undefine.               5.
* macros, how to delete:        Undefine.               5.
* マクロの特殊な引数:           Pseudo Arguments.       5.
* arguments to macros, special: Pseudo Arguments.       5.
* macros, special arguments to: Pseudo Arguments.       5.
* special arguments to macros:  Pseudo Arguments.       5.
* GNU拡張:                      Arguments.              27.
* GNU extensions:               Arguments.              27.
* マクロへの引数:               Arguments.              5.
* Arguments to macros:          Arguments.              5.
* macros, arguments to:         Arguments.              5.
* マクロを新しく定義する方法:   Definitions.            5.
* defining new macros:          Definitions.            5.
* macros, how to define new:    Definitions.            5.
* マクロの展開:                 Macro expansion.        5.
* expansion of macros:          Macro expansion.        5.
* macros, expansion of:         Macro expansion.        5.
* クォートされたマクロの引数:   Quoting Arguments.      5.
* arguments, quoted macro:      Quoting Arguments.      5.
* macros, quoted arguments to:  Quoting Arguments.      5.
* quoted macro arguments:       Quoting Arguments.      5.
* 引数:                         Macro Arguments.        5.
* マクロの引数:                 Macro Arguments.        5.
* マクロへの引数:               Macro Arguments.        5.
* arguments to macros:          Macro Arguments.        5.
* macros, arguments to:         Macro Arguments.        5.
* マクロ呼び出し:               Invocation.             5.
* マクロの呼び出し:             Invocation.             5.
* macro invocation:             Invocation.             5.
* コメント:                     Comments.               5.
* comments:                     Comments.               5.
* 引用符で括られた文字列:       Quoted strings.         5.
* 引用符で囲まれた文字列:       Quoted strings.         5.
* クォートされた文字列:         Quoted strings.         5.
* quoted string:                Quoted strings.         5.
* 名前:                         Names.                  5.
* names:                        Names.                  5.
* トークン:                     Syntax.                 5.
* 入力トークン:                 Syntax.                 5.
* tokens:                       Syntax.                 5.
* input tokens:                 Syntax.                 5.
* コマンドライン上のファイル名: Invoking m4.            175.
* filenames, on the command line: Invoking m4.          175.
* command line, filenames on the: Invoking m4.          175.
* コマンドライン上でマクロを定義: Invoking m4.          141.
* command line, macro definitions on the: Invoking m4.  141.
* macro definitions, on the command line: Invoking m4.  141.
* コマンドライン, オプション:   Invoking m4.            9.
* options, command line:        Invoking m4.            9.
* command line, options:        Invoking m4.            9.



File: m4-ja.info, Node: Macro index, Prev: Concept index, Up: Top

Macro index
***********

参照先は組み込みマクロが最初に紹介されている場所だけです。索引では始めや
終りに`__'のある名前はそれらが取り除かれています。



* Menu:

* unix:                         Other Incompat.         51.
* gnu:                          Other Incompat.         48.
* m4exit:                       M4exit.                 5.
* line:                         Errprint.               24.
* file:                         Errprint.               24.
* errprint:                     Errprint.               5.
* maketemp:                     Maketemp.               5.
* sysval:                       Sysval.                 5.
* esyscmd:                      Esyscmd.                5.
* syscmd:                       Syscmd.                 5.
* eval:                         Eval.                   5.
* decr:                         Incr.                   5.
* incr:                         Incr.                   5.
* format:                       Format.                 5.
* patsubst:                     Patsubst.               5.
* translit:                     Translit.               5.
* substr:                       Substr.                 5.
* regexp:                       Regexp.                 5.
* index:                        Index.                  5.
* len:                          Len.                    5.
* divnum:                       Divnum.                 5.
* undivert:                     Undivert.               5.
* divert:                       Divert.                 5.
* sinclude:                     Include.                5.
* include:                      Include.                5.
* m4wrap:                       M4wrap.                 5.
* changeword:                   Changeword.             5.
* changecom:                    Changecom.              5.
* changequote:                  Changequote.            5.
* dnl:                          Dnl.                    5.
* debugfile:                    Debug Output.           5.
* debugmode:                    Debug Levels.           58.
* traceoff:                     Trace.                  5.
* traceon:                      Trace.                  5.
* dumpdef:                      Dumpdef.                5.
* shift:                        Loops.                  11.
* ifelse:                       Ifelse.                 5.
* ifdef:                        Ifdef.                  5.
* builtin:                      Builtin.                5.
* indir:                        Indir.                  5.
* pushdef:                      Pushdef.                6.
* popdef:                       Pushdef.                6.
* defn:                         Defn.                   5.
* undefine:                     Undefine.               5.
* define:                       Define.                 5.



Tag table:
Node: Top1014
Node: Preliminaries5633
Node: Intro6083
Node: History7076
Node: Invoking m47711
Node: Bugs12086
Node: Manual12821
Node: Syntax13602
Node: Names14060
Node: Quoted strings14357
Node: Other tokens14820
Node: Comments15017
Node: Macros15492
Node: Invocation15870
Node: Inhibiting Invocation16363
Node: Macro Arguments18265
Node: Quoting Arguments18957
Node: Macro expansion19484
Node: Definitions19883
Node: Define20446
Node: Arguments21002
Node: Pseudo Arguments22020
Node: Undefine23354
Node: Defn23846
Node: Pushdef24571
Node: Indir25865
Node: Builtin26430
Node: Conditionals26726
Node: Ifdef27171
Node: Ifelse27769
Node: Loops28931
Node: Debugging31069
Node: Dumpdef31494
Node: Trace32060
Node: Debug Levels33007
Node: Debug Output34423
Node: Input Control34796
Node: Dnl35245
Node: Changequote35917
Node: Changecom36892
Node: Changeword37966
Node: M4wrap40071
Node: File Inclusion40920
Node: Include41214
Node: Search Path42648
Node: Diversions43185
Node: Divert43995
Node: Undivert44808
Node: Divnum46326
Node: Cleardiv46966
Node: Text handling47697
Node: Len48211
Node: Index48487
Node: Regexp48931
Node: Substr49714
Node: Translit50176
Node: Patsubst51093
Node: Format52638
Node: Arithmetic53830
Node: Incr54144
Node: Eval54508
Node: UNIX commands56765
Node: Syscmd57146
Node: Esyscmd57640
Node: Sysval58268
Node: Maketemp58632
Node: Miscellaneous59318
Node: Errprint59585
Node: M4exit60290
Node: Frozen files60938
Node: Compatibility63983
Node: Extensions64333
Node: Incompatibilities65853
Node: Other Incompat66180
Node: Concept index67591
Node: Macro index79827

End tag table
