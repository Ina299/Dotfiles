Info file: gdb-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gdb-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.









START-INFO-DIR-ENTRY * Gdb: (gdb).  The GNU debugger.
END-INFO-DIR-ENTRY This file documents the GNU debugger GDB.


This is the Seventh Edition, February 1999, of `Debugging with GDB: the
GNU Source-Level Debugger' for GDB Version 4.18.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.





File: gdb-ja.info, Node: Altering, Next: GDB Files, Prev: Symbols, Up: Top

実行の変更
**********

ユーザ・プログラムの中に誤りのある箇所を見つけると、その明らかな誤りを訂
正することで、その後の実行が正しく行われるかどうかを知りたくなるでしょう。
GDBにはプログラムの実行に変化を与える機能があり、これを使って実験するこ
とで、その答を知ることができます。

例えば、変数やメモリ上のある箇所に新しい値を格納すること、ユーザ・プログ
ラムにシグナルを送ること、ユーザ・プログラムを異なるアドレスで再起動する
こと、関数が完全に終了する前に呼び出し元に戻ることなどが可能です。

* Menu:

* Assignment::                  変数への代入
* Jumping::                     異なるアドレスにおける処理継続
* Signaling::                   ユーザ・プログラムへのシグナルの通知

* Returning::                   関数からの復帰
* Calling::                     ユーザ・プログラム関数の呼び出し
* Patching::                    ユーザ・プログラムへのパッチ適用



File: gdb-ja.info, Node: Assignment, Next: Jumping, Prev: Altering, Up: Altering

変数への代入
============

ある変数の値を変更するには、代入式を評価します。*Note Expressions:
Expressions。例えば、

     print x=4

は、変数`x'に値4を格納してから、その代入式の値（すなわち4）を表示します。
サポートされている言語の演算子の詳細情報については、*Note Using GDB with
Different Languages: Languages。

代入の結果を表示させることに関心がなければ、`print'コマンドの代わりに
`set'コマンドを使用してください。実際のところ`set'コマンドは、式の値が表
示もされず、値ヒストリ（*Note Value history: Value History.）にも入らな
いということを除けば、`print'コマンドと同等です。式は、その結果の入手だ
けを目的として評価されます。

`set'コマンドの引数となる文字列の先頭の部分が、`set'コマンドのサブ・コマ
ンドの名前と一致してしまうような場合には、ただの`set'コマンドではなく
`set variable'コマンドを使用してください。このコマンドは、サブ・コマンド
を持たないという点を除けば、`set'コマンドと同等です。例えば、ユーザ・プ
ログラムに`width'という変数がある場合、`set width=13'によってこの変数に
値を設定しようとするとエラーになります。これは、GDBが`set width'というコ
マンドを持っているためです。

     ( gdb) whatis width
     type = double
     ( gdb) p width
     $4 = 13
     ( gdb) set width=47
     Invalid syntax in expression.

ここで不正な表現となっているのは、もちろん`=47'の部分です。プログラム内
の変数`width'に値を設定するには、以下のようにしてください。

     ( gdb) set var width=47

 GDBは、代入時の暗黙の型変換をC言語よりも多くサポートしています。整数値
を自由にポインタ型変数に格納できますし、その逆もできます。また、任意の構
造体を、同じサイズの別の構造体、または、より小さいサイズの別の構造体に変
換することができます。

メモリ上の任意の箇所に値を格納するには、指定されたアドレスにおいて指定さ
れた型の値を生成するために、`{...}'を使用します（*Note Expressions:
Expressions.）。例えば`{int}0x83040'は、メモリ・アドレス`0x83040'を整数
値として参照します（メモリ上における、ある特定のサイズと表現を示唆してい
ます）。また、

     set {int}0x83040 = 4

は、そのメモリ・アドレスに値4を格納します。



File: gdb-ja.info, Node: Jumping, Next: Signaling, Prev: Assignment, Up: Altering

異なるアドレスにおける処理継続
==============================

通常、ユーザ・プログラムを継続実行するには、`continue'コマンドを使用して、
停止した箇所から継続実行させます。以下のコマンドを使用することで、ユーザ
が選択したアドレスにおいて実行を継続させることができます。

`jump LINESPEC'
     LINESPECで指定される行において、実行を再開します。その行にブレイク
     ポイントが設定されている場合には、実行は再びすぐに停止します。
     LINESPECの形式については、*Note Printing source lines: List。一般的
     な慣例として、`jump'コマンドは、`tbreak'コマンドと組み合わせて使用
     されます。*Note Setting breakpoints: Set Breaks。

     `jump'コマンドは、カレントなスタック・フレーム、スタック・ポインタ、
     メモリ内の任意の箇所の内容、プログラム・カウンタを除くレジスタの内
     容を変更しません。LINESPECで指定される行が、現在実行されている関数
     とは異なる関数の中にある場合、それら2つの関数が異なるパターンの引数
     やローカル変数を期待していると、奇妙な結果が発生するかもしれません。
     このため、指定された行が、現在実行されている関数の中にない場合、
     `jump'コマンドは実行の確認を求めてきます。しかし、ユーザがプログラ
     ムのマシン言語によるコードを熟知していたとしても、奇妙な結果の発生
     することが予想されます。

`jump *ADDRESS'
     ADDRESSで指定されるアドレスにある命令から、実行を再開します。

レジスタ`$pc'に新しい値を設定することで、`jump'コマンドとほとんど同等の
効果を実現することができます。両者の違いは、レジスタ`$pc'に値を設定した
だけでは、ユーザ・プログラムの実行は再開されないという点にあります。ユー
ザが実行を*継続するとき*に、プログラムが実行を再開するアドレスが変更され
るだけです。例えば、

     set $pc = 0x485

を実行すると、次に`continue'コマンドやステップ実行を行うコマンドが実行さ
れるとき、ユーザ・プログラムが停止したアドレスにある命令ではなく、アドレ
ス`0x485'にある命令から実行されることになります。*Note Continuing and
stepping: Continuing and Stepping。

`jump'コマンドが最も一般的に使用されるのは、既に実行されたプログラム部分
を、さらに多くのブレイクポイントを設定した状態で再実行する場合でしょう。
これにより、実行される処理の内容をさらに詳しく調べることができます。



File: gdb-ja.info, Node: Signaling, Next: Returning, Prev: Jumping, Up: Altering

ユーザ・プログラムへのシグナルの通知
====================================

`signal SIGNAL'
     実行を停止した箇所からユーザ・プログラムを再開させますが、すぐに
     SIGNALで指定されるシグナルを通知します。SIGNALには、シグナルの名前
     または番号を指定できます。例えば、多くのシステムにおいて、`signal
     2'と`signal SIGINT'はどちらも、割り込みシグナルを通知する方法です。

     一方、
     SIGNALが0であれば、
     シグナルを通知することなく実行を継続します。
     ユーザ・プログラムがシグナルのために停止し、
     通常であれば、
     `continue'コマンドによって実行を再開するとそのシグナルを検知してしまうような場合に便利です。
     `signal 0'を実行すると、
     プログラムはシグナルを受信することなく実行を再開します。

     `signal'を実行した後、RETキーを押しても、繰り返し実行は行われません。

`signal'コマンドを実行することは、シェルから`kill'ユーティリティを実行す
るのと同じではありません。`kill'によってシグナルを送ると、GDBはシグナル
処理テーブルによって何をするべきかを決定します（*Note Signals::）。一方、
`signal'コマンドは、ユーザ・プログラムに直接シグナルを渡します。




File: gdb-ja.info, Node: Returning, Next: Calling, Prev: Signaling, Up: Altering

関数からの復帰
==============

`return'
`return EXPRESSION'
     `return'コマンドによって、呼び出されている関数の実行をキャンセルす
     ることができます。式EXPRESSIONを引数に指定すると、その値が関数の戻
     り値として使用されます。

`return'を実行すると、GDBは選択されているスタック・フレーム（および、そ
の下位にあるすべてのフレーム）を破棄します。破棄されたフレームは、実行を
完結する前に復帰したのだと考えればよいでしょう。戻り値を指定したいのであ
れば、その値を`return'への引数として渡してください。

このコマンドは、選択されているスタック・フレーム（*Note Selecting a
frame: Selection.）、および、その下位にあるすべてのフレームをポップして、
もともと選択されていたフレームを呼び出したフレームを、最下位のフレームに
します。つまり、そのフレームが選択されることになります。指定された値は、
関数から戻り値を返すのに使用されるレジスタに格納されます。

`return'コマンドは実行を再開しません。関数から復帰した直後の状態で、プロ
グラムを停止したままにします。これに対して、`finish'コマンド（*Note
Continuing and stepping: Continuing and Stepping.）は、選択されているス
タック・フレームが自然に復帰するまで、実行を再開、継続します。



File: gdb-ja.info, Node: Calling, Next: Patching, Prev: Returning, Up: Altering

プログラム関数の呼び出し
========================

`call EXPR'
     `void'型の戻り値を表示することなく、式EXPRを評価します。

ユーザ・プログラムの中からある関数を呼び出したいが、void型の戻り値を出力
させたくない場合、この`print'コマンドの変種を使用することができます。
`void'型でない戻り値は表示され、値ヒストリに保存されます。

A29Kでは、ユーザに制御される変数`call_scratch_address'によって、GDBがデ
バッグ対象の関数を呼び出すときに使用するスクラッチ領域が指定されます。通
常はスクラッチ領域をスタック上に置きますが、この方法は命令空間とデータ空
間を別々に持つシステム上では機能しないため、これが必要になります。



File: gdb-ja.info, Node: Patching, Prev: Calling, Up: Altering

プログラムへのパッチ適用
========================

デフォルトでは、GDBはユーザ・プログラムの実行コードを持つファイル（ある
いは、コア・ファイル）を書き込み不可の状態でオープンします。これにより、
マシン・コードを誤って変更してしまうことを防ぐことができます。しかし、ユー
ザ・プログラムのバイナリに意図的にパッチを適用することもできなくなってし
まいます。

バイナリにパッチを適用したいのであれば、`set write'コマンドによって明示
的にそのことを指定することができます。例えば、内部的なデバッグ・フラグを
立てたり、緊急の修正を行いたいということがあるでしょう。

`set write on'
`set write off'
     `set write on'を指定すると、GDBは実行ファイルやコア・ファイルを、読
     み込み、書き込みともに可能な状態でオープンします。`set write off' 
     （デフォルト）を指定すると、GDBはこれらのファイルを読み込みしかでき
     ない状態でオープンします。

     既にファイルをロード済みの場合、`set write'の設定を変更後、その変更
     を反映させるためには、（`exec-file'コマンド、`core-file'コマンドを
     使用して）、そのファイルを再ロードしなければなりません。

`show write'
     実行ファイル、コア・ファイルが、読み込みだけではなく書き込みもでき
     る状態でオープンされる設定になっているか否かを表示します。



File: gdb-ja.info, Node: GDB Files, Next: Targets, Prev: Altering, Up: Top

 GDBファイル
************

 GDBはデバッグ対象となるプログラムのファイル名を知っている必要があります。
これは、プログラムのシンボル・テーブルを読み込むためでもあり、また、プロ
グラムを起動するためでもあります。過去に生成されたコア・ダンプをデバッグ
するには、GDBにコア・ダンプ・ファイルの名前を教えてやらなければなりませ
ん。

* Menu:

* Files::                       ファイルを指定するコマンド
* Symbol Errors::               シンボル・ファイル読み込み時のエラー



File: gdb-ja.info, Node: Files, Next: Symbol Errors, Prev: GDB Files, Up: GDB Files

ファイルを指定するコマンド
==========================

実行ファイルやコア・ダンプ・ファイルの名前を指定したい場合があります。こ
れは通常、GDBの起動コマンドへの引数を利用して、起動時に行います（*Note
Getting In and Out of GDB: Invocation.）。

ときには、GDBのセッション中に、異なるファイルに切り替える必要がでてくる
ことがあります。あるいは、GDBを起動するときに、使いたいファイルの名前を
指定するのを忘れたということもあるかもしれません。このような場合に、新し
いファイルを指定する GDBコマンドが便利です。

`file FILENAME'
     FILENAMEで指定されるプログラムをデバッグ対象にします。そのプログラ
     ムは、シンボル情報とメモリ内容を獲得するために読み込まれます。また、
     ユーザが`run'コマンドを使用したときに実行されます。ユーザがディレク
     トリを指定せず、そのファイルが GDBの作業ディレクトリに見つからない
     場合、シェルが実行すべきファイルを探すときと同様、GDBは、ファイルを
     探すべきディレクトリのリストとして環境変数`PATH'の値を使用します。
     `path'コマンドによって、GDB、ユーザ・プログラムの両方について、この
     変数の値を変更することができます。

     ファイルをメモリにマップすることのできるシステムでは、補助的なファ
     イル`FILENAME.syms'に、ファイルFILENAMEのシンボル・テーブル情報が格
     納されることがあります。このような場合、GDBは、`FILENAME.syms'とい
     うファイルからシンボル・テーブルをメモリ上にマップすることで、起動
     に要する時間を短くします。詳細については、（以下に説明する`file'コ
     マンド、`symbol-file'コマンド、`add-symbol-file'コマンドを実行する
     際にコマンドライン上で使用可能な）ファイル・オプションの`-mapped'、
     `-readnow'の説明を参照してください。

`file'
     `file'コマンドを引数なしで実行すると、GDBは実行ファイル、シンボル・
     テーブルに関して保持している情報をすべて破棄します。

`exec-file [ FILENAME ]'
     実行するプログラムがFILENAMEで指定されるファイル内に存在する（ただ
     し、シンボル・テーブルはそこには存在しない）ということを指定します。
     GDBは、必要であれば、ユーザ・プログラムの存在場所を見つけるために、
     環境変数`PATH'を使用します。FILENAMEを指定しないと、実行ファイルに
     関して保持している情報を破棄するよう指示したことになります。

`symbol-file [ FILENAME ]'
     FILENAMEで指定されるファイルからシンボル・テーブル情報を読み込みま
     す。必要な場合には`PATH'が検索されます。同一のファイルから、シンボ
     ル・テーブルと実行プログラムの両方を獲得する場合には、`file'コマン
     ドを使用してください。

     `symbol-file'を引数なしで実行すると、GDBがユーザ・プログラムのシン
     ボル・テーブルに関して持っている情報は消去されます。

     `symbol-file'コマンドが実行されると、それまで GDBが保持していたコン
     ビニエンス変数、値ヒストリ、すべてのブレイクポイント、自動表示式は
     破棄されます。その理由は、これらの情報の中に、GDBが破棄した古いシン
     ボル・テーブルのデータの一部である、シンボルやデータ型を記録する内
     部データへのポインタが含まれているかもしれないからです。

     `symbol-file'を一度実行した後にRETキーを押しても、`symbol-file'の実
     行は繰り返されません。

      GDBは、特定の環境用に構成されると、その環境において生成される標準
     フォーマットのデバッグ情報を理解するようになります。GNUコンパイラを
     使うこともできますし、ローカルな環境の規約に従う他のコンパイラを使
     用することもできます。通常は、GNUコンパイラを使用しているときに最高
     の結果を引き出すことができます。例えば` gcc'を使用すると、最適化さ
     れたコードに対してデバッグ情報を生成することができます。

     COFFを使用する古いSVR3システムを除外すれば、ほとんどの種類のオブジェ
     クト・ファイルでは、`symbol-file'コマンドを実行しても、通常は、ただ
     ちにシンボル・テーブルの全体が読み込まれるわけではありません。実際
     に存在するソース・ファイルとシンボルを知るために、シンボル・テーブ
     ルを素早く調べるだけです。詳細な情報は、後にそれが必要になったとき
     に、一度に1ソース・ファイルずつ読み込まれます。

     2段階に分けて読み込むという手法は、GDBの起動時間の短縮を目的として
     います。ほとんどの場合、このような手法が採用されているということに
     気付くことはありません。せいぜい、特定のソース・ファイルに関するシ
     ンボル・テーブルの詳細が読み込まれている間、たまに停止するくらいで
     す（もしそうしたいのであれば、`set verbose'コマンドを使うことによっ
     て、このようにして停止しているときにはメッセージを表示させることも
     できます。*Note Optional warnings and messages: Messages/Warnings）。

     COFFについては、まだこの2段階方式を実装していません。シンボル・テー
     ブルがCOFFフォーマットで格納されている場合、`symbol-file'コマンドは
     シンボル・テーブル・データの全体をただちに読み込みます。COFFのstabs
     拡張フォーマット（stabs-in-COFF）では、デバッグ情報が実際にはstabs
     フォーマットの内部に存在するため、2段階方式が実装されていることに注
     意してください。

`symbol-file FILENAME [ -readnow ] [ -mapped ]'
`file FILENAME [ -readnow ] [ -mapped ]'
      GDBが確実にシンボル・テーブル全体を保持しているようにしたいのであ
     れば、シンボル・テーブル情報を読み込む任意のコマンド実行時に
     `-readnow'オプションを使用することで、2段階によるシンボル・テーブル
     読み込み方式を使わないようにさせることができます。

     `mmap'システム・コールによるファイルのメモリへのマッピングがシステ
     ム上において有効な場合、もう1つのオプション`-mapped'を使って、GDBに
     対して、再利用可能なファイルの中にユーザ・プログラムのシンボルを書
     き込ませることができます。後の GDBデバッグ・セッションは、（プログ
     ラムに変更がない場合）実行プログラムからシンボル・テーブルを読み込
     むのに時間を費やすことなく、この補助シンボル・ファイルからシンボル
     情報をマップします。`-mapped'オプションを使用することは、コマンドラ
     イン・オプション`-mapped'を指定して GDBを起動するのと同じ効果を持ち
     ます。

     補助シンボル・ファイルがユーザ・プログラムのシンボル情報をすべて確
     実に持つように、両方のオプションを同時に指定することもできます。

     MYPROGという名前のプログラムの補助シンボル・ファイルは、
     `MYPROG.syms'という名前になります。このファイルが存在すると、（それ
     が、対応する実行ファイルよりも新しい限り）ユーザがMYPROGをデバッグ
     しようとすると、GDBは常にそのファイルを使おうとします。特別なオプショ
     ンやコマンドは必要ありません。

     `.syms'ファイルは、GDBを実行したホスト・マシンに固有のものです。そ
     れは、GDB内部におけるシンボル・テーブルの正確なイメージを保持してい
     ます。複数のホスト・プラットフォーム間で共用することはできません。


`core-file [ FILENAME ]'
     「メモリ上のイメージ」として使用されるコア・ダンプ・ファイルの存在
     場所を指定します。伝統的に、コア・ファイルは、それを生成したプロセ
     スのアドレス空間の一部だけを保持しています。GDBは、実行ファイルその
     ものにアクセスすることによって、保持されていない部分を獲得すること
     ができます。

     `core-file'を引数なしで実行すると、コア・ファイルを一切使用しないこ
     とを指定したことになります。

     ユーザ・プログラムが実際に GDBの管理下で実行中の場合は、コア・ファ
     イルは無視されることに注意してください。したがって、ある時点までユー
     ザ・プログラムを実行させた後に、コア・ファイルをデバッグしたくなっ
     たような場合、プログラムを実行しているサブ・プロセスを終了させなけ
     ればなりません。サブ・プロセスの終了は、`kill'コマンドで行います
     （*Note Killing the child process: Kill Process.）。

`add-symbol-file FILENAME ADDRESS'
`add-symbol-file FILENAME ADDRESS [ -readnow ] [ -mapped ]'
     `add-symbol-file'コマンドは、FILENAMEで指定されるファイルから追加的
     なシンボル・テーブル情報を読み込みます。FILENAMEで指定されるファイ
     ルが（何か別の方法によって）実行中のプログラムの中に動的にロードさ
     れた場合に、このコマンドを使用します。ADDRESSは、ファイルがロードさ
     れたメモリ・アドレスでなければなりません。GDBは独力でこのアドレスを
     知ることはできません。ADDRESSは式として指定することもできます。

     FILENAMEで指定されるファイルのシンボル・テーブルは、もともと
     `symbol-file'コマンドによって読み込まれたシンボル・テーブルに追加さ
     れます。`add-symbol-file'コマンドは何回でも使用することができます。
     新たに読み込まれたシンボル・テーブルのデータは、古いデータに追加さ
     れていきます。古いシンボル・データをすべて破棄するには、
     `symbol-file'コマンドを使用してください。

     `add-symbol-file'コマンドを実行した後にRETキーを押しても、
     `add-symbol-file'コマンドは繰り返し実行されません。

     `symbol-file'コマンドと同様、`-mapped'オプションと`-readnow'オプショ
     ン使用して、FILENAMEで指定されるファイルのシンボル・テーブル情報を 
     GDBがどのように管理するかを変更することができます。

`add-shared-symbol-file'
     `add-shared-symbol-file'コマンドは、Motorola 88k用のHarris' CXUXオ
     ペレーティング・システム上でのみ使用することができます。GDBは自動的
     に共有ライブラリを探しますが、GDBがユーザの共有ライブラリを見つけて
     くれない場合には、`add-shared-symbol-file'コマンドを実行できます。
     このコマンドは引数を取りません。

`section'
     `section'コマンドは、実行ファイルのSECTIONセクションのベース・アド
     レスをADDRに変更します。これは、（a.outフォーマットのように）実行ファ
     イルがセクション・アドレスを保持していない場合や、ファイルの中で指
     定されているアドレスが誤っている場合に使うことができます。個々のセ
     クションは、個別に変更されなければなりません。`info files'コマンド
     によって、すべてのセクションとそのアドレスを一覧表示することができ
     ます。

`info files'
`info target'
     `info files'と`info target'は同義です。両方とも、カレント・ターゲッ
     ト（*Note Specifying a Debugging Target: Targets.）に関する情報を表
     示します。表示される情報には、GDBが現在使用中の実行ファイルやコア・
     ダンプ・ファイルの名前、シンボルがそこからロードされたファイルの名
     前を含みます。`help target'コマンドは、カレントなターゲットではなく、
     すべての可能なターゲットを一覧表示します。

ファイルを指定するすべてのコマンドは、引数として、絶対パスによるファイル
名と相対パスによるファイル名のどちらでも受け付けます。GDBは、常にファイ
ル名を絶対パス名に変換して、絶対パスの形で記憶します。

 GDBは、HP-UX、SunOS、SVr4、Irix 5、IBM RS/6000の共有ライブラリをサポー
トします。ユーザが`run'コマンドを実行したり、コア・ファイルを調べようと
すると、GDBは自動的に共有ライブラリからシンボル定義をロードします（ユー
ザが`run'コマンドを発行するまでは、共有ライブラリ内部の関数への参照があっ
ても、GDBにはそれを理解することができません。コア・ファイルをデバッグし
ている場合は、この限りではありません）。

`info share'
`info sharedlibrary'
     現在ロードされている共有ライブラリの名前を表示します。

`sharedlibrary REGEX'
`share REGEX'

     UNIXの正規表現にマッチするファイルに対応する、共有オブジェクト・ラ
     イブラリのシンボルをロードします。自動的にロードされるファイルと同
     様、ユーザ・プログラムによってコア・ファイルのために必要とされる共
     有ライブラリ、または`run'コマンド実行時に必要とされる共有ライブラリ
     だけがロードされます。REGEXが省略されると、ユーザ・プログラムによっ
     て必要とされるすべての共有ライブラリがロードされます。





File: gdb-ja.info, Node: Symbol Errors, Prev: Files, Up: GDB Files

シンボル・ファイル読み込み時のエラー
====================================

シンボル・ファイルの読み込み中に、GDBはときどき問題にぶつかることがあり
ます。例えば、認識できないシンボル・タイプを見つけたり、コンパイラの出力
に既知の問題を発見することがあります。デフォルトでは、このようなエラーが
あったことを、GDBはユーザに知らせません。なぜなら、このようなエラーは比
較的よく見られるものであり、コンパイラのデバッグをしているような人々だけ
が関心を持つようなものだからです。もし、正しく構築されていないシンボル・
テーブルに関する情報を見ることに関心があれば、`set complaints'コマンドを
使用することで、何回問題が発生しようと個々のタイプの問題について1回だけ
メッセージを出力するよう指示することができますし、また、何回問題発生した
かを見るためにより多くのメッセージを表示するよう指示することもできます
（*Note Optional warnings and messages: Messages/Warnings.）。

現在のバージョンで表示されるメッセージとその意味を以下に記します。

`inner block not inside outer block in SYMBOL'

     シンボル情報は、シンボルのスコープの先頭と末尾の位置を示します（例
     えば、ある関数の先頭、あるいは、ブロックの先頭など）。このエラーは、
     内側のスコープのブロックが、外側のスコープのブロックに完全に包含さ
     れていないことを意味しています。

      GDBは、内側のブロックが外側のブロックと同一のスコープを持つものと
     して扱うことで、この問題を回避します。外側のブロックが関数でない場
     合には、エラー・メッセージのSYMBOLの部分が``(don't know)''のように
     表示されることがあります。

`block at ADDRESS out of order'

     シンボルのスコープとなるブロックに関する情報は、アドレスの低い方か
     ら昇順に並んでいなければなりません。このエラーは、そうなっていない
     ということを示しています。

      GDBはこの問題を回避することはせず、読み込もうとしているソース・ファ
     イルのシンボルを見つけるのに支障が出ます（`set verbose on'を指定す
     ることで、どのソース・ファイルが関係しているかを知ることができます。
     *Note Optional warnings and messages: Messages/Warnings）。

`bad block start address patched'

     シンボルのスコープとなるブロックに関する情報の中の開始アドレスが、1
     つ前のソース行のアドレスより小さい値です。これは、SunOS 4.1.1 （お
     よび、それ以前のバージョン）のCコンパイラで発生することが分かってい
     ます。

      GDBは、シンボルのスコープとなるブロックが1つ前のソース行から始まる
     ものとして扱うことによって、この問題を回避します。

`bad string table offset in symbol N'

     シンボル番号Nのシンボルが持っている文字列テーブルへのポインタが、文
     字列テーブルのサイズを超える値です。

      GDBは、このシンボルが`foo'という名前を持つものとみなすことによって、
     この問題を回避します。この結果、多くのシンボルが`foo'という名前を持
     つことになってしまうと、他の問題が発生する可能性があります。

`unknown symbol type `0xNN''

     シンボル情報の中に、どのようにして読み取ればよいのか GDBには分から
     ないような、新しいデータ型が含まれています。`0xNN'は理解できなかっ
     たシンボルの型を16進数で表わしたものです。

      GDBは、このようなシンボル情報を無視することによって、このエラーを
     回避します。通常、プログラムのデバッグを行うことは可能になりますが、
     ある特定のシンボルにアクセスすることができなくなります。このような
     問題にぶつかり、それをデバッグしたいのであれば、` gdb'自身を使って`
     gdb'をデバッグすることができます。この場合、シンボル`complain'にブ
     レイクポイントを設定し、関数`read_dbx_symtab'まで実行してから、
     `*bufp'によってシンボルを参照します。

`stub type has NULL name'
      GDBは、ある構造体またはクラスに関する完全な定義を見つけることがで
     きませんでした。

`const/volatile indicator missing (ok if using g++ v1.x), got...'

     あるC++のメンバ関数に関するシンボル情報に、より新しいコンパイラを使
     用した場合には生成されるいくつかの情報が欠けています。

`info mismatch between compiler and debugger'

      GDBは、コンパイラが生成した型の指定を解析できませんでした。



File: gdb-ja.info, Node: Targets, Next: Controlling GDB, Prev: GDB Files, Up: Top

デバッグ・ターゲットの指定
**************************

"ターゲット"とは、ユーザ・プログラムが持つ実行環境を指します。多くの場合、
GDBはユーザ・プログラムと同一のホスト環境上で実行されます。この場合には、
`file'コマンドや`core'コマンドを実行すると、その副作用としてデバッグ・ター
ゲットが指定されます。例えば、物理的に離れた位置にあるホスト・マシン上で 
GDBを実行したい場合や、シリアル・ポート経由でスタンドアロン・システムを
制御したい場合、または、TCP/IP接続を利用してリアルタイム・システムを制御
したい場合などのように、より多くの柔軟性が必要とされる場合、`target'コマ
ンドを使うことによって、GDBに設定されたターゲットの種類の中から1つを指定
することができます（*Note Commands for managing targets: Target
Commands.）。

* Menu:

* Active Targets::              アクティブ・ターゲット
* Target Commands::             ターゲットを管理するコマンド
* Byte Order::                  ターゲットのバイト・オーダの選択
* Remote::                      リモート・デバッグ




File: gdb-ja.info, Node: Active Targets, Next: Target Commands, Prev: Targets, Up: Targets

アクティブ・ターゲット
======================

ターゲットには3つのクラスがあります。プロセス、コア・ファイル、そして、
実行ファイルです。GDBは同時に、1クラスにつき1つ、全体で最高で3つまでアク
ティブなターゲットを持つことができます。これにより、（例えば）コア・ファ
イルに対して行ったデバッグ作業を破棄することなく、プロセスを起動してその
動作を調べることができます。

例えば、`gdb a.out'を実行すると、実行ファイル`a.out'が唯一のアクティブな
ターゲットになります。コア・ファイル（おそらくは、前回実行したときにクラッ
シュしてコア・ダンプしたもの）を併せて指定すると、GDBは2つのターゲットを
持ち、メモリ・アドレスを知る必要がある場合には、それを知るために2つのター
ゲットを並行して使用します。この場合、まずコア・ファイルを参照し、次に実
行ファイルを参照します。（典型的には、これら2つのクラスのターゲットは相
互に補完的です。というのも、コア・ファイルには、プログラムが持っている変
数などの読み書き可能なメモリ域の内容とマシン・ステータスだけがあり、実行
ファイルには、プログラムのテキストと初期化されたデータだけがあるからで
す）。

`run'コマンドを実行すると、ユーザの実行ファイルはアクティブなプロセス・
ターゲットにもなります。プロセス・ターゲットがアクティブな間は、メモリ・
アドレスを要求するすべての GDBコマンドは、プロセス・ターゲットを参照しま
す。アクティブなコア・ファイル・ターゲットや実行ファイル・ターゲットの中
のアドレスは、プロセス・ターゲットがアクティブな間は、隠された状態になり
ます。

新しいコア・ファイル・ターゲットや実行ファイル・ターゲットを選択するには、
`core-file'コマンドや`exec-file'コマンドを使用します（*Note Commands to
specify files: Files.）。既に実行中のプロセスをターゲットとして指定する
には、`attach'コマンドを使用します（*Note Debugging an already-running
process: Attach.）。



File: gdb-ja.info, Node: Target Commands, Next: Byte Order, Prev: Active Targets, Up: Targets

ターゲットを管理するコマンド
============================

`target TYPE PARAMETERS'
      GDBのホスト環境をターゲット・マシンまたはターゲット・プロセスに接
     続します。ターゲットとは、典型的には、デバッグ機能と通信するための
     プロトコルを指します。引数TYPEによって、ターゲット・マシンの種類ま
     たはプロトコルを指定します。

     PARAMETERSはターゲット・プロトコルによって解釈されるものですが、典
     型的には、接続すべきデバイス名やホスト名、プロセス番号、ボーレート
     などが含まれます。

     `target'コマンドを実行した後にRETキーを押しても、`target'コマンドは
     再実行されません。

`help target'
     利用可能なすべてのターゲットの名前を表示します。現在選択されている
     ターゲットを表示させるには、`info target'コマンドまたは`info files'
     コマンドを使用します（*Note Commands to specify files: Files.）。

`help target NAME'
     ある特定のターゲットに関する説明を表示します。選択時に必要となるパ
     ラメータも表示されます。

`set gnutarget ARGS'
      GDBは、自分で持っているライブラリBFDを使用してユーザ・ファイルを読
     み込みます。GDBは、"実行ファイル"、"コア・ファイル"、".oファイル"の
     どれを自分が読み込んでいるのかを知っています。しかし、`set
     gnutarget'コマンドを使用して、ファイルのフォーマットを指定すること
     もできます。ほとんどの`target'コマンドとは異なり、`gnutarget'におけ
     る`target'は、マシンではなくプログラムです。

     *注意:* `set gnutarget'でファイル・フォーマットを指定するには、実際
     のBFD名を知っている必要があります。

     *Note Commands to specify files: Files。

`show gnutarget'
     `gnutarget'がどのようなファイル・フォーマットを読むよう設定されてい
     るかを表示させるには、`show gnutarget'コマンドを使用します。
     `gnutarget'を設定していない場合、個々のファイルのフォーマットを GDB
     が自動的に決定します。この場合、`show gnutarget'を実行すると`The
     current BDF target is "auto"' と表示されます。

以下に、一般的なターゲットをいくつか示します（GDBの構成によって、利用可
能であったり利用不可であったりします）。

`target exec PROGRAM'
     実行ファイルです。`target exec PROGRAM'は`exec-file PROGRAM'と同じ
     です。

`target core FILENAME'
     コア・ダンプ・ファイルです。`target core FILENAME'は`core-file
     FILENAME'と同じです。

`target remote DEV'
      GDB固有のプロトコルによる、リモートのシリアル・ターゲットです。引
     数DEVによって、接続を確立するために使用するシリアル装置（例えば、
     `/dev/ttya'）を指定します。*Note Remote debugging: Remote。`target
     remote'は、`load'コマンドもサポートするようになりました。これは、ス
     タブをターゲット・システム上に持っていく方法が別にあり、かつ、ダウ
     ンロードが実行されたときに破壊されないようなメモリ域にそれを置くこ
     とができる場合にのみ役に立ちます。

`target sim'
     CPUシミュレータです。*Note Simulated CPU Target: Simulator。

以下のターゲットはすべて、特定のCPUに固有のものであり、特定の構成におい
てのみ利用可能です。


`target abug DEV'
     M68K用のABug ROMモニタです。

`target adapt DEV'
     A29K用のAdaptモニタです。

`target amd-eb DEV SPEED PROG'
     シリアル回線により接続されている、リモートのPCに組み込まれたAMD
     EB29Kボードです。`target remote'の場合と同様、DEVはシリアル装置です。
     SPEEDによって回線速度を指定することができます。PROGは、デバッグ対象
     となるプログラムをPC上のDOSから見た場合の名前です。*Note The EBMON
     protocol for AMD29K: EB29K Remote。

`target array DEV'
     Array Tech LSI33K RAIDコントローラ・ボードです。

`target bug DEV'
     MVME187（m88k）ボード上で動作するBUGモニタです。

`target cpu32bug DEV'
     CPU32（M68K）ボード上で動作するCPU32BUGモニタです。

`target dbug DEV'
     Motorola ColdFire用のdBUG ROMモニタです。

`target ddb DEV'
     Mips Vr4300用のNEC DDBモニタです。

`target dink32 DEV'
     PowerPC用のDINK32 ROMモニタです。

`target e7000 DEV'
     日立H8、SH用のE7000エミュレータです。

`target es1800 DEV'
     M68K用のES-1800エミュレータです。

`target est DEV'
     CPU32（M68K）ボード上で動作するEST-300 ICEモニタです。

`target hms DEV'
     ユーザのホストにシリアル回線で接続された日立のSH、H8/300、H8/500ボー
     ドです。特別なコマンドである`device'と`speed'によって、使用されるシ
     リアル回線と通信速度を制御します。*Note GDB and Hitachi
     Microprocessors: Hitachi Remote。

`target lsi DEV'
     Mips用のLSI ROMモニタです。

`target m32r DEV'
     三菱M32R/D ROMモニタです。

`target mips DEV'
     Mips用のIDT/SIM ROMモニタです。

`target mon960 DEV'
     Intel i960用のMON960モニタです。

`target nindy DEVICENAME'
     Nindy Monitorにより制御されるIntel 960ボードです。DEVICENAMEは、接
     続に使用するシリアル装置の名前です。例えば`/dev/ttya'です。*Note
     GDB with a remote i960 (Nindy): i960-Nindy Remote。

`target nrom DEV'
     NetROM ROMエミュレータです。このターゲットは、ダウンロードのみサポー
     トしています。

`target op50n DEV'
     OKI HPPAボード上で動作するOP50Nモニタです。

`target pmon DEV'
     Mips用のPMON ROMモニタです。

`target ppcbug DEV'
`target ppcbug1 DEV'
     PowerPC用のPPCBUG ROMモニタです。

`target r3900 DEV'
     東芝R3900 Mips用のDensan DVE-R3900 ROMモニタです。

`target rdi DEV'
     RDIライブラリ・インターフェイスを経由したARM Angelモニタです。
 
`target rdp DEV'
     ARM Demonモニタです。

`target rom68k DEV'
     M68K IDPボード上で動作するROM 68Kモニタです。

`target rombug DEV'
     OS/9000用のROMBUG ROMモニタです。

`target sds DEV'
     （MotorolaのADSなどの）PowerPCボード上で動作するSDSモニタです。

`target sparclite DEV'
     ロードするためだけの目的で使用される、富士通のsparcliteボードです。
     プログラムをデバッグするためには、さらに別のコマンドを使用しなけれ
     ばなりません。一例を挙げると、GDBの標準的なリモート・プロトコルを使
     用するtarget remote DEVです。

`target sh3 DEV'
`target sh3e DEV'
     日立SH-3、SH-3Eターゲット・システムです。

`target st2000 DEV SPEED'
     Tandem STDBUGプロトコルを実行しているTandem ST2000電話交換機です。
     DEVは、ST2000のシリアル回線に接続されている装置の名前です。SPEEDは
     通信回線の速度です。GDBがST2000にTCPまたはTelnetで接続するよう構成
     されている場合、引数は使用されません。*Note GDB with a Tandem
     ST2000: ST2000 Remote。

`target udi KEYWORD'
     AMD UDIプロトコルを使用するRemote AMD29Kターゲットです。引数KEYWORD
     が、使用する29Kボードまたはシミュレータを指定します。*Note The UDI
     protocol for AMD29K: UDI29K Remote。

`target vxworks MACHINENAME'
     TCP/IPで接続されたVxWorksシステムです。引数MACHINENAMEは、ターゲッ
     ト・システムのマシン名またはIPアドレスです。*Note GDB and VxWorks:
     VxWorks Remote。

`target w89k DEV'
     Winbond HPPAボード上で動作するW89Kモニタです。


 GDBの構成によって、利用可能なターゲットも異なるものになります。構成次第
で、ターゲットの数は多くなったり少なくなったりします。

多くのリモート・ターゲットでは、接続に成功すると、実行プログラムのコード
をダウンロードすることが必要となります。


`load FILENAME'
     構成によって GDBに組み込まれたリモート・デバッグ機能によっては、
     `load'コマンドが使用可能になります。これが利用可能な場合、実行ファ
     イルFILENAMEが（例えば、ダウンロードやダイナミック・リンクによって）
     リモート・システム上でデバッグできるようになることを意味します。ま
     た、`load'コマンドは`add-symbol-file'コマンドと同様、ファイル
     FILENAMEのシンボル・テーブルを GDB内に記録します。

      GDBが`load'コマンドを提供していない場合、それを実行しようとすると
     「`You can't do that when your target is ...'」というエラー・メッセー
     ジが表示されます。

     実行ファイルの中で指定されたアドレスに、ファイルはロードされます。
     オブジェクト・ファイルのフォーマットによっては、プログラムをリンク
     するときに、ファイルをロードするアドレスを指定できるものもあります。
     これ以外のフォーマット（例えば、a.out）では、オブジェクト・ファイル
     のフォーマットによって固定的にアドレスが指定されます。

     VxWorksで`load'コマンドを実行すると、FILENAMEで指定される実行ファイ
     ルがカレントなターゲット・システム上で動的にリンクされ、シンボルが 
     GDBに追加されます。

     Intel 960ボードのNindyインターフェイスでは、`load'コマンドは
     FILENAMEで指定されるファイルを960側にダウンロードし、そのシンボルを 
     GDBに追加します。

     日立のSH、H8/300、H8/500ボード（*Note GDB and Hitachi
     Microprocessors: Hitachi Remote.）に対するリモート・デバッグを選択
     すると、`load'コマンドはユーザ・プログラムを日立ボードにダウンロー
     ドし、（`file'コマンドと同様）ユーザのホスト・マシン上の GDBのカレ
     ントなターゲット実行ファイルとしてオープンします。

     `load'コマンドを実行した後にRETキーを押しても、`load'コマンドは繰り
     返し実行されません。



File: gdb-ja.info, Node: Byte Order, Next: Remote, Prev: Target Commands, Up: Targets

ターゲットのバイト・オーダの選択
================================

MIPS、PowerPC、Hitachi SHなどのプロセッサは、ビッグ・エンディアン、リト
ル・エンディアンのどちらのバイト・オーダでも実行することができます。通常
は、実行ファイルまたはシンボルの中に、エンディアン種別を指定するビットが
あるので、どちらを使用するかを気にする必要はありません。しかし、GDBの認
識しているプロセッサのエンディアン種別を手作業で調整することができれば、
便利なこともあるでしょう。

`set endian big'
      GDBに対して、ターゲットはビッグ・エンディアンであると想定するよう
     指示します。

`set endian little'
      GDBに対して、ターゲットはリトル・エンディアンであると想定するよう
     指示します。

`set endian auto'
      GDBに対して、実行ファイルに関連付けされているバイト・オーダを使用
     するよう指示します。

`show endian'
      GDBが認識している、ターゲットの現在のバイト・オーダ種別を表示しま
     す。


これらのコマンドは、ホスト上でのシンボリック・データの解釈を調整するだけ
であり、ターゲット・システムに対しては全く何の影響も持たないということに
注意してください。



File: gdb-ja.info, Node: Remote, Prev: Byte Order, Up: Targets

リモート・デバッグ
==================

通常の方法で GDBを実行させることのできないマシン上で実行中のプログラムを
デバッグするには、リモート・デバッグ機能を使うのが便利です。例えば、オペ
レーティング・システムのカーネルのデバッグや、フル機能を持つデバッガを実
行するのに十分な機能を持つ汎用的なオペレーティング・システムを持たない小
規模なシステムでのデバッグでは、ユーザはリモート・デバッグ機能を使うこと
になるかもしれません。

 GDBは、その構成によっては、特別なシリアル・インターフェイスやTCP/IPイン
ターフェイスを持ち、これを特定のデバッグ・ターゲット用に使用することがで
きます。さらに、GDBには汎用的なシリアル・プロトコルが組み込まれており
（ GDB固有のもので、特定のターゲット・システムに固有なものではありませ
ん）、リモート・スタブを作成すれば、これを使用することができます。リモー
ト・スタブとは、GDBと通信するためにリモート・システム上で動作するコード
です。

 GDBの構成によっては、他のリモート・ターゲットが利用可能な場合もあります。
利用可能なリモート・ターゲットを一覧表示させるには、`help target'コマン
ドを使用します。

* Menu:

* Remote Serial::                GDBリモート・シリアル・プロトコル
* i960-Nindy Remote::		 GDBとリモートi960（Nindy）
* UDI29K Remote::               AMD29K用のUDIプロトコル
* EB29K Remote::		AMD29K用のEBMONプロトコル
* VxWorks Remote::		 GDBとVxWorks
* ST2000 Remote::                GDBとTandem ST2000
* Hitachi Remote::               GDBと日立のマイクロ・プロセッサ
* MIPS Remote::			 GDBとMIPSボード
* Sparclet Remote::              GDBとSparcletボード
* Simulator::                   シミュレートされたCPUターゲット





File: gdb-ja.info, Node: Remote Serial

 GDBリモート・シリアル・プロトコル
----------------------------------

他のマシン上で実行中のプログラムをデバッグするには（"ターゲット"・マシン
をデバッグするには）、そのプログラムを単独で実行するために通常必要となる
事前条件をすべて整える必要があります。例えば、Cのプログラムの場合、

  1. Cの実行環境をセットアップするためのスタートアップ・ルーチンが必要で
     す。これは通常`crt0'のような名前を持っています。スタートアップ・ルー
     チンは、ハードウェアの供給元から提供されることもありますし、ユーザ
     が自分で書かなければならないこともあります。

  2. ユーザ・プログラムからのサブルーチン呼び出しをサポートするために、
     入出力の管理などを行うCのサブルーチン・ライブラリが必要になるかもし
     れません。

  3. ユーザ・プログラムを他のマシンに持っていく手段、例えばダウンロード・
     プログラムが必要です。これはハードウェアの供給元から提供されること
     が多いのですが、ハードウェアのドキュメントをもとにユーザが自分で作
     成しなければならないこともあります。

次に、ユーザ・プログラムがシリアル・ポートを使って、 GDBを実行中のマシン
（"ホスト"・マシン）と通信できるように準備します。一般的には、以下のよう
な形になります。

*ホスト上では：*
      GDBは既にこのプロトコルの使い方を理解しています。他の設定がすべて
     終了した後、単に`target remote'コマンドを使用するだけです（*Note
     Specifying a Debugging Target: Targets.）。

*ターゲット上では：*
     ユーザ・プログラムに、GDBリモート・シリアル・プロトコルを実装した特
     別なサブルーチンをいくつかリンクする必要があります。これらのサブルー
     チンを含むファイルは、"デバッグ・スタブ"と呼ばれます。

     特定のリモート・ターゲットでは、ユーザ・プログラムにスタブをリンク
     する代わりに、`gdbserver'という補助プログラムを使うこともできます。
     詳細については、*Note Using the `gdbserver' program: Server。

デバッグ・スタブはリモート・マシンのアーキテクチャに固有のものです。例え
ば、SPARCボード上のプログラムをデバッグするには`sparc-stub.c'を使います。

以下に実際に使えるスタブを列挙します。これらは、GDBとともに配布されてい
ます。


`i386-stub.c'
     Intel 386アーキテクチャ、およびその互換アーキテクチャ用です。

`m68k-stub.c'
     Motorola 680x0アーキテクチャ用です。

`sh-stub.c'
     日立SHアーキテクチャ用です。

`sparc-stub.c'
     SPARCアーキテクチャ用です。

`sparcl-stub.c'
     富士通SPARCLITEアーキテクチャ用です。


 GDBとともに配布されるREADMEファイルには、新しく追加された他のスタブのこ
とが記されているかもしれません。

* Menu:

* Stub Contents::       スタブの提供する機能
* Bootstrapping::       スタブに対する必須作業
* Debug Session::       ここまでのまとめ
* Protocol::            通信プロトコルの概略
* Server::		gdbserverプログラムの使用
* NetWare::		gdbserve.nlmプログラムの使用



File: gdb-ja.info, Node: Stub Contents

スタブの提供する機能
....................

各アーキテクチャ用のデバッグ・スタブは、3つのサブルーチンを提供します。

`set_debug_traps'
     このルーチンは、ユーザ・プログラムが停止したときに
     `handle_exception'が実行されるよう設定します。ユーザ・プログラムは、
     その先頭付近でこのサブルーチンを明示的に呼び出さなければなりません。

`handle_exception'
     これが中心的な仕事をする部分ですが、ユーザ・プログラムはこれを明示
     的には呼び出しません。セットアップ・コードによって、トラップが発生
     したときに`handle_exception'が実行されるよう設定されます。

     ユーザ・プログラムが実行中に（例えば、ブレイクポイントで）停止する
     と、`handle_exception'が制御権を獲得し、ホスト・マシン上の GDBとの
     通信を行います。これが、通信プロトコルが実装されている部分です。
     `handle_exception'は、ターゲット・マシン上で GDBの代理として機能し
     ます。それはまず、ユーザ・プログラムの状態に関する情報を要約して送
     ることから始めます。次に、GDBが必要とする情報を入手して転送する処理
     を継続します。これは、ユーザ・プログラムの実行を再開させるような 
     GDBコマンドが実行されるまで続きます。そのようなコマンドが実行される
     と、`handle_exception'は、制御をターゲット・マシン上のユーザ・コー
     ドに戻します。

`breakpoint'
     ユーザ・プログラムにブレイクポイントを持たせるには、この補助的なサ
     ブルーチンを使います。特定の状況においては、これが GDBが制御を獲得
     する唯一の方法です。例えば、ユーザのターゲット・マシンに割り込みを
     発生させるボタンのようなものがあれば、このサブルーチンを呼び出す必
     要はありません。割り込みボタンを押すことで、制御は
     `handle_exception'に、つまり事実上 GDBに渡されます。マシンによって
     は、シリアル・ポートから文字を受け取るだけでトラップが発生すること
     もあります。このような場合には、ユーザ・プログラム自身から
     `breakpoint'を呼び出す必要はなく、ホストの GDBセッションから`target
     remote'を実行するだけで制御を得ることができます。

     これらのどのケースにも該当しない場合、あるいは、デバッグ・セッショ
     ンの開始箇所としてあらかじめ決めてあるところでユーザ・プログラムが
     停止することを単に確実にしたいのであれば、`breakpoint'を呼び出して
     ください。



File: gdb-ja.info, Node: Bootstrapping

スタブに対する必須作業
......................

 GDBとともに配布されるデバッグ用スタブは、特定のチップのアーキテクチャ用
にセットアップされたものですが、デバッグのターゲット・マシンに関してそれ
以外の情報は持っていません。

まず最初に、どのようにしてシリアル・ポートと通信するかをスタブに教えてや
る必要があります。

`int getDebugChar()'
     シリアル・ポートから単一文字を読み込むサブルーチンとしてこれを書き
     ます。これは、ターゲット・システム上の`getchar'と同一かもしれません。
     これら2つを区別したい場合を考慮して、異なる名前が使われています。

`void putDebugChar(int)'
     シリアル・ポートに単一文字を書き込むサブルーチンとしてこれを書きま
     す。これは、ターゲット・システム上の`putchar'と同一かもしれません。
     これら2つを区別したい場合を考慮して、異なる名前が使われています。

実行中のユーザ・プログラムを GDBが停止できるようにしたいのであれば、割り
込み駆動型のシリアル・ドライバを使用して、`^C' （control-C文字、すなわち
`\003'）を受信したときに停止するよう設定する必要があります。GDBはこの文
字を使って、リモート・システムに対して停止するよう通知します。

デバッグ・ターゲットが適切なステータス情報を GDBに対して返せるようにする
ためには、おそらく標準のスタブを変更する必要があるでしょう。最も美しくな
く、しかし最も手っ取り早くこれを実現する方法は、ブレイクポイント命令を実
行することです（この方法が「美しくない」のは、GDBが`SIGINT'ではなく
`SIGTRAP'を報告してくる点にあります）。

ユーザが提供する必要のあるルーチンには、ほかに以下のようなものがあります。

`void exceptionHandler (int EXCEPTION_NUMBER, void *EXCEPTION_ADDRESS)'
     例外処理テーブルにEXCEPTION_ADDRESSを組み込むよう、この関数を書きま
     す。ユーザがこれを提供しなければならないのは、スタブにはターゲット・
     システム上の例外処理テーブルがどのようなものになるかを知る手段がな
     いからです（例えば、プロセッサのテーブルはROM上にあり、その中のエン
     トリがRAM上のテーブルを指す、という形になっているかもしれません）。
     EXCEPTION_NUMBER は例外番号で、これは変更される必要があります。例外
     番号の意味は、アーキテクチャに依存します（例えば、0による除算、境界
     を無視したメモリ・アクセス等は、異なる番号によって表わされるかもし
     れません）。この例外が発生したとき、制御は直接EXCEPTION_ADDRESSに渡
     されなければならず、また、プロセッサの状態（スタック、レジスタなど）
     はプロセッサ例外が発生したときの状態と同じでなければなりません。し
     たがって、EXCEPTION_ADDRESSに到達するのにジャンプ命令を使用したいの
     であれば、サブルーチン・ジャンプではなく、ただのジャンプ命令を使わ
     なければなりません。

     386では、ハンドラが実行されているときに割り込みがマスクされるよう、
     EXCEPTION_ADDRESSは割り込みゲートとして組み込まれる必要があります。
     そのゲートは特権レベル0 （最も高いレベル）でなければなりません。
     SPARC用のスタブや68k用のスタブは、`exceptionHandler'の助けを借りな
     くても自分で割り込みをマスクすることができます。

`void flush_i_cache()'
     （sparc、sparcliteのみ）ターゲット・マシンに命令キャッシュがある場
     合、それをフラッシュするようこのサブルーチンを書きます。命令キャッ
     シュがない場合には、このサブルーチンは何もしないものになるかもしれ
     ません。

     命令キャッシュを持つターゲット・マシン上の GDBは、ユーザ・プログラ
     ムが安定した状態にあることがこの関数によって保証されることを必要と
     します。

また、次のライブラリ・ルーチンが使用可能であることを確かめなければなりま
せん。

`void *memset(void *, int, int)'
     あるメモリ領域に既知の値を設定する標準ライブラリ関数`memset'です。
     フリーの`libc.a'を持っていれば、そこに`memset'があります。フリーの
     `libc.a'がなければ、`memset'をハードウェアの供給元から入手するか、
     自分で作成する必要があります。

GNU Cコンパイラを使っていないのであれば、他の標準ライブラリ・サブルーチ
ンも必要になるかもしれません。これは、スタブによっても異なりますが、一般
的にスタブは、`gcc'がインライン・コードとして生成する共通ライブラリ・サ
ブルーチンを使用する可能性があります。



File: gdb-ja.info, Node: Debug Session

ここまでのまとめ
................

要約すると、ユーザ・プログラムをデバッグする準備が整った後、以下の手順に
従わなければなりません。

  1. 下位レベルのサポート・ルーチンがあることを確認します（*Note What
     you must do for the stub: Bootstrapping.）。
          `getDebugChar', `putDebugChar',
          `flush_i_cache', `memset', `exceptionHandler'.

  2. ユーザ・プログラムの先頭付近に以下の行を挿入します。

          set_debug_traps();
          breakpoint();

  3. 680x0のスタブに限り、`exceptionHook'という変数を提供する必要があり
     ます。通常は、以下のように使います。

          void (*exceptionHook)() = 0;

     しかし、`set_debug_traps'が呼び出される前に、ユーザ・プログラム内の
     ある関数を指すようこの変数を設定すると、トラップ（例えば、バス・エ
     ラー）で停止した後に GDBが処理を継続実行するときに、その関数が呼び
     出されます。`exceptionHook'によって指される関数は、1つの引数付きで
     呼び出されます。それは、`int'型の例外番号です。

  4. ユーザ・プログラム、ターゲット・アーキテクチャ用の GDBデバッグ・ス
     タブ、サポート・サブルーチンをコンパイルしリンクします。

  5. ターゲット・マシンと GDBホストとの間がシリアル接続されていることを
     確認します。また、ホスト上のシリアル・ポートの名前を調べます。

  6. ターゲット・マシンにユーザ・プログラムをダウンロードし（あるいは、
     製造元の提供する手段によってターゲット・マシンにユーザ・プログラム
     を持っていき）、起動します。

  7. リモート・デバッグを開始するには、ホスト・マシン上で GDBを実行し、
     リモート・マシン上で実行中のプログラムを実行ファイルとして指定しま
     す。これにより、ユーザ・プログラムのシンボルとテキスト域の内容を見
     つける方法が GDBに通知されます。

     次に`target remote'コマンドを使って通信を確立します。引数には、シリ
     アル回線に接続された装置名または（通常はターゲットと接続されたシリ
     アル回線を持つ端末サーバの）TCPポートを指定することで、ターゲット・
     マシンとの通信方法を指定します。例えば、`/dev/ttyb'という名前の装置
     に接続されているシリアル回線を使うには、

          target remote /dev/ttyb

     とします。

     TCP接続を使うには、`HOST:PORT'という形式の引数を使用します。例えば、
     `manyfarms'という名前の端末サーバのポート2828に接続するには、

          target remote manyfarms:2828

     とします。

@noindent

ここまでくると、データの値の調査、変更、リモート・プログラムのステップ実
行、継続実行に通常使用するすべてのコマンドを使用することができます。

リモート・プログラムの実行を再開し、デバッグするのをやめるには、`detach'
コマンドを使います。

 GDBがリモート・プログラムを待っているときにはいつでも、割り込み文字（多
くの場合C-C）を入力すると、GDBはそのプログラムを停止しようとします。これ
は成功することも失敗することもありますが、その成否は、リモート・システム
のハードウェアやシリアル・ドライバにも依存します。割り込み文字を再度入力
すると、GDBは以下のプロンプトを表示します。

     Interrupted while waiting for the program.
     Give up (and stop debugging it)?  (y or n)

ここで`y'を入力すると、GDBはリモート・デバッグ・セッションを破棄します
（後になって再実行したくなった場合には、接続するために`target remote'を
再度使用します）。`n'を入力すると、GDBは再び待ち状態になります。



File: gdb-ja.info, Node: Protocol

通信プロトコル
..............

 GDBとともに提供されるスタブ・ファイルは、ターゲット側の通信プロトコルを
実装します。そして GDB側の通信プロトコルは、GDBのソース・ファイル
`remote.c'に実装されています。通常は、これらのサブルーチンに通信処理を任
せて、詳細を無視することができます（独自のスタブ・ファイルを作成するとき
でも、詳細については無視して、既存のスタブ・ファイルをもとにして作成を始
めることができます。`sparc-stub.c'が最もよく整理されており、したがって最
も読みやすくなっています）。

しかし、場合によっては、プロトコルについて何かを知る必要が出てくることも
あるでしょう。例えば、ターゲット・マシンにシリアル・ポートが1つしかなく、
GDBに対して送られてきたパケットを検出したときに、ユーザ・プログラムが何
か特別なことをするようにしたい場合です。

（単一文字による確認メッセージを除く）すべての GDBコマンドとそれに対する
応答は、チェックサムを含むパケットとして送信されます。パケットは、文字
`$'で始まり、文字`#'に2桁のチェックサム値が続いて終わります。

     $PACKET INFO#CHECKSUM

ここで、CHECKSUMはPACKET INFOのすべての文字の値を合計したものを256で割っ
た余りとして計算されます。

ホスト・マシンまたはターゲット・マシンがパケットを受信したとき、最初に期
待される応答は確認メッセージです。これは単一文字で、（パッケージが正しく
受信されたことを示す）`+'または（再送要求を示す）`-'です。

ホスト（ GDB）がコマンドを送信し、ターゲット（ユーザ・プログラムに組み込
まれたデバッグ・スタブ）が応答としてデータを送信します。ターゲットは、ユー
ザ・プログラムが停止したときにも、データを送信します。

コマンド・パケットは最初の文字で区別されます。最初の文字がコマンドの種類
を表わします。

以下に、現在サポートされているコマンドをいくつか列挙します（コマンドの完
全なリストについては`gdb/remote.c'を参照してください）。

`g'
     CPUレジスタの値を要求します。

`G'
     CPUレジスタの値を設定します。

`mADDR,COUNT'
     ADDRで示される位置からCOUNTで示されるバイト数を読み込みます。

`MADDR,COUNT:...'
     ADDRで示される位置からCOUNTで示されるバイト数を書き込みます。

`c'
`cADDR'
     カレントなアドレス（ADDRが指定されているのであれば、それによって指
     定されるアドレスから）実行を再開します。

`s'
`sADDR'
     プログラム・カウンタの指すカレントな箇所から（ADDRが指定されている
     のであれば、それによって指定されるアドレスから）ターゲット・プログ
     ラムを1命令だけステップ実行します。

`k'
     ターゲット・プログラムを終了させます。

`?'
     最後に受信したシグナルを報告します。GDBのシグナル処理コマンドを利用
     できるように、デバッグ・スタブの中のある関数が、CPUトラップを対応す
     るPOSIXシグナル値として報告してきます。

`T'
     リモートのスタブに対して、GDBがシングル・ステップ処理や条件付きブレ
     イクポイントに関する迅速な決定を下すのに必要となるレジスタの情報だ
     けを送信するようにさせます。これによって、ステップ実行中の1命令ごと
     にすべてのレジスタの情報を入手する必要がなくなります。

     現在の GDBは、レジスタへのライト・スルー・キャッシュを実装していて、
     ターゲットが実行された場合のみ、レジスタを再度読み込みます。

シリアル接続に問題がある場合には、`set remotedebug'コマンドを使うことが
できます。これにより GDBは、シリアル回線経由でリモート・マシンとの間で送
受信したすべてのパケットを報告するようになります。パケット・デバッグ用の
情報は GDBの標準出力ストリームに表示されます。`set remotedebug off'によっ
てこの設定が解除され、`show remotedebug'によって現在の設定が表示されます。



File: gdb-ja.info, Node: Server

`gdbserver'プログラムの使用
...........................

`gdbserver'は、UNIX系システム用の制御プログラムで、これにより、通常のデ
バッグ用スタブをリンクすることなく、`target remote'コマンドによって、ユー
ザ・プログラムをリモートの GDBに接続することができます。

`gdbserver'は、デバッグ用スタブに完全に取って代わるものではありません。
`gdbserver'は、GDBが必要とするのと同様のオペレーティング・システムの機能
を基本的には必要とするからです。実際、リモートの GDBと接続するために
`gdbserver'を実行できるシステムであれば、GDBをローカルに実行することも可
能です。それでも、`gdbserver'は GDBと比較するとかなりサイズが小さいので、
便利なことがあります。また、`gdbserver'の移植は GDB全体の移植よりも簡単
なので、`gdbserver'を使うことで、新しいシステムでの作業をより早く開始す
ることができます、最後に、リアル・タイム・システムの開発をしている場合、
リアル・タイムな操作に関わるトレードオフのために、例えばクロス・コンパイ
ルなどによって、他のシステム上で可能な限り多くの開発作業を行ったほうが便
利であるということがあるでしょう。デバッグ作業に関しても、`gdbserver'を
使うことでこれと同じような選択を行うことができます。

 GDBと`gdbserver'は、シリアル回線またはTCP接続を経由して、標準的な GDBリ
モート・シリアル・プロトコルによって通信します。

*ターゲット・マシンでは：*
     デバッグしたいプログラムのコピーが1つ必要です。`gdbserver'はユーザ・
     プログラムのシンボル・テーブルを必要とはしませんので、スペースの節
     約が必要であれば、プログラムをストリップすることができます。ホスト・
     システム上の GDBが、シンボルに関するすべての処理を実行します。

     `gdbserver'を使うには、GDBとの通信方法、ユーザ・プログラムの名前、
     ユーザ・プログラムへの引数を教えてやる必要があります。構文は、以下
     のとおりです。

          target> gdbserver COMM PROGRAM [ ARGS ... ]

     COMMは（シリアル回線を使うための）装置名、あるいは、TCPのホスト名と
     ポート番号です。例えば、`foo.txt'という引数を指定してEmacsをデバッ
     グし、シリアル・ポート`/dev/com1'経由で GDBと通信するには、以下のよ
     うに実行します。

          target> gdbserver /dev/com1 emacs foo.txt

     `gdbserver'は、ホスト側の GDBが通信してくるのを受動的に待ちます。

     シリアル回線の代わりにTCP接続を使うには、以下のようにします。

          target> gdbserver host:2345 emacs foo.txt

     前の例との唯一の違いは第1引数です。これは、ホストの GDBとTCPによっ
     て接続することを指定しています。`host:2345'は、マシン`host'からロー
     カルのTCPポート2345へのTCP接続を`gdbserver'が期待していることを意味
     します（現在のバージョンでは、`host'の部分は無視されます）。ターゲッ
     ト・システム上で既に使われているTCPポートでなければ、任意の番号をポー
     ト番号として選択できます（例えば、`23'は`telnet'に予約されています） 
     (1) (*Note Server-Footnotes::)。ここで指定したのと同じポート番号を、
     ホスト上の GDBの`target remote'コマンドで使わなければなりません。

* GDBのホスト・マシンでは：*
      GDBはシンボル情報、
     デバッグ情報を必要とするので、
     ストリップされていないユーザ・プログラムのコピーが必要です。
     通常どおり、
     第1引数にユーザ・プログラムのローカル・コピーの名前を指定して GDBを起動します
     （シリアル回線の速度が9600 bps以外であれば、
     `--baud'オプションも必要になります）。
     その後、
     `target remote'コマンドによって`gdbserver'との通信を確立します。
     引数には、
     装置名
     （通常は`/dev/ttyb'のようなシリアル装置）、
     または、
     `HOST:PORT'という形式でのTCPポート記述子を指定します。
     例えば、

          ( gdb) target remote /dev/ttyb

     では、シリアル回線`/dev/ttyb'を介して`gdbserver'と通信します。また、

          ( gdb) target remote the-target:2345

     では、
     ホスト`the-target'上のポート2345に対するTCP接続によって通信します。
     TCP接続を使う場合には、
     `target remote'コマンドを実行する前に、
     `gdbserver'を起動しておかなければなりません。
     そうしないと、エラーになります。
     エラー・テキストの内容はホスト・システムによって異なりますが、
     通常は`Connection refused'のような内容です。



File: gdb-ja.info  Node: Server-Footnotes, Up: Server

(1) 原注：他のサービスによって使用されているポート番号を選択すると、
`gdbserver'はエラー・メッセージを出力して終了します。


File: gdb-ja.info, Node: NetWare

`gdbserve.nlm'プログラムの使用
..............................

`gdbserve.nlm'はNetWareシステムでの制御プログラムです。これによって、
`target remote'コマンドでユーザ・プログラムをリモートの GDBに接続するこ
とができます。

 GDBと`gdbserve.nlm'は、標準の GDBリモート・シリアル・プロトコルを使って、
シリアル回線経由で通信します。

*ターゲット・マシンでは：*
     デバッグしたいプログラムのコピーが1つ必要です。`gdbserve.nlm'はユー
     ザ・プログラムのシンボル・テーブルを必要とはしませんので、スペース
     の節約が必要であれば、プログラムをストリップすることができます。ホ
     スト・システム上の GDBが、シンボルに関わるすべての処理を実行します。

     `gdbserve.nlm'を使うには、GDBとの通信方法、ユーザ・プログラムの名前、
     ユーザ・プログラムの引数を教えてやる必要があります。構文は、以下の
     とおりです。

          load gdbserve [ BOARD=BOARD ] [ PORT=PORT ]
                        [ BAUD=BAUD ] PROGRAM [ ARGS ... ]

     BOARDとPORTがシリアル回線を指定します。BAUDは接続に使われるボーレー
     トを指定します。PORTとNODEのデフォルト値は0、BAUDのデフォルト値は
     9600 bpsです。

     例えば、`foo.txt'という引数を指定してEmacsをデバッグし、シリアル・
     ポート番号2、ボード1を経由して19200 bpsの接続で GDBと通信するには、
     以下のように実行します。

          load gdbserve BOARD=1 PORT=2 BAUD=19200 emacs foo.txt

* GDBのホスト・マシンでは：*
      GDBはシンボル情報、
     デバッグ情報を必要とするので、
     ストリップされていないユーザ・プログラムのコピーが必要です。
     通常どおり、
     第1引数にユーザ・プログラムのローカル・コピーの名前を指定して GDBを起動します
     （シリアル回線の速度が9600 bps以外であれば、
     `--baud'オプションも必要になります）。
     その後、
     `target remote'コマンドによって
     `gdbserve.nlm'との通信を確立します。
     引数には、
     装置名
     （通常は`/dev/ttyb'のようなシリアル装置）
     を指定します。
     例えば、

          ( gdb) target remote /dev/ttyb

     は、シリアル回線`/dev/ttyb'を経由して`gdbserve.nlm'と通信します。




File: gdb-ja.info, Node: i960-Nindy Remote

 GDBとリモートi960（Nindy）
---------------------------

"Nindy"は、Intel 960ターゲット・システム用のROM Monitorプログラムです。
Nindyを使ってリモートのIntel 960を制御するよう GDBが構成されている場合、
いくつかの方法によって GDBに960との接続方法を教えることができます。

   * シリアル・ポート、Nindyプロトコルのバージョン、通信スピードを指定す
     るコマンドライン・オプションによる方法

   * 起動時のプロンプトに答える方法

   *  GDBセッション中の任意の時点で`target'コマンドを使う方法（*Note
     Commands for managing targets: Target Commands）


* Menu:

* Nindy Startup::               Nindy使用時の起動方法
* Nindy Options::               Nindy用のオプション
* Nindy Reset::                 Nindy resetコマンド



File: gdb-ja.info, Node: Nindy Startup

Nindy使用時の起動方法
.....................

コマンドライン・オプションを一切使わずに` gdb'を起動すると、通常の GDBプ
ロンプトが表示される*前*に、使用するシリアル・ポートを指定するよう促され
ます。

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:  

このプロンプトに対して、使いたいシリアル・ポートを示す（`/dev/tty'の後ろ
の）サフィックスを入力します。もしそうしたいのであれば、プロンプトに空行
で答えることによって、Nindyとの接続を確立せずに起動することもできます。
この場合、後にNindyと接続したいときには`target'コマンドを使います（*Note
Commands for managing targets: Target Commands.）。



File: gdb-ja.info, Node: Nindy Options

Nindy用のオプション
...................

接続されたNindy-960ボードとの GDBセッションを開始するための起動オプショ
ンを以下に示します。

`-r PORT'
     ターゲット・システムとの接続に使用されるシリアル・インターフェイス
     のシリアル・ポート名を指定します。このオプションは、GDBがIntel 960 
     ターゲット・アーキテクチャ用に構成されているときのみ利用可能です。
     PORTは、完全なパス名（例：`-r /dev/ttya'）、`/dev'配下のデバイス名
     （例：`-r ttya'）、`tty'固有の一意なサフィックス（例：`-r a'）のい
     ずれによっても指定することができます。

`-O'
     （ゼロではなく、英大文字のOです）。GDBがターゲット・システムと接続
     する際に、古いNindyモニタ・プロトコルを使用すべきであることを指定し
     ます。このオプションは、GDBがIntel 960ターゲット・アーキテクチャ用
     に構成されているときのみ利用可能です。

          *注意*：`-O'を指定したにもかかわらず、実際にはより新しいプロト
          コルを期待しているターゲット・システムに接続しようとした場合、
          接続は失敗します。この失敗は、あたかも通信速度の不一致が原因で
          あるかのように見えてしまいます。GDBは、異なる回線速度によって
          再接続を繰り返し試みます。割り込みによって、この処理を中断させ
          ることができます。

`-brk'
     接続する前にNindyターゲットをリセットするために、ターゲット・システ
     ムに対して最初に`BREAK'信号を送信するよう、GDBに対して指定します。

          *注意*：多くのターゲット・システムは、このオプションが必要とす
          るハードウェアを備えていません。このオプションは、少数のボード
          でしか機能しません。

標準の`-b'オプションが、シリアル・ポート上で使用される回線速度を制御しま
す。



File: gdb-ja.info, Node: Nindy Reset

Nindy resetコマンド
...................

`reset'
     ターゲットがNindyである場合、このコマンドはBREAK信号をリモートのター
     ゲット・システムに送信します。これは、BREAK信号を受信したときにハー
     ド・リセット（または、その他の興味深いアクション）を実行する回路が
     ターゲットに備わっている場合にのみ役に立ちます。



File: gdb-ja.info, Node: UDI29K Remote

AMD29K用のUDIプロトコル
-----------------------

 GDBは、a29kプロセッサ・ファミリをデバッグするためのAMD UDI （Universal
Debugger Interface）プロトコルをサポートしています。MiniMONモニタを実行
するAMDターゲットという構成を使うには、AMD社から無料で入手可能な`MONTIP'
プログラムが必要になります。また、AMD社から入手可能なUDI準拠のa29kシミュ
レータ・プログラム`ISSTIP'とともに GDBを使うこともできます。

`target udi KEYWORD'
     リモートのa29kボードまたはシミュレータへのUDIインターフェイスを選択
     します。KEYWORDは、AMD構成ファイル`udi_soc'内のエントリです。このファ
     イルには、a29kターゲットに接続するときに使われるパラメータを指定す
     るキーワード・エントリが含まれます。`udi_soc'ファイルが作業ディレク
     トリにない場合には、環境変数`UDICONF'にそのパス名を設定しなければな
     りません。



File: gdb-ja.info, Node: EB29K Remote

AMD29KのEBMONプロトコル
-----------------------


AMD社は、PC組み込み用の29K開発ボードを、DOS上で動作する`EBMON'というモニ
タ・プログラムとともに配布しています。この開発システムは、省略してEB29K
と呼ばれます。UNIXシステム上の GDBを使ってEB29Kボード上でプログラムを実
行するには、まず（EB29Kを組み込んだ）PCとUNIXシステムのシリアル・ポート
の間をシリアル回線で接続しなければなりません。以下の節では、PCの`COM1'ポー
トとUNIXシステムの`/dev/ttya'との間をケーブルで接続してあるものと仮定し
ます。

* Menu:

* Comms (EB29K)::               通信セットアップ
* gdb-EB29K::                   EB29Kクロス・デバッグ
* Remote Log::                  リモート・ログ



File: gdb-ja.info, Node: Comms (EB29K)

通信セットアップ
................

PC上のDOSで以下のように実行することによって、PCのポートをセットアップし
ます。

     C:\> MODE com1:9600,n,8,1,none

MS DOS 4.0上で実行されているこの例では、PCポートを通信速度9600 bps、パリ
ティ・ビットなし、データ・ビット数8、ストップ・ビット数1、リトライなしに
設定しています。UNIX側を設定する際には、同一の通信パラメータを使わなけれ
ばなりません。

シリアル回線のUNIX側にPCの制御権を与えるには、DOSコンソール上で以下のよ
うに実行します。

     C:\> CTTY com1

（後に、DOSコンソールに制御を戻したいときには、`CTTY con'コマンドを使う
ことができます。ただし、制御権を持っている装置からこのコマンドを送信する
必要があります。ここでの例では、`COM1'に接続されているシリアル回線を通し
て送信することになります）。

UNIXのホストからは、PCと通信するのに`tip'や`cu'のような通信プログラムを
使います。以下に例を示します。

     cu -s 9600 -l /dev/ttya

ここで示されている`cu'オプションはそれぞれ、使用する回線速度とシリアル・
ポートを指定しています。`tip'コマンドを使った場合は、コマンドラインは以
下のようなものになるでしょう。

     tip -9600 /dev/ttya

ここで`tip'への引数として指定した`/dev/ttya'の部分には、システムによって
異なる名前を指定する必要があるかもしれません。使用するポートを含む通信パ
ラメータは、"remote"記述ファイルにおいて`tip'コマンドへの引数と関連付け
られます。通常このファイルは、システム・テーブル`/etc/remote'です。

`tip'接続または`cu'接続を使用してDOSの作業ディレクトリを29Kプログラムが
存在するディレクトリに変更し、PCプログラム`EBMON' （AMD社からボードとと
もに提供されるEB29K制御プログラム）を起動します。以下に示す例によく似た、
`EBMON'プロンプト`#'で終わる`EBMON'の初期画面が表示されるはずです。

     C:\> G:

     G:\> CD \usr\joe\work29k

     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.

     Enter '?' or 'H' for help

     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000

     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff

     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800

     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes

     # ~.

続いて、`cu'プログラムまたは`tip'プログラムを終了させます（上の例では、
`EBMON'プロンプトにおいて`~.'を入力することで終了させています）。`EBMON'
は、GDBが制御権を獲得できる状態で、実行を継続します。

この例では、PCとUNIXシステムの両方に同一の29Kプログラムが確実に存在する
ようにするのに、おそらく最も便利であろうと思われる方法を使うことを仮定し
ました。それは、PC/NFSによる接続で、UNIXホストのファイル・システムの1つ
をPCの`G:'ドライブとする方法です。PC/NFS、あるいは、2つのシステム間を接
続する類似の方法がない場合、フロッピ・ディスクによる転送など、UNIXシステ
ムからPCへ29Kプログラムを転送するための他の手段を準備する必要があります。
GDBは、シリアル回線経由で29Kプログラムをダウンロードすることは*しません*。



File: gdb-ja.info, Node: gdb-EB29K

EB29Kクロス・デバッグ
.....................

最後に、UNIXシステム上の29Kプログラムが存在するディレクトリに`cd'コマン
ドによって移動して、GDBを起動します。引数には、29Kプログラムの名前を指定
します。

     cd /usr/joe/work29k
      gdb myfoo

これで`target'コマンドが使えるようになります。

     target amd-eb /dev/ttya 9600 MYFOO

この例では、ユーザ・プログラムは`myfoo'と呼ばれるファイルであると仮定し
ています。`target amd-eb'に対して最後の引数として指定するファイル名は、
DOS上でのプログラム名でなければならない点に注意してください。この例では
単に`MYFOO'となっていますが、DOSのパス名を含むこともできますし、転送メカ
ニズムによっては、UNIX側での名前とは似ても似つかないものになることもある
でしょう。

ここまでくると、好きなようにブレイクポイントを設定することができます。
29Kボード上でのプログラムの実行を監視する準備が整えば、GDBの`run'コマン
ドを使います。

リモート・プログラムのデバッグを停止するには、GDBの`detach'コマンドを使
います。

PCの制御をPCコンソールに戻すには、 GDBセッションが終了した後に、`EBMON'
にアタッチするために、もう一度`tip'または`cu'を使います。その後、`q'コマ
ンドによって`EBMON'をシャットダウンし、DOSのコマンドライン・インタープリ
タに制御を戻します。`CTTY con'と入力して、入力されたコマンドがメインの
DOSコンソールによって受け取られるようにし、`~.'を入力して`tip'または`cu'
を終了させます。



File: gdb-ja.info, Node: Remote Log

リモート・ログ
..............

`target amd-eb'コマンドは、接続に関わる問題のデバッグを支援するため、カ
レントな作業ディレクトリに`eb.log'というファイルを作成します。`eb.log'は、
`EBMON'に送信されたコマンドのエコーを含む、`EBMON'からのすべての出力を記
録します。別のウィンドウ内でこのファイルに対して`tail -f'を実行すると、
`EBMON'に関わる問題やPC側での予期せぬイベントを理解する助けになることが
よくあります。




File: gdb-ja.info, Node: ST2000 Remote

 GDBとTandem ST2000
-------------------

ST2000をホスト・システムに接続する方法については、製造元のマニュアルを参
照してください。ST2000が物理的に接続されれば、それをデバッグ環境として確
立するには、以下を実行します。

     target st2000 DEV SPEED

DEVは通常、シリアル回線によってST2000と接続される`/dev/ttya'のようなシリ
アル装置の名前です。代わりに、`HOSTNAME:PORTNUMBER'という構文を使って
（例えば、端末多重化装置経由で接続されたシリアル回線への）TCP接続として
DEVを指定することもできます。

このターゲットに対して、`load'コマンドと`attach'コマンドは定義されて*い
ません*。通常スタンドアロンで操作している場合と同様、ST2000にユーザ・プ
ログラムをロードしなければなりません。GDBは（シンボルのような）デバッグ
用の情報を、ホスト・コンピュータ上にある別のデバッグ・バージョンのプログ
ラムから読みとります。

ST2000での作業を支援するために、以下の補助的な GDBコマンドが利用可能です。

`st2000 COMMAND'
     STDBUGモニタにCOMMANDを送信します。利用できるコマンドについては、製
     造元のマニュアルを参照してください。

`connect'
     STDBUGコマンド・モニタに対して制御端末を接続します。STDBUGの操作が
     終了した後、`RET~.'  （Returnキーに続いて、チルダとピリオドを入力）、
     または、`RET~C-d' （Returnキーに続いて、チルダとControl-Dを入力）の
     いずれかを入力することによって GDBコマンド・プロンプトに戻ります。



File: gdb-ja.info, Node: VxWorks Remote

 GDBとVxWorks
-------------

開発者は、GDBを使用することによって、ネットワークに接続されたVxWorks端末
上のタスクを、UNIXのホストから起動してデバッグすることができます。
VxWorksシェルから起動され、既に実行中の状態のタスクをデバッグすることも
できます。GDBは、UNIXホスト上で実行されるコードとVxWorksターゲット上で実
行されるコードの両方を使います。`gdb'は、UNIXホスト上にインストールされ
て実行されます（ホスト上のプログラムをデバッグするのに使う GDBと区別する
ために、`vxgdb'という名前でインストールされることもあります）。

`VxWorks-timeout ARGS'
     すべてのVxWorksベースのターゲットが、`vxworks-timeout'オプションを
     サポートするようになりました。このオプションはユーザによってセット
     されるもので、ARGSは、GDBがRPCの応答を待つ秒数を表わします。実際の
     VxWorksターゲットが速度の遅いソフトウェア・シミュレータであったり、
     帯域の小さいネットワーク回線を介して遠距離にある場合などに使うとよ
     いでしょう。

VxWorksとの接続に関する以下の情報は、このマニュアルの作成時における最新
の情報です。新しくリリースされたVxWorksでは、手順が変更されているかもし
れません。

VxWorks上で GDBを使うためには、VxWorksカーネルを再構築して、VxWorksライ
ブラリ`rdb.a'の中のリモート・デバッグ用のインターフェイス・ルーチンを組
み込む必要があります。そのためには、VxWorksのコンフィギュレーション・ファ
イル`configAll.h'の中で`INCLUDE_RDB'を定義して、VxWorksカーネルを再構築
します。この結果として生成されるカーネルには`rdb.a'が組み込まれ、VxWorks
の起動時にソース・デバッグ用のタスク`tRdbTask'が起動されます。VxWorksの
構成や再構築に関する詳細については、製造元のマニュアルを参照してください。

VxWorksシステム・イメージへの`rdb.a'の組み込みが終わり、UNIXの実行ファイ
ル・サーチ・パスに GDBの存在するパスを加えれば、GDBを実行するための準備
は完了です。UNIXホストから`gdb' （インストールの方法によっては`vxgdb'）
を実行します。

 GDBが起動されて、以下のプロンプトを表示します。

     (vxgdb)

* Menu:

* VxWorks Connection::          VxWorksへの接続
* VxWorks Download::            VxWorksダウンロード
* VxWorks Attach::              タスクの実行



File: gdb-ja.info, Node: VxWorks Connection

VxWorksへの接続
...............

 GDBの`target'コマンドによって、ネットワーク上のVxWorksターゲットに接続
します。`tt'というホスト名を持つターゲットに接続するには、以下のようにし
ます。

     (vxgdb) target vxworks tt

 GDBは以下のようなメッセージを表示します。

     Attaching remote machine across net... 
     Connected to tt.

続いて GDBは、最後にVxWorksターゲットが起動されたときより後にロードされ
たオブジェクト・モジュールのシンボル・テーブルを読み込もうと試みます。
GDBは、コマンドのサーチ・パスに含まれているディレクトリを探索することに
よって、これらのファイルを見つけます（*Note Your program's environment:
Environment.）。オブジェクト・ファイルを見つけることができない場合には、
以下のようなメッセージを表示します。

     prog.o: No such file or directory.

このような場合には、GDBの`path'コマンドによって適切なディレクトリを検索
パスに加えてから、再度`target'コマンドを実行します。



File: gdb-ja.info, Node: VxWorks Download

VxWorksダウンロード
...................

VxWorksターゲットに接続済みの状態で、まだロードされていないオブジェクト
をデバッグしたい場合には、GDBの`load'コマンドを使ってUNIXからVxWorksへ追
加的にファイルをダウンロードすることができます。`load'コマンドの引数とし
て指定されたオブジェクト・ファイルは、実際には2回オープンされます。まず、
コードをダウンロードするためにVxWorksターゲットによってオープンされ、次
にシンボル・テーブルを読み込むために GDBによってオープンされます。2つの
システム上のカレントな作業ディレクトリが異なると、問題が発生します。両方
のシステムが同一のファイル・システムをNFSマウントしているのであれば、絶
対パスを使うことで問題を回避することができます。そうでない場合は、両方の
システム上で、オブジェクト・ファイルが存在するディレクトリを作業ディレク
トリにして、パスを一切使わずにファイル名だけでファイルを参照するのが、最
も簡単でしょう。例えば、プログラム`prog.o'が、VxWorksでは
`VXPATH/vw/demo/rdb'に存在し、ホストでは`HOSTPATH/vw/demo/rdb'に存在する
としましょう。このプログラムをロードするには、VxWorks上で以下のように実
行します。

     -> cd "VXPATH/vw/demo/rdb"

 GDB上では、以下のように実行します。

     (vxgdb) cd HOSTPATH/vw/demo/rdb 
     (vxgdb) load prog.o

 GDBは次のような応答を表示します。

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

ソース・ファイルを編集して再コンパイルした後に、`load'コマンドを使ってオ
ブジェクト・モジュールを再ロードすることもできます。ただし、これを行うと、
GDBはその時点で定義されているすべてのブレイクポイント、自動表示設定、コ
ンビニエンス変数を削除し、値ヒストリを初期化してしまいますので、注意して
ください（これは、ターゲット・システムのシンボル・テーブルを参照するデバッ
ガのデータ構造の完全性を保つために必要です）。



File: gdb-ja.info, Node: VxWorks Attach

タスクの実行
............

以下のように`attach'コマンドを使うことで、既存のタスクにアタッチすること
も可能です。

     (vxgdb) attach TASK

TASKは、VxWorksの16進数のタスクIDです。アタッチするときに、タスクは実行
中であってもサスペンドされていても構いません。実行中であったタスクは、ア
タッチされたときにサスペンドされます。



File: gdb-ja.info, Node: Sparclet Remote

 GDB と Sparclet
----------------

開発者は、GDBを使うことによって、Sparcletターゲット上で実行中のタスクを
Unixホストからデバッグできるようになります。GDBは、Unixホスト上で実行さ
れるコードとSparcletターゲット上で実行されるコードの両方を使用します。
`gdb'は、Unixホスト上にインストールされて実行されます。

`timeout ARGS'
      GDBはオプション`remotetimeout'をサポートするようになりました。この
     オプションはユーザによって設定されるもので、ARGSは GDBが応答を待つ
     秒数を表わします。

デバッグ用にコンパイルする際には、デバッグ情報を得るために"-g"オプション
を、また、ターゲット上でロードしたい位置にプログラムを再配置するために
"-Ttext"オプションを指定します。各セクションのサイズを小さくするために、
"-n"または"-N"オプションを加えるのも良いでしょう。

     sparclet-aout-gcc prog.c -Ttext 0x12010000 -g -o prog -N

アドレスが意図したものと一致しているかどうかを検証するのに、objdumpを使
うことができます。

     sparclet-aout-objdump --headers --syms prog

 GDBが見つかるようにUnixの実行サーチ・パスを設定すれば、GDBを実行するた
めの準備は完了です。Unixホストから`gdb' （インストールの方法によっては、
`sparclet-aout-gdb'）を実行します。

 GDBが起動されて、以下のプロンプトを表示します。

     (gdbslet)

* Menu:

* Sparclet File::                デバッグするファイルの選択
* Sparclet Connection::          Sparcletへの接続
* Sparclet Download::            Sparcletダウンロード
* Sparclet Execution::           実行とデバッグ



