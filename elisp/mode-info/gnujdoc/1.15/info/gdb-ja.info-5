Info file: gdb-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gdb-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.









START-INFO-DIR-ENTRY * Gdb: (gdb).  The GNU debugger.
END-INFO-DIR-ENTRY This file documents the GNU debugger GDB.


This is the Seventh Edition, February 1999, of `Debugging with GDB: the
GNU Source-Level Debugger' for GDB Version 4.18.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.





File: gdb-ja.info, Node: Sparclet File

デバッグするファイルの選択
..........................

 GDBの`file'コマンドによって、デバッグするプログラムを選択することができ
ます。

     (gdbslet) file prog

このコマンドを実行すると、GDBは`prog'のシンボル・テーブルを読み込もうと
します。GDBは、コマンド・サーチ・パスに含まれるディレクトリを探索するこ
とによって、そのファイルを見つけます。そのファイルがデバッグ情報付き（オ
プション"-g"）でコンパイルされた場合は、ソース・ファイルも探します。GDB
は、ディレクトリ・サーチ・パス（*Note Your program's environment:
Environment.）に含まれるディレクトリを探索することによって、そのソース・
ファイルを見つけます。ファイルが見つからない場合には、次のようなメッセー
ジを表示します。

     prog: No such file or directory.

このメッセージが表示された場合には、GDBの`path'コマンドと`dir'コマンドを
使って適切なディレクトリをサーチ・パスに加えてから、`target'コマンドを再
実行します。



File: gdb-ja.info, Node: Sparclet Connection

Sparcletへの接続
................

 GDBの`target'コマンドによってSparcletターゲットに接続することができます。
シリアル・ポート"`ttya'"でターゲットに接続するには、以下のように入力しま
す。

     (gdbslet) target sparclet /dev/ttya
     Remote target sparclet connected to /dev/ttya
     main () at ../prog.c:3 

 GDBは以下のようなメッセージを表示します。

     Connected to ttya.



File: gdb-ja.info, Node: Sparclet Download

Sparcletダウンロード
....................

Sparcletターゲットへの接続が完了すると、GDBの`load'コマンドを使って、ホ
ストからターゲットへファイルをダウンロードすることができます。ファイル名
とロード・オフセットを、`load'コマンドへの引数として渡さなければなりませ
ん。ファイル形式はaoutですので、プログラムはその開始アドレスにロードされ
なければなりません。開始アドレスの値を知るにはobjdumpを使うことができま
す。ロード・オフセットとは、ファイルの個々のセクションのVMA（仮想メモリ・
アドレス）に加算されるオフセットのことです。例えば、プログラム`prog'が、
textセクションのアドレス0x12010000、dataセクションのアドレス0x12010160、
bssセクションのアドレス0x12010170にリンクされているとすると、GDBでは以下
のように入力します。

     (gdbslet) load prog 0x12010000
     Loading section .text, size 0xdb0 vma 0x12010000

プログラムがリンクされたアドレスとは異なるアドレスにコードがロードされた
場合、どこにシンボル・テーブルをマップするかを GDBに通知するために、
`section'コマンドと`add-symbol-file'コマンドを使う必要があるかもしれませ
ん。



File: gdb-ja.info, Node: Sparclet Execution

実行とデバッグ
..............

以上により、GDBの実行制御コマンドである`b'、`step'、`run'などを使ってタ
スクのデバッグを開始することができます。コマンドの一覧については、GDBの
マニュアルを参照してください。

     (gdbslet) b main
     Breakpoint 1 at 0x12010000: file prog.c, line 3.
     (gdbslet) run 
     Starting program: prog
     Breakpoint 1, main (argc=1, argv=0xeffff21c) at prog.c:3
     3        char *symarg = 0;
     (gdbslet) step
     4        char *execarg = "hello!";
     (gdbslet)                           




File: gdb-ja.info, Node: Hitachi Remote

 GDBと日立のマイクロ・プロセッサ
--------------------------------

日立のSH、H8/300、H8/500と通信するためには、GDBは以下の情報を知っている
必要があります。

  1. ユーザは、日立マイクロ・プロセッサへのリモート・デバッグ用インター
     フェイスである`target hms'と、日立SHや日立300Hのインサーキット・エ
     ミュレータであるtarget`e7000'のどちらを使用したいかということ（ GDB
     が日立SH、H8/300、H8/500用に特に構成されている場合には、`target
     hms'がデフォルトです）。

  2. ホストと日立ボードを接続しているシリアル装置（デフォルトは、ホスト
     上で利用できる最初のシリアル装置です）

  3. シリアル装置で使用する速度

* Menu:

* Hitachi Boards::      日立ボードへの接続
* Hitachi ICE::         E7000インサーキット・エミュレータの使用
* Hitachi Special::     日立マイクロ・プロセッサ用の特別な GDBコマンド



File: gdb-ja.info, Node: Hitachi Boards

日立ボードへの接続
..................

シリアル装置を明示的に指定する必要があれば、そのための専用コマンドである、
` gdb'の`device PORT'コマンドを使用します。PORTのデフォルトは、ホスト上
で最初に利用可能なポートです。これはUNIXホスト上でのみ必要であり、そこで
は典型的には`/dev/ttya'という名前になります。

` gdb'には、
通信速度を設定するための専用コマンド`speed BPS'があります。
このコマンドもまた
UNIXホストからのみ使用されるものです。
DOSホストでは通常どおり、
 GDBからではなくDOSの`mode'コマンドによって回線速度を設定します
（例えば、
9600 bpsの接続を確立するには`mode com2:9600,n,8,1,p'のように実行します）。

`device'コマンドと`speed'コマンドは、日立マイクロ・プロセッサ・プログラ
ムのデバッグにUNIXホストを使う場合のみ利用可能です。DOSホストを使う場合、
GDBは、PCのシリアル・ポート経由で開発ボードと通信するのに、`asynctsr'と
呼ばれる補助的な常駐プログラムに依存します。DOS側でシリアル・ポートの設
定をする場合にも、DOSの`mode'コマンドを使わなければなりません。




File: gdb-ja.info, Node: Hitachi ICE

E7000インサーキット・エミュレータの使用
.......................................

E7000インサーキット・エミュレータを使って、日立SHまたはH8/300H用のコード
を開発することができます。`target e7000'コマンドを以下のいずれかの形式で
使って、GDBをE7000に接続します。

`target e7000 PORT SPEED'
     E7000がシリアル・ポートに接続されている場合は、この形式を使ってくだ
     さい。引数PORTが、使用するシリアル・ポートを指定します（例えば、
     `com2'）。3番目の引数は、秒あたりのビット数による回線速度です（例え
     ば、`9600'）。

`target e7000 HOSTNAME'
     E7000がTCP/IPネットワーク上のホストとしてインストールされている場合、
     ホスト名だけを指定することもできます。GDBは接続に`telnet'を使います。



File: gdb-ja.info, Node: Hitachi Special

日立マイクロ・プロセッサ用の特別な GDBコマンド
..............................................

いくつかの GDBコマンドは、H8/300またはH8/500用に構成された場合にのみ利用
可能です。

`set machine h8300'
`set machine h8300h'
     `set machine'コマンドによって、2種類のH8/300アーキテクチャのどちら
     か一方にあわせて GDBを調整します。`show machine'コマンドによって、
     現在有効なアーキテクチャを調べることができます。

`set memory MOD'
`show memory'
     `set memory'コマンドによって、使用中のH8/500メモリ・モデル（MOD）を
     指定します。`show memory'コマンドによって、現在有効なメモリ・モデル
     を調べます。MODに指定可能な値は、`small'、`big'、`medium'、
     `compact'のいずれかです。




File: gdb-ja.info, Node: MIPS Remote

 GDBとリモートMIPSボード
------------------------

 GDBは、MIPSのリモート・デバッグ用のプロトコルを使って、シリアル回線に接
続されたMIPSボードと通信することができます。これは、GDBを
`--target=mips-idt-ecoff'によって構成することによって、利用することがで
きます。

ターゲット・ボードとの接続を指定するには、以下の GDBコマンドを使用します。

`target mips PORT'
     ボード上でプログラムを実行するには、引数にユーザ・プログラムの名前
     を指定して` gdb'を起動します。ボードに接続するには、`target mips
     PORT'コマンドを使用します。PORTは、ボードに接続されているシリアル・
     ポートの名前です。プログラムがまだボードにダウンロードされていない
     のであれば、`load'コマンドを使ってダウンロードすることができます。
     その後、通常利用できるすべての GDBコマンドを使うことができます。

     例えば以下の手順では、デバッガを使うことによって、シリアル・ポート
     を経由してターゲット・ボードに接続した後に、PROGと呼ばれるプログラ
     ムをロードして実行しています。

          host$  gdb PROG
          GDB is free software and ...
          (gdb) target mips /dev/ttyb
          (gdb) load PROG
          (gdb) run

`target mips HOSTNAME:PORTNUMBER'
      GDBのホスト構成によっては、`HOSTNAME:PORTNUMBER'という構文を使うこ
     とで、シリアル・ポートの代わりに（例えば、端末多重化装置によって管
     理されているシリアル回線への）TCP接続を指定することができます。

`target pmon PORT'

`target ddb PORT'

`target lsi PORT'



 GDBは、MIPSターゲットに対して、以下の特別なコマンドもサポートしています。

`set processor ARGS'
`show processor'
     プロセッサの種類に固有のレジスタにアクセスしたい場合には、`set
     processor'コマンドを使ってMIPSプロセッサの種類を設定します。例えば、
     `set processor r3041'は、3041チップで有効なCPOレジスタを使うよう、
     GDBに対して通知します。GDBが使っているMIPSプロセッサの種類を知るに
     は、`show processor'コマンドを使います。GDBが使っているレジスタを知
     るには、`info reg'コマンドを使います。

`set mipsfpu double'
`set mipsfpu single'
`set mipsfpu none'
`show mipsfpu'
     MIPS浮動小数点コプロセッサをサポートしないターゲット・ボードを使う
     場合は、`set mipsfpu none'コマンドを使う必要があります（このような
     ことが必要な場合には、初期化ファイルの中にそのコマンドを入れてしまっ
     てもよいでしょう）。これによって、浮動小数値を返す関数の戻り値を見
     つける方法を GDBに知らせます。またこれにより、ボード上で関数を呼び
     出すときに、GDBは浮動小数点レジスタの内容を退避する必要がなくなりま
     す。R4650プロセッサ上にあるような、単精度浮動小数だけをサポートする
     浮動小数点コプロセッサを使っている場合には、`set mipsfpu single'コ
     マンドを使います。デフォルトの倍精度浮動小数点コプロセッサは、`set
     mipsfpu double'によって選択することができます。

     以前のバージョンでは、有効な選択肢は、倍精度浮動小数コプロセッサを
     使う設定と浮動小数点コプロセッサを使わない設定だけでした。したがっ
     て、`set mipsfpu on'で倍精度浮動小数コプロセッサが選択され、`set
     mipsfpu off'で浮動小数点コプロセッサを使わないという設定が選択され
     ていました。

     他の場合と同様、`mipsfpu'変数に関する設定は、`show mipsfpu'によって
     問い合わせることができます。

`set remotedebug N'
`show remotedebug'
     `remotedebug'変数を設定することによって、ボードとの通信に関するいく
     つかのデバッグ用の情報を見ることができます。`set remotedebug 1'によっ
     て値`1'を設定すると、すべてのパケットが表示されます。値を`2'に設定
     すると、すべての文字が表示されます。`show remotedebug'コマンドによっ
     て、いつでも現在の設定値を調べることができます。

`set timeout SECONDS'
`set retransmit-timeout SECONDS'
`show timeout'
`show retransmit-timeout'
     MIPSリモート・プロトコルにおけるパケット待ちの状態でのタイムアウト
     時間を、`set timeout SECONDS'コマンドで制御することができます。デフォ
     ルトは5秒です。同様に、パケットに対する確認（ACK）を待っている状態
     でのタイムアウト時間を、`set retransmit-timeout SECONDS'コマンドで
     制御することができます。デフォルトは3秒です。それぞれの値を`show
     timeout'と`show retransmit-timeout'で調べることができます（どちらの
     コマンドも、GDBが`--target=mips-idt-ecoff'用に構成されている場合*の
     み*使用可能です）。

     `set timeout'で設定されたタイムアウト時間は、ユーザ・プログラムが停
     止するのを GDBが待っている間は適用されません。この場合には、GDBは永
     遠に待ち続けます。これは、停止するまでにプログラムがどの程度長く実
     行を継続するのかを知る方法がないからです。



File: gdb-ja.info, Node: Simulator

シミュレートされたCPUターゲット
-------------------------------

構成によっては、ユーザ・プログラムをデバッグする際にハードウェアCPUの代
わりに使うことのできるCPUシミュレータが、GDBの中に組み込まれています。現
在のところ、ARM、D10V、D30V、FR30、H8/300、H8/500、i960、M32R、MIPS、
MN10200、MN10300、PowerPC、SH、Sparc、V850、W65、Z8000 用のシミュレータ
が利用できます。


Z8000系については、`target sim'によって、Z8002 （Z8000アーキテクチャの、
セグメントを持たない変種）またはZ8001 （セグメントを持つ変種）をシミュレー
トします。シミュレータは、オブジェクト・コードを調べることで、どちらのアー
キテクチャが適切であるかを認識します。

`target sim ARGS'
     シミュレートされたCPU上でプログラムをデバッグします。シミュレータが
     セットアップ・オプションをサポートしている場合は、それをARGSの部分
     に指定します。

このターゲットを指定した後には、ホスト・コンピュータ上のプログラムをデバッ
グするのと同様の方法で、シミュレートされたCPU用のプログラムをデバッグす
ることができます。新しいプログラムのイメージをロードするには`file'コマン
ドを使い、ユーザ・プログラムを実行するには`run'コマンドを使う、という具
合です。

Z8000シミュレータでは、通常のマシン・レジスタ（`info reg' を参照）がすべ
て利用可能であるだけでなく、特別な名前を持つレジスタとして、3つの追加情
報が提供されています。

`cycles'
     シミュレータ内のクロック・ティックをカウントします。

`insts'
     シミュレータ内で実行された命令をカウントします。

`time'
     1/60秒を単位とする実行時間を示します。

これらの変数は、
 GDBの式の中で普通に参照することができます。
例えば、
`b fputc if $cycles>5000'は、
シミュレートされたクロック・ティックが最低5,000回発生した後に停止するような、
条件付きブレイクポイントを設定します。




File: gdb-ja.info, Node: Controlling GDB, Next: Sequences, Prev: Targets, Up: Top

 GDBの制御
**********

`set'コマンドによって GDBの操作方法を変更することができます。GDBによるデー
タの表示方法を変更するコマンドについては、*Note Print settings: Print
Settings.。この章では、その他の設定について説明します。

* Menu:

* Prompt::                      プロンプト
* Editing::                     コマンド編集
* History::                     コマンド・ヒストリ
* Screen Size::                 画面サイズ
* Numbers::                     数値
* Messages/Warnings::           オプションの警告およびメッセージ



File: gdb-ja.info, Node: Prompt, Next: Editing, Prev: Controlling GDB, Up: Controlling GDB

プロンプト
==========


 GDBは、"プロンプト"と呼ばれる文字列を表示することで、コマンドを受け付け
る用意ができたことを示します。通常、この文字列は`( gdb)'です。`set
prompt'コマンドによって、プロンプトの文字列を変更することができます。例
えば、GDBを使って GDB自体をデバッグしているときには、どちらか一方の GDB
セッションのプロンプトを変更して、どちらの GDBとやりとりしているのか区別
できるようにすると便利です。

*注:* 以前のバージョンとは異なり、現在の`set prompt'は、ユーザが設定した
プロンプトの後ろに空白を追加しません。ユーザは、空白で終わるプロンプト、
空白で終わらないプロンプトのいずれでも設定することができます。

`set prompt NEWPROMPT'
     今後はNEWPROMPTをプロンプトとして使用するよう、GDBに指示します

`show prompt'
     `Gdb's prompt is: YOUR-PROMPT' という形式の1行を表示します



File: gdb-ja.info, Node: Editing, Next: History, Prev: Prompt, Up: Controlling GDB

コマンド編集
============

 GDBは入力コマンドを"readline"インターフェイスによって読み込みます。この
GNUライブラリを使うことで、ユーザに対してコマンドライン・インターフェイ
スを提供するプログラムは、統一された振る舞いをするようになります。これを
使うことの利点としては、GNU Emacsスタイルまたは"vi"スタイルによるコマン
ドのインライン編集、`csh'スタイルのヒストリ代替、複数のデバッグ・セッショ
ンにまたがるコマンド・ヒストリの保存と呼び出しができるようになることが挙
げられます。

`set'コマンドによって、GDBにおけるコマンドライン編集の振る舞いを制御する
ことができます。

`set editing'
`set editing on'
     コマンドライン編集を使用可能にします（コマンドライン編集は、デフォ
     ルトの状態で使用可能です）。

`set editing off'
     コマンドライン編集を使用不可にします。

`show editing'
     コマンドライン編集が使用可能かどうかを示します。



File: gdb-ja.info, Node: History, Next: Screen Size, Prev: Editing, Up: Controlling GDB

コマンド・ヒストリ
==================

デバッグ・セッション中にユーザが入力したコマンドを GDBに記録させることが
できるため、ユーザは実際に何が実行されたかを確実に知ることができます。以
下のコマンドを使って、GDBのコマンド・ヒストリ機能を管理します。

`set history filename FNAME'
      GDBコマンド・ヒストリ・ファイルの名前をFNAMEに設定します。GDBは、
     最初にこのファイルからコマンド・ヒストリ・リストの初期値を読み込み、
     終了時には、このファイルにセッション中のコマンド・ヒストリを書き込
     みます。コマンド・ヒストリ・リストには、ヒストリ展開機能、あるいは、
     後に列挙するヒストリ・コマンド編集文字によってアクセスすることがで
     きます。このファイル名は、デフォルトでは環境変数`GDBHISTFILE'の値に
     なりますが、この変数が設定されていない場合には`./.gdb_history'にな
     ります。

`set history save'
`set history save on'
     コマンド・ヒストリをファイルの中に記録します。ファイルの名前は`set
     history filename'コマンドで指定可能です。デフォルトでは、このオプショ
     ンは使用不可の状態になっています。

`set history save off'
     コマンド・ヒストリをファイルの中に記録するのを停止します。

`set history size SIZE'
      GDBがヒストリ・リストの中に記録するコマンドの数を設定します。デフォ
     ルトでは、この値は環境変数`HISTSIZE'の値に設定されますが、この変数
     が設定されていない場合は256になります。

ヒストリ展開機能により、文字`!'には特別な意味が割り当てられます。*Note
Event Designators::。

`!'は、C言語における論理NOTの演算子でもあるので、ヒストリ展開機能はデフォ
ルトではoffになっています。`set history expansion on'コマンドによってヒ
ストリ展開を利用できるようにした場合には、（`!'を式の中で論理NOTとして使
うのであれば）`!'の後ろに空白かタブを入れることによって、それが展開され
ないようにする必要のある場合があります。ヒストリ展開が有効になっている場
合でも、readlineのヒストリ機能は、`!='や`!('という文字列を置き換えようと
はしません。

ヒストリ展開を制御するコマンドには、以下のようなものがあります。

`set history expansion on'
`set history expansion'
     ヒストリ展開を使用可能にします。ヒストリ展開はデフォルトでは使用不
     可です。

`set history expansion off'
     ヒストリ展開を使用不可にします。

     readlineのコードには、ヒストリ編集機能やヒストリ展開機能に関する、
     より完全なドキュメントが付属しています。GNU Emacsや`vi'のことをよく
     知らない人は、このドキュメントを読むとよいでしょう。*Note Command
     Line Editing::。

`show history'
`show history filename'
`show history save'
`show history size'
`show history expansion'
     これらのコマンドは、GDBのヒストリ・パラメータの状態を表示します。単
     に`show history'を実行すると、4つのパラメータの状態がすべて表示され
     ます。

`show commands'
     コマンド・ヒストリ中の最後の10個のコマンドを表示します。

`show commands N'
     コマンド番号Nのコマンドを中心に、その前後の10個のコマンドを表示しま
     す。

`show commands +'
     最後に表示されたコマンドに続く10個のコマンドを表示します。



File: gdb-ja.info, Node: Screen Size, Next: Numbers, Prev: History, Up: Controlling GDB

画面サイズ
==========

 GDBのコマンドは、大量の情報を画面上に出力することがあります。大量の情報
をすべて読むのを支援するために、GDBは1ページ分の情報を出力するたびに、出
力を停止してユーザからの入力を求めます。出力を継続したい場合はRETキーを
押し、残りの出力を破棄したい場合は`q'を入力します。また、画面幅の設定に
よって、どこで行を折り返すかが決まります。GDBは、単純に次の行に折り返す
のではなく、出力の内容に応じて読みやすいところで折り返すよう試みます。

通常 GDBは、termcapデータベースと`TERM'環境変数の値、さらに、`stty rows'、
`stty cols'の設定から、画面の大きさを知っています。この結果が正しくない
場合、`set height'コマンドと`set width'コマンドで画面の大きさの設定を変
更することができます。

`set height LPP'
`show height'
`set width CPL'
`show width'
     これらの`set'コマンドは、画面の高さをLPP行に、幅をCPL桁に指定します。
     関連する`show'コマンドが、現在の設定を表示します。

     ゼロ行の高さを指定すると、GDBは出力がどんなに長くても、出力途中で一
     時停止することをしません。これは、出力先がファイルやエディタのバッ
     ファである場合に便利です。

     同様に、`set width 0'を指定することによって、GDBに行の折り返しを行
     わせないようにすることもできます。



File: gdb-ja.info, Node: Numbers, Next: Messages/Warnings, Prev: Screen Size, Up: Controlling GDB

数値
====

 GDBに対して8進、10進、16進の数値を慣例にしたがって入力することはいつで
も可能です。8進数は`0'で始まります。10進数は`.'で終わります。16進数は
`0x'で始まります。このどれにも該当しないものは、デフォルトで10進数として
入力されます。同様に、数値を表示するときも、特定のフォーマットが指定され
ていなければ、デフォルトで10進数として表示されます。`set radix'コマンド
によって、入力、出力の両方のデフォルトを変更することができます。

`set input-radix BASE'
     数値入力のデフォルトの基数を設定します。サポートされる選択肢は10進
     数の8、10、16です。BASE自身はあいまいにならないように指定するか、あ
     るいは、現在のデフォルトの基数を使用して指定します。例えば、

          set radix 012
          set radix 10.
          set radix 0xa

     は基数を10進数に設定します。一方、`set radix 10'は、現在の基数を
     （それがどれであれ）変更しません。

`set output-radix BASE'
     数値の表示に使うデフォルトの基数を設定します。サポートされるBASEの
     選択肢は10進数の8、10、16です。BASE自身はあいまいにならないように指
     定するか、あるいは、現在のデフォルトの基数を使用して指定します。

`show input-radix'
     数値の入力に現在使われているデフォルトの基数を表示します。

`show output-radix'
     数値の表示に現在使われているデフォルトの基数を表示します。



File: gdb-ja.info, Node: Messages/Warnings, Prev: Numbers, Up: Controlling GDB

オプションの警告およびメッセージ
================================

デフォルトでは、GDBは内部の動作に関する情報を表示しません。性能の遅いマ
シンで実行している場合には、`set verbose'コマンドを使うとよいでしょう。
これによって、GDBは、長い内部処理を実行するときにメッセージを出力するこ
とで、クラッシュと勘違いされないようにします。

現在のところ、`set verbose'コマンドによって制御されるメッセージは、ソー
ス・ファイルのシンボル・テーブルを読み込み中であることを知らせるメッセー
ジです。*Note Commands to specify files: Filesの`symbol-file'を参照して
ください。

`set verbose on'
      GDBが特定の情報メッセージを出力するようにします。

`set verbose off'
      GDBが特定の情報メッセージを出力しないようにします。

`show verbose'
     `set verbose'がon、offのどちらの状態であるかを表示します。

デフォルトでは、オブジェクト・ファイルのシンボル・テーブルに問題を検出し
ても、GDBはメッセージを出力しません。しかし、コンパイラをデバッグしてい
るようなときには、このような情報があると便利かもしれません（*Note Errors
reading symbol files: Symbol Errors.）。

`set complaints LIMIT'
     異常な型のシンボルを検出するたびに GDBが出力するメッセージの総数を
     LIMIT個とします。LIMIT個のメッセージを表示すると、その後は問題を検
     出してもメッセージを表示しないようになります。メッセージを1つも出力
     させないようにするには、LIMITにゼロを指定してください。メッセージの
     出力が抑止されないようにするには、LIMITに大きな値を設定してください。

`show complaints'
      GDBが何個までシンボル異常に関するメッセージを出力できるよう設定されているかを表示します。

デフォルトでは、GDBは慎重に動作し、コマンドを本当に実行するのか確認する
ために、ときには馬鹿げているとさえ思えるような質問を多く尋ねてきます。例
えば、既に実行中のプログラムを実行しようとすると、次のように質問してきま
す。

     ( gdb) run
     The program being debugged has been started already.
     Start it from the beginning? (y or n)

ユーザが、実行したコマンドの結果を何がなんでも見てみたいのであれば、この
「機能」を抑止することができます。

`set confirm off'
     確認要求を行わないようにします。

`set confirm on'
     確認要求を行うようにします（デフォルト）。

`show confirm'
     確認要求の現在の設定を表示します。



File: gdb-ja.info, Node: Sequences, Next: Emacs, Prev: Controlling GDB, Up: Top

一連のコマンドのグループ化
**************************

ブレイクポイント・コマンド（*Note Breakpoint command lists: Break
Commands.）とは別に、一連のコマンドを一括して実行するために保存する2つの
方法を、GDBは提供しています。ユーザ定義コマンドとコマンド・ファイルがそ
れです。

* Menu:

* Define::                      ユーザ定義コマンド
* Hooks::                       ユーザ定義コマンド・フック
* Command Files::               コマンド・ファイル
* Output::                      制御された出力を得るためのコマンド



File: gdb-ja.info, Node: Define, Next: Hooks, Prev: Sequences, Up: Sequences

ユーザ定義コマンド
==================

"ユーザ定義コマンド"とは、一連の GDBコマンドに単一コマンドとしての名前を
新たに割り当てたものです。これは、`define'コマンドによって行われます。ユー
ザ・コマンドは、空白で区切られた引数を最高で10個まで受け取ることができま
す。引数は、ユーザ・コマンドの中で、$ARG0...$ARG9としてアクセスすること
ができます。簡単な例を以下に示します。

     define adder
       print $arg0 + $arg1 + $arg2

このコマンドを実行するには、以下のようにします。

     adder 1 2 3

上の例では、`adder'というコマンドを定義しています。このコマンドは、3つの
引数の合計を表示します。引数は文字列で代用されますので、変数を参照するこ
ともできますし、複雑な式を使うこともできます。また、下位関数の呼び出しを
行うこともできます。

`define COMMANDNAME'
     COMMANDNAMEという名前のコマンドを定義します。同じ名前のコマンドが既
     に存在する場合は、再定義の確認を求められます。

     コマンドの定義は、`define'コマンドに続いて与えられる、他の GDBコマ
     ンド行から構成されます。これらのコマンドの末尾は、`end'を含む行によっ
     て示されます。

`if'
     引数として、評価の対象となる式を1つだけ取ります。その後に一連のコマ
     ンドが続きますが、これらのコマンドは、式の評価結果が真（ゼロ以外の
     値）である場合にだけ実行されます。さらに、`else'行が続くことがあり、
     この場合は、`else'行の後に、式の評価結果が偽であった場合にだけ実行
     される一連のコマンドが続きます。末尾は、`end'を含む行によって示され
     ます。

`while'
     構文は`if'と似ています。引数として、評価の対象となる式を1つだけ取り
     ます。その後には、実行されるべきコマンドが1行に1つずつ続き、最後に
     `end'がなければなりません。コマンドは、式の評価結果が真である限り、
     繰り返し実行されます。

`document COMMANDNAME'
     ユーザ定義コマンドCOMMANDNAMEのドキュメントを記述します。このドキュ
     メントは`help'コマンドによってアクセスできます。コマンドCOMMANDNAME
     は既に定義済みでなければなりません。このコマンドは、`define'コマン
     ドが一連のコマンド定義を読み込むのと同様に、`end'で終わる一連のドキュ
     メントを読み込みます。`document'コマンドの実行が完了すると、コマン
     ドCOMMANDNAMEに対して`help'コマンドを実行すると、ユーザの記述したド
     キュメントが表示されます。

     `document'コマンドを再度実行することによって、コマンドのドキュメン
     トを変更することができます。`define'コマンドによってコマンドを再定
     義しても、ドキュメントは変更されません。

`help user-defined'
     すべてのユーザ定義コマンドを一覧表示します。個々のコマンドにドキュ
     メントがあれば、その1行目が表示されます。

`show user'
`show user COMMANDNAME'
     COMMANDNAMEで指定されるコマンドを定義するのに使われた GDBコマンドを
     表示します（ドキュメントは表示されません）。COMMANDNAMEを指定しない
     と、すべてのユーザ定義コマンドの定義が表示されます。

ユーザ定義コマンドが実行されるときに、定義内のコマンドは表示されません。
定義内のコマンドがどれか1つでもエラーになると、ユーザ定義コマンドの実行
が停止されます。

対話的に使われている場合には確認を求めてくるようなコマンドも、ユーザ定義
コマンドの内部で使われている場合には確認を求めることなく処理を継続します。
通常は実行中の処理に関してメッセージを表示する GDBコマンドの多くが、ユー
ザ定義コマンドの中から呼び出されている場合にはメッセージを表示しません。



File: gdb-ja.info, Node: Hooks, Next: Command Files, Prev: Define, Up: Sequences

ユーザ定義コマンド・フック
==========================

特別な種類のユーザ定義コマンドである、*フック*を定義することができます。
`hook-foo'というユーザ定義コマンドが存在すると、`foo'というコマンドを実
行するときにはいつも、`foo'コマンドが実行される前に（引数のない）
`hook-foo'が実行されます。

また、仮想コマンドである`stop'が存在します。（`hook-stop'を）定義すると、
ユーザ・プログラムの実行が停止するたびに、その定義内のコマンドが実行され
ます。実行タイミングは、ブレイクポイント・コマンドの実行、自動表示対象の
表示、および、スタック・フレームの表示の直前です。

例えば、シングル・ステップ実行をしている際には`SIGALRM'シグナルを無視し、
通常の実行時には通常どおり処理したい場合には、以下のように定義します。

     define hook-stop
     handle SIGALRM nopass
     end

     define hook-run
     handle SIGALRM pass
     end

     define hook-continue
     handle SIGLARM pass
     end

 GDBのコマンドのうち、その名前が1つの単語から成るものには、フックを定義
することができます。ただし、コマンド・エイリアスにフックを定義することは
できません。フックは、コマンドの基本名に対して定義しなければなりません。
例えば、`bt'ではなく`backtrace'を使います。フックの実行中にエラーが発生
すると、GDBコマンドは停止します。（ユーザが実際に入力したコマンドが実行
する機会を与えられる前に）GDBはプロンプトを表示します。

既知のコマンドのいずれにも対応しないフックを定義しようとすると、`define'
コマンドは警告メッセージを表示します。



File: gdb-ja.info, Node: Command Files, Next: Output, Prev: Hooks, Up: Sequences

コマンド・ファイル
==================

 GDBのコマンド・ファイルとは、各行が GDBコマンドとなっているファイルのこ
とです。（行の先頭が`#'の）コメントも含めることができます。コマンド・ファ
イル内の空行は何も実行しません。それは、端末上での実行の場合とは異なり、
最後に実行されたコマンドの繰り返しを意味しません。

 GDBを起動すると、自動的に"初期化ファイル"からコマンドを読み込んで実行し
ます。これは、Unix上では`.gdbinit'という名前のファイルであり、
DOS/Windows上では`gdb.ini'という名前のファイルです。GDBは、ユーザのホー
ム・ディレクトリに初期化ファイルがあればまずそれを読み込み、続いてコマン
ンドライン・オプションとオペランドを処理した後、カレントな作業ディレクト
リに初期化ファイルがあればそれを読み込みます。このように動くのは、ユーザ
のホーム・ディレクトリに初期化ファイルを置くことで、コマンドライン上のオ
プションやオペランドの処理に影響を与える（`set complaints'のような）オプ
ションを設定することができるようにするためです。`-nx'オプションを使用す
ると、初期化ファイルは実行されません。*Note Choosing modes: Mode
Options.。

 GDBのいくつかの構成では、初期化ファイルは異なる名前で知られています（こ
のような環境では、特別な形式の GDBが他の形式の GDBと共存する必要があり、
そのために特別なバージョンの GDBの初期化ファイルには異なる名前が付けられ
ます）。特別な名前の初期化ファイルを持つ環境には、以下のようなものがあり
ます。

   * VxWorks（Wind River Systems社のリアルタイムOS）: `.vxgdbinit'

   * OS68K（Enea Data Systems社のリアルタイムOS）: `.os68gdbinit'

   * ES-1800（Ericsson Telecom社のAB M68000エミュレータ）: `.esgdbinit'

また、`source'コマンドによって、コマンド・ファイルの実行を要求することも
できます。

`source FILENAME'
     コマンド・ファイルFILENAMEを実行します。

コマンド・ファイルの各行は順番に実行されます。コマンドの実行時に、そのコ
マンドは表示されません。どれか1つでもコマンドがエラーになると、コマンド・
ファイルの実行は停止されます。

対話的に使われている場合には確認を求めてくるようなコマンドも、コマンド・
ファイル内で使われている場合は確認を求めることなく処理を継続します。通常
は実行中の処理についてメッセージを表示する GDBコマンドの多くが、コマンド・
ファイルの中から呼び出されている場合にはメッセージを表示しません。



File: gdb-ja.info, Node: Output, Prev: Command Files, Up: Sequences

制御された出力を得るためのコマンド
==================================

コマンド・ファイルやユーザ定義コマンドの実行中には、通常の GDBの出力は抑
止されます。唯一出力されるのは、定義内のコマンドが明示的に表示するメッセー
ジだけです。ここでは、ユーザが希望するとおりの出力を生成するのに役に立つ、
3つのコマンドについて説明します。

`echo TEXT'
     TEXTを表示します。
     通常は表示されない文字も、
     Cのエスケープ・シーケンスを使うことでTEXTの中に含めることができます。
     例えば、
     改行コードを表示するには`\n'を使います。
     *明示的に指定しない限り、
     改行コードは表示されません。*
     標準的なCのエスケープ・シーケンスに加えて、
     バックスラッシュの後ろに空白を置くことで、
     空白が表わされます。
     これは、
     先頭や末尾に空白のある文字列を表示するのに便利です。
     というのは、
     こうしないと、
     引数の先頭や末尾の空白は削除されるからです。
     ` and foo = 'を表示するには、
     `echo \ and foo = \ 'を実行してください。

     Cと同様、TEXTの末尾にバックスラッシュを置くことで、コマンドを次の行
     以降に継続することができます。例えば、

          echo This is some text\n\
          which is continued\n\
          onto several lines.\n

     は

          echo This is some text\n
          echo which is continued\n
          echo onto several lines.\n

     と同じ出力をもたらします。

`output EXPRESSION'
     EXPRESSIONの値を表示し、それ以外には何も表示しません。改行コードも、
     `$NN = 'も表示されません。EXPRESSIONの値は値ヒストリには入りません。
     式の詳細については、*Note Expressions: Expressions。

`output/FMT EXPRESSION'
     EXPRESSIONの値を、FMTで指定されるフォーマットで表示します。`print'
     コマンドと同じフォーマットを指定することができます。詳細については、
     *Note Output formats: Output Formats。

`printf STRING, EXPRESSIONS...'
     STRINGで指定された文字列にしたがってEXPRESSIONSの値を表示します。複
     数のEXPRESSIONSはカンマで区切られ、数値かポインタのいずれかを指定で
     きます。これらの値は、ユーザ・プログラムからCのサブルーチン

          printf (STRING, EXPRESSIONS...);

     を実行した場合と同様に、STRINGの指定にしたがって表示されます。

     例えば、次のようにして2つの値を16進数で表示することができます。

          printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo

     フォーマットを指定する文字列の中で使えるバックスラッシュ・エスケー
     プ・シーケンスは、バックスラッシュとそれに続く単一文字から構成され
     る簡単なものだけです。



File: gdb-ja.info, Node: Emacs, Next: Installing GDB, Prev: Sequences, Up: Top

GNU Emacsの中での GDBの使用
***************************

 GDBでデバッグ中のプログラムのソース・ファイルをGNU Emacsを使って参照
（および編集）するための、特別なインターフェイスが提供されています。

このインターフェイスを使うには、Emacsの中で`M-x gdb'コマンドを使います。
デバッグしたい実行ファイルを引数として指定してください。このコマンドは、
GDBをEmacsのサブプロセスとして起動し、新しく作成したEmacsバッファを通じ
て入出力を行います。

Emacsの中での GDBの使い方は、通常の GDBの使い方とほぼ同様ですが、2つ相違
点があります。

   * 「端末」へのすべての入出力はEmacsバッファへ送られる。

これは、GDBコマンドとその出力、および、デバッグ対象のユーザ・プログラム
による入出力の両方に適用されます。

以前に実行したコマンド・テキストをコピーして再入力することができるので便
利です。出力された部分に関しても同様のことができます。

EmacsのShellモードで利用可能なすべての機能を、ユーザ・プログラムとのやり
とりで使うことができます。特に、通常どおりにシグナルを送信することができ
ます。例えば、`C-c C-c'で割り込みシグナルを、`C-c C-z'でストップ・シグナ
ルを発生させることができます。

   *  GDBはEmacsを使ってソース・コードを表示する。

 GDBがスタック・フレームを表示するときにはいつでも、Emacsがそのフレーム
のソース・ファイルを自動的に見つけて、カレント行の左側の余白に矢印（`=>'）
を表示します。Emacsはソース・コードを別バッファに表示し、スクリーンを2つ
に分けて、GDBセッションとソースをともに表示します。

 GDBの`list'コマンドや`search'コマンドを明示的に使えば、通常どおりの出力
を生成することもできますが、これらをEmacsから使う理由はおそらくないでしょ
う。

     *注意:* ユーザ・プログラムの存在するディレクトリがユーザのカレント・
     ディレクトリでない場合、ソース・ファイルの存在場所についてEmacsは簡
     単に混乱に陥ります。このような場合、ソースを表示するための追加のディ
     スプレイ・バッファは表示されません。GDBは、ユーザの環境変数`PATH'の
     リストの中にあるディレクトリを探索してプログラムを見つけ出しますの
     で、GDBの入出力セッションは通常どおり進行します。しかしEmacsは、こ
     のような状況においてソース・ファイルを見つけ出すのに十分な情報を 
     GDBから受け取っていません。この問題を回避するには、ユーザ・プログラ
     ムの存在するディレクトリから GDBモードを開始するか、`M-x gdb'の引数
     の入力を求められたときに、絶対パスでファイル名を指定します。

     Emacsの既存の GDBバッファから、デバッグ対象をどこかほかの場所にある
     プログラムに変更する目的で GDBの`file'コマンドを使うと、同様の混乱
     の発生することがあります。

デフォルトでは、`M-x gdb'は`gdb'という名前のプログラムを呼び出します。別
の名前で GDBを呼び出す必要がある場合（例えば、異なる構成の GDBを別の名前
で持っているような場合）は、Emacsの`gdb-command-name'という変数を設定し
ます。例えば

     (setq gdb-command-name "mygdb")

（を`ESC ESC'に続けて入力するか、あるいは、`*scratch*'バッファまたは
`.emacs'ファイルに入力することで）Emacsは`gdb'の代わりに「`mygdb'」とい
う名前のプログラムを呼び出します。

 GDBのI/Oバッファでは、標準的なShellモードのコマンドに加えて、以下のよう
な特別なEmacsコマンドを使うことができます。

`C-h m'
     Emacsの GDBモードの機能に関する説明を表示します。

`M-s'
      GDBの`step'コマンドのように、ソース行を1行実行します。さらに、カレ
     ントなファイルとその中における位置を示すために、表示ウィンドウを更
     新します。

`M-n'
      GDBの`next'コマンドのように、関数呼び出しをすべてスキップして、現
     在の関数内の次のソース行まで実行を進めます。さらに、カレントなファ
     イルとその中における位置を示すために、表示ウィンドウを更新します。

`M-i'
      GDBの`stepi'コマンドのように、1命令を実行します。必要に応じて表示
     ウィンドウを更新します。

`M-x gdb-nexti'
      GDBの`nexti'コマンドを使って、次の命令まで実行します。必要に応じて
     表示ウィンドウを更新します。

`C-c C-f'
      GDBの`finish'コマンドのように、選択されたスタック・フレームを終了
     するまで実行を継続します。

`M-c'
      GDBの`continue'コマンドのように、ユーザ・プログラムの実行を継続し
     ます。

     *注意:* Emacs v19では、このコマンドは`C-c C-p'です。

`M-u'
      GDBの`up'コマンドのように、数値引数によって示される数だけ上位のフ
     レームに移動します（*Note Numeric Arguments: (Emacs)Arguments. (1)
     (*Note Emacs-Footnotes::)）。

     *注意:* Emacs v19では、このコマンドは`C-c C-u'です。

`M-d'
      GDBの`down'コマンドのように、数値引数によって示される数だけ下位の
     フレームに移動します。

     *注意:* Emacs v19では、このコマンドは`C-c C-d'です。

`C-x &'
     カーソルの位置にある数値を読み取り、GDBのI/Oバッファの末尾に挿入し
     ます。例えば、以前に表示されたアドレスの前後のコードを逆アセンブル
     したいとしましょう。この場合、まず`disassemble'と入力し、次に表示さ
     れたアドレスのところにカーソルを移動し、`disassemble'への引数を`C-x
     &'で読み取ります。

     `gdb-print-command'リストの要素を定義することによって、これをさらに
     カスタマイズすることができます。これが定義されていると、`C-x &'で入
     手した数値が挿入される前に、それをフォーマットしたり、処理したりす
     ることができるようになります。`C-x &'に数値引数を指定すると、特別な
     フォーマット処理を必要としているという意味になり、その数値がリスト
     の要素を取得するためのインデックスとなります。リストの要素が文字列
     の場合は、挿入される数値はEmacsの`format'関数によってフォーマットさ
     れます。リストの要素が文字列以外の場合は、その数値が、対応するリス
     ト要素への引数として渡されます。

どのソース・ファイルが表示されている場合でも、Emacsの`C-x SPC'
（`gdb-break'）コマンドは、ポイントの置かれているソース行にブレイクポイ
ントを設定するよう GDBに対して指示します。

ソースを表示中のバッファを誤って削除してしまった場合に、それを再表示させ
る簡単な方法は、GDBバッファの中で`f'コマンドを入力して、フレーム表示を要
求することです。Emacs配下では、カレント・フレームのコンテキストを表示す
るために必要であれば、ソース・バッファが再作成されます。

Emacsによって表示されるソース・ファイルは、通常どおりの方法でソース・ファ
イルにアクセスする、普通のEmacsバッファによって表示されます。そうしたい
のであれば、これらのバッファの中でファイルの編集を行うこともできますが、
GDBとEmacsの間で行番号に関する情報が交換されていることを頭に入れておいて
ください。テキストに行を挿入したり、削除したりすると、GDBの認識している
ソース行番号は、実際のコードと正しく対応しなくなってしまいます。



File: gdb-ja.info  Node: Emacs-Footnotes, Up: Emacs

(1) 訳注：`GNU Emacs 19 マニュアル'（星雲社）の「ニューメリッ
ク引数」、`GNU Emacs マニュアル'（共立出版）の「数引数」に、日
本語訳があります。



File: gdb-ja.info, Node: GDB Bugs, Next: Installing GDB, Prev: Emacs, Up: Top

 GDBのバグ報告
**************

ユーザからのバグ報告は、GDBの信頼性を向上させるのに重要な役割を果たして
います。

バグを報告することで、その問題の解決につながり、結果として報告者自ら利益
を得ることができるかもしれません。もちろん、何の解決にもつながらないこと
もあります。しかし、いずれにしても、バグ報告の主要な意義は、次のバージョ
ンの GDBをより良いものにすることで、コミュニティ全体の役に立つという点に
あります。バグ報告は、GDBの保守作業へのユーザからの貢献です。

バグ報告がその目的とするところを首尾よく達成できるようにするためには、バ
グを修正することを可能にするような情報が提供されなければなりません。

* Menu:

* Bug Criteria::                本当にバグを見つけたのかどうかを知る方法
* Bug Reporting::               バグの報告方法



File: gdb-ja.info, Node: Bug Criteria, Next: Bug Reporting, Prev: Emacs, Up: Emacs

本当にバグを見つけたのかどうかを知る方法
========================================

発見した現象がバグかどうかよく分からない場合には、以下のガイドラインを参
照してください。

   * 入力された情報が何であれ、デバッガが致命的なシグナルを受信するので
     あれば、それは GDBのバグです。信頼性のあるデバッガは決してクラッシュ
     などしません。

   * 正当な入力に対して GDBがエラー・メッセージを出力するのであれば、そ
     れはバグです。（クロス・デバッグを行っている場合には、ターゲットへ
     の接続に問題がある可能性もあるということに注意してください。）

   * 不正な入力に対して GDBがエラー・メッセージを出力しないのであれば、
     それはバグです。ただし、ユーザにとって「不正な入力」に思えるものが、
     実は「拡張機能」であったり「古くから使われている用法のサポート」で
     あったりすることもあります。

   * デバッグ・ツールに関する経験が豊富なユーザからの GDBの改善提案は、
     どのような場合でも歓迎です。 (1) (*Note Bug Criteria-Footnotes::)


File: gdb-ja.info  Node: Bug Criteria-Footnotes, Up: Bug Criteria

(1) 訳注：この日本語の翻訳マニュアルへの改善提案は、
ki@home.email.ne.jpに送ってください。



File: gdb-ja.info, Node: Bug Reporting, Prev: Bug Criteria, Up: Emacs

バグの報告方法
==============

いくつかの企業や個人がGNUのソフトウェアをサポートしています。こうしたサ
ポート組織から GDBを入手したのであれば、まずその組織に連絡することをお勧
めします。

サポートを提供している多くの企業、個人の連絡先情報が、GNU Emacsディスト
リビューションの`etc/SERVICE'ファイルに記載されています。

どのような場合でも、GDBのバグ報告を（英語で）以下のアドレスに送ることを
お勧めします。 (1) (*Note Bug Reporting-Footnotes::)

     bug-gdb@prep.ai.mit.edu

*`info-gdb'、`help-gdb'、および、いかなるニュースグループにもバグ報告を
送ることはしないでください。* GDBユーザのほとんどは、バグ報告を受け取り
たいと考えてはいません。バグ報告を受け取りたいと思っている人は、
`bug-gdb'の配信を受けるようにしているはずです。

メーリング・リスト`bug-gdb'には、リピータとして機能する`gnu.gdb.bug'とい
うニュースグループがあります。このメーリング・リストとニュースグループは、
全く同一のメッセージを配信しています。メーリング・リストではなくニュース
グループにバグ報告を流そうと考える人がよくいます。これはうまく機能するよ
うに見えますが、1つ重大な問題があります。ニュースグループへの投稿では、
送信者へのメール・パスが分からないことがよくあります。したがって、もっと
多くの情報が必要になったときに、バグの報告者と連絡を取ることができない可
能性があります。こういうことがあるので、メーリング・リストへのバグ報告の
方が望ましいのです。

最後の手段として、バグ報告を（英語で）紙に書いて下記に郵送するという方法
があります。

     GNU Debugger Bugs
     Free Software Foundation Inc.
     59 Temple Place - Suite 330
     Boston, MA 02111-1307
     USA


役に立つバグ報告を行うための最も根本的な原則は、*すべての事実を報告する*
ことです。ある事実を書くべきか省くべきかよく分からない場合は、書くように
してください。

事実が省略されてしまうことがよくありますが、これはバグ報告者が、自分には
問題の原因は既に分かっていると考え、いくつかの細かい点は関係がないと仮定
してしまうからです。したがって、例の中で使った変数の名前などは重要ではな
いと、報告者は考えます。おそらくそうかもしれません。しかし、完全にそうで
あるとも言い切れません。メモリの参照がデタラメな場所を指しているというバ
グで、それがたまたまメモリ上においてその名前が置かれている箇所から値を取
り出しているということがあるかもしれません。名前が異なれば、そこの内容は、
バグが存在するにもかかわらずデバッガが正しく動作してしまうような値になる
かもしれません。このようなことがないよう、特定の完全な実例を提供してくだ
さい。バグの報告者にとっては、このようにするのが最も簡単なはずであり、か
つ、それが最も役に立つのです。

バグ報告の目的は、そのバグを修正することができるようにすることにある、と
いう点を頭に入れておいてください。そのバグが、以前に報告されたものと同じ
であるという可能性もありますが、バグ報告が完全なもので、必要な情報がすべ
て含まれたものでなければ、バグの報告者にも私たちにもそのことを知ることが
できません。

ときどき、2、3の大雑把な事実だけを記述して、「何か思い当たることはありま
すか?」と聞いてくる人がいます。このようなバグ報告は役に立ちません。この
ような報告には、より適切なバグ報告を送るよう報告者に注意する場合を除いて、
*返事をすることを拒否する*よう強くお願いします。

バグを修正できるようにするためには、報告者は以下の情報をすべて含めるべき
です。

   *  GDBのバージョン。GDBのバージョンは、引数を指定せずに GDBを起動する
     と、表示されます。また、いつでも`show version'コマンドで表示させる
     ことができます。

     この情報がないと、カレント・バージョンの GDBを使ってバグを探すこと
     に意味があるのかどうかを知ることができません。

   * 使っているマシンのタイプ、オペレーティング・システムの名前とバージョ
     ン番号。

   *  GDBをコンパイルするのに使われたコンパイラ（および、そのバージョン）。
     例えば、gcc--2.8.1。

   * デバッグ対象のプログラムをコンパイルするのに使われたコンパイラ（お
     よび、そのバージョン）。例えば、gcc--2.8.1、あるいは、HP92453-01
     A.10.32.03 HP Cコンパイラ。GCCについては、`gcc --version'によってこ
     の情報を知ることができます。他のコンパイラについては、そのドキュメ
     ントを参照してください。

   * バグを見つけたプログラムをコンパイルする際に、コンパイラに渡したコ
     マンド引数。例えば、`-O'オプションを使ったか否かなど。何か重要な点
     を省いてしまうことがないよう、すべての引数を記述してください。
     `Makefile'のコピー（あるいは、`make'からの出力）を添付すれば十分で
     しょう。

     引数が何であったのかを私たちが推測しようとしても、おそらく誤った推
     測をしてしまうでしょう。そうなると、バグは再現しないかもしれません。

   * バグを再現することのできる、完全な入力スクリプトとすべての必要なソー
     ス・ファイル。

   * 発見された、正しくないと思われる動作の説明。例えば、「致命的なシグ
     ナルを受信する」など。

     もちろん、GDBが致命的なシグナルを受信するというバグであれば、私たち
     も間違いなくそれに気がつくでしょう。しかし、出力が正しくないという
     バグであれば、紛れもない誤りでなければ、私たちはそれに気付かないか
     もしれません。私たちが間違いをする可能性を排除するようにしてくださ
     い。

     たとえ致命的なシグナルを受信するような問題であっても、報告者はその
     ことを明示的に報告するべきです。何か奇妙なことが起こっていると仮定
     しましょう。例えば、報告者が使っている GDBにちぐはぐなところがある
     とか、報告者のシステム上にあるCライブラリのバグだった、というような
     場合です（こういうことは、実際にありました！）。このような場合、報
     告者の GDBはクラッシュしても、私たちのところではクラッシュしません。
     クラッシュするはずであると報告されていれば、私たちの GDBがクラッシュ
     しなくても、「私たちのところではバグが発生しない」ということを知る
     ことができます。クラッシュするはずであるという報告がなければ、実際
     の現象から何も結論を引き出すことができません。

   * もし GDBのソースへの修正を提案したいのであれば、コンテキスト付きの
     差分情報を送ってください。GDBのソースについて何か議論する場合も、行
     番号に言及するのではなく、コンテキストに言及してください。

     私たちが開発中のソースの行番号は、報告者の持っているソースの行番号
     とは一致しないでしょう。報告者から見たソースの行番号は、私たちにとっ
     て役に立つ情報を提供してくれません。

以下に、バグ報告に必要ではない情報をいくつか列挙します。

   * バグの包括的な説明。

     バグを見つけると、多くの時間をかけて、入力ファイルをどのように変更
     するとバグが発生しなくなり、どのように変更した場合はバグが発生し続
     けるかを調べる人がよくいます。

     これは多くの場合、時間のかかる作業であり、しかもあまり役に立ちませ
     ん。というのは、私たちがバグを見つけるのは、デバッガでブレイクポイ
     ントを使いながら1つの実例を実行させることによってであり、一連の実例
     からの純粋な演繹によってではないからです。時間を無駄にせず、何かほ
     かのことに使うようお勧めします。

     もちろん、一番最初にバグを見つけたときの実例の*代わり*となる、もっ
     と単純な実例を見つけることができるのであれば、私たちにとっても便利
     です。出力におけるエラーはより発見しやすいものですし、デバッガ配下
     で実行させる方が時間がかかりません。

     しかし、単純化は絶対に必要というわけでもありません。こういうことを
     したくないのであれば、バグを発見したときのテスト・ケース全体を送っ
     て、バグの報告を行ってください。

   * バグに対するパッチ。

     バグに対するパッチは、それが良いものであれば、役に立ちます。しかし、
     パッチがあれば十分であるとみなして、テスト・ケースのような必要な情
     報を送るのを省かないでください。提供されたパッチに問題があり、別の
     方法で問題を修正することにする場合もありますし、提供されたパッチを
     全く理解できないということもあるかもしれません。

      GDBのような複雑なプログラムでは、コード中のある特定のパスを通るよ
     うな実例を作成するのは困難なことがあります。報告者が実例を送ってく
     れなければ、私たちには実例を作成することができず、したがって、バグ
     が修正されたことを検証することができなくなってしまいます。

     また、報告者の送ってくれたパッチがどのような問題を修正しようとして
     いるのか私たちに理解できない場合、あるいは、なぜそのパッチが改善に
     なるのか私たちが理解できない場合、そのパッチを組み込むことはしませ
     ん。テスト・ケースが1つでもあれば、そうしたことを理解するのに役立つ
     でしょう。

   * バグが何であるか、あるいは、何に依存しているかに関する推測。

     このような推測は普通は間違っているものです。私たちですら、デバッガ
     を使って事実を見出すまでは、このような点に関して正しく推測すること
     はできないのです。






File: gdb-ja.info  Node: Bug Reporting-Footnotes, Up: Bug Reporting

(1) 訳注：この日本語の翻訳マニュアルのバグは、日本語（か英語）で、
ki@home.email.ne.jpに報告してください。



File: gdb-ja.info, Node: Command Line Editing

コマンドライン編集
******************

この章では、GNUのコマンドライン編集インターフェイスの基本的な特徴につい
て説明します。

* Menu:

* Introduction and Notation::	表記法
* Readline Interaction::	行編集のための最小限のコマンド・セット
* Readline Init File::		ユーザの見地からのReadlineのカスタマイズ
* Bindable Readline Commands::	バインディングを行うために利用可能なほとんどの
                                Readlineコマンドの説明
* Readline vi Mode::		Readlineをviエディタのように振る舞わせる方法の
                                簡単な説明



File: gdb-ja.info, Node: Introduction and Notation

行編集入門
==========

以下のパラグラフでは、キー・ストロークを表わすために使用される表記法につ
いて説明します。

C-kは、Control-Kという意味です。これは、コントロール・キーが押されたまま
の状態でキーkが押されたときに生成される文字を表わします。

M-kは、Meta-Kという意味です。これは、メタ・キー（があるものとして、それ）
が押されたままの状態でキーkが押されたときに生成される文字を表わします。
メタ・キーがない場合、最初にESCキーを押し、次にキーkを押すことで、同等の
キー・ストロークを生成することができます。どちらの手順も、キーkを"メタ化
"する、といいます。

M-C-kは、Meta-Control-Kという意味です。これは、C-kを"メタ化"することによ
り生成される文字を指します。

さらに、いくつかのキーには名前があります。DEL、ESC、LFD、SPC、RET、TABは、
この文章の中でも、初期化ファイルの中でも、各々のキーを表わします（*Note
Readline Init File::）。



File: gdb-ja.info, Node: Readline Interaction

Readlineの操作
==============

対話的なセッションにおいて、長いテキストを1行に記述した後で、その行の先
頭の単語のスペルが間違っていたことに気が付くことがよくあります。Readline
ライブラリは、入力したテキストを操作するための一連のコマンドを提供してお
り、これによって、その行の大部分を入力し直すことなく、タイプ・ミスしたと
ころだけを修正することができます。これらの編集コマンドを使って、修正が必
要なところにカーソルを移動させ、テキストを削除したり、修正テキストを挿入
したりします。その行の修正が終われば、単にRETURNを押します。RETURNを押す
のに、行末にいる必要はありません。カーソルが行内のどこにあろうと、その行
全体が入力として受け付けられます。

* Menu:

* Readline Bare Essentials::	Readlineについて最低限知っていなければならないこと
* Readline Movement Commands::	入力行の中での移動
* Readline Killing Commands::	テキストの削除と再入手
* Readline Arguments::		コマンドへの数値引数の指定
* Searching::			以前の行の中の検索
 


File: gdb-ja.info, Node: Readline Bare Essentials

Readlineの基本
--------------

行内に文字を入力するには、
単にその文字をタイプします。
タイプされた文字はカーソルの位置に表示され、
カーソルは1桁分右へ移動します。
1文字打ち間違えた場合は、
削除文字（erase character）を使って、
後退しながら打ち間違えた文字を削除することができます。

ときには、
本当は入力したかった文字を入力せず、
その誤りに気が付くことなく、
さらに数文字を入力してしまうということがあります。
このような場合には、
C-bによってカーソルを左に移動し、
誤りを訂正することができます。
訂正後、
C-fによってカーソルを右に移動することができます。

行の途中にテキストを追加すると、
挿入されたテキストのためのスペースを空けるために、
カーソルの右側にある文字が右方向に押しやられることに気がつくでしょう。
同様に、
カーソル位置にあるテキストを削除すると、
文字が削除されたために生じる空白を埋めるために、
カーソルの右側にある文字が左方向に引き戻されます。
入力行のテキストを編集するための最も基本的な操作の一覧を以下に示します。

C-b
     1文字戻ります。
C-f
     1文字進みます。
DEL
     カーソルの左にある文字を削除します。
C-d
     カーソル位置にある文字を削除します。
表示可能な文字
     行内のカーソル位置にその文字を挿入します。
C-_
     最後の編集コマンドを取り消して元に戻します。
     行内に文字が無くなるまで取り消しを繰り返すことが可能です。



File: gdb-ja.info, Node: Readline Movement Commands

Readline移動コマンド
--------------------


上記の一覧は、
ユーザが入力行を編集するのに必要な、
最も基本的なキー・ストロークを説明したものです。
ユーザの利便を考慮して、
C-b、
C-f、
C-d、
DELに加えて多くのコマンドが追加されてきました。
以下に、
行内をより迅速に動きまわるためのコマンドをいくつか示します。

C-a
     行の先頭に移動します。
C-e
     行の末尾に移動します。
M-f
     1単語分先に進みます。
     単語は、
     文字と数字から構成されます。
M-b
     1単語分前に戻ります。
C-l
     画面上の情報を消去し、
     カレント行が画面の一番上にくるようにして再表示します。

C-fが1文字分先に進むのに対して、
M-fが1単語分先に進む点に注意してください。
大まかな慣例として、
コントロール・キーを使うと文字単位の操作になり、
メタ・キーを使うと単語単位の操作になります。



File: gdb-ja.info, Node: Readline Killing Commands

Readlineキル（kill）コマンド
----------------------------


テキストを"キル（kill）"するとは、
行からテキストを削除し、
その際に、
そのテキストを後に引き出して行内に"再挿入（yank）"することができるように退避しておくことを指します。
あるコマンドの説明に「テキストをキル（kill）する」という記述があれば、
後に別の箇所
（あるいは同じ箇所）
において、
そのテキストを再入手することができると考えて間違いありません。

キル（kill）コマンドを使うと、
テキストは"キル・リング（kill-ring）"に退避されます。
キル（kill）コマンドを任意の回数連続して実行すると、
キル（kill）されたテキストはすべて連結されて退避されます。
したがって、
再挿入（yank）を行うと、
そのすべてを入手することができます。
キル・リング（kill-ring）は個々の行に固有のものではありません。
以前入力した行においてキル（kill）したテキストを、
後になって別の行を入力しているときに再挿入（yank）することができます。

以下に、テキストをキル（kill）するためのコマンドを一覧で示します。

C-k
     カレントなカーソル位置から行末までのテキストをキル（kill）します。

M-d
     カーソル位置から、
     カーソルの置かれている単語の末尾までをキル（kill）します。
     カーソルが2つの単語の間にあるときは、
     次の単語の末尾までをキル（kill）します。

M-DEL
     カーソル位置から、
     カーソルの置かれている単語の先頭までをキル（kill）します。
     カーソルが2つの単語の間にあるときは、
     前の単語の先頭までをキル（kill）します。

C-w
     カーソル位置から、
     それより前にある最初の空白までをキル（kill）します。
     単語間の境界が異なるので、
     これはM-DELとは異なります。


キル（kill）されたテキストを引き出して行内へ"再挿入（yank）"する方法を、
以下に示します。
再挿入（yank）とは、
最後にキルされたテキストを、
キル・バッファからコピーすることを意味しています。

C-y
     バッファ内のカーソル位置に、
     最後にキル（kill）されたテキストを再挿入（yank）します。

M-y
     キル・リング（kill-ring）を回転させ、
     新たに一番上にきたテキストを再挿入（yank）します。
     このコマンドを実行できるのは、
     1つ前に実行したコマンドがC-yまたはM-yの場合だけです。



File: gdb-ja.info, Node: Readline Arguments

Readlineの引数
--------------

Readlineコマンドには数値引数を渡すことができます。
数値引数は、
繰り返し回数として使われたり、
引数の符号として使われたりします。
通常は先に進むようなコマンドに負の数を引数として指定すると、
前に戻るようになります。
例えば、
行の先頭までのテキストをキル（kill）するには、
`M-- C-k'としてもよいでしょう。

コマンドに数値引数を渡す通常の方法は、
コマンドの前にメタ化された数字を入力することです。
入力された最初の「数字」がマイナス記号（-）の場合、
引数の符号は負になります。
引数を開始するためには、
メタ化された数字を1つだけ入力すればよく、
残りの数字はそのまま入力することができます。
そして最後にコマンドを入力します。
例えば、
C-dコマンドに引数として10を渡すためには、
`M-1 0 C-d'と入力します。



File: gdb-ja.info, Node: Searching

ヒストリ中のコマンドの検索
--------------------------

readlineは、
コマンド・ヒストリ
(*Note Bash History Facilities::)
の中から、
指定された文字列を含む行を検索するコマンドを提供しています。
インクリメンタル（INCREMENTAL）と
非インクリメンタル（NON-INCREMENTAL）の2つの検索モードがあります。

インクリメンタル（incremental）・モードでは、
ユーザが検索文字列を入力し終わる前から検索が始まります。
検索文字列の中の文字が1つ入力されるたびに、
readlineは、
それまで入力された文字列にマッチする、
ヒストリの中の次のエントリを表示します。
インクリメンタル・モードの検索では、
検索したいヒストリ・エントリを見つけるのに本当に必要となる文字だけを入力するだけで済みます。
インクリメンタル・モードの検索を中止するのには、
ESC文字を使います。
C-jでも、
検索は中止されます。
C-gは、
インクリメンタル・モードの検索を終了させて、
元の行を表示します。
検索が中止されると、
検索文字列を含むヒストリ・エントリがカレント行となります。
検索文字列にマッチする他のエントリをヒストリ・リストから見つけるためには、
必要に応じてC-sまたはC-rを入力します。
これによって、
それまでに入力された検索文字列にマッチする次のエントリをヒストリから見つけるために、
下の方向、
または、
上の方向に検索が行われます。
Readlineコマンドにバインドされているキー・シーケンスのうち上記以外のものを入力すると、
検索は中止され、
そのコマンドが実行されます。
例えば
RETが入力されると、
検索は中止され、
そのときの行が受け入れられたことになります。
したがって、
ヒストリ・リストの中のそのコマンドが実行されます。

非インクリメンタル（non-incremental）・モードでは、
マッチするヒストリ行の検索を開始する前に、
検索文字列全体を読み込みます。
検索文字列は、
ユーザによって入力されたものでも構いませんし、
カレント行の内容の一部であっても構いません。



File: gdb-ja.info, Node: Readline Init File

Readline初期化ファイル
======================

Readlineライブラリには、
`emacs'スタイルのキー・バインディングがデフォルトで組み込まれていますが、
異なるキー・バインディングを使うこともできます。
ホーム・ディレクトリ内のファイル"inputrc"にコマンドを記述することで、
誰でもReadlineを使うプログラムをカスタマイズすることができます。
このファイルの名前は、
シェル変数`INPUTRC'の値から取られます。
環境変数`INPUTRC'の値から取られます。
この変数に値がセットされていない場合のデフォルトは、
`~/.inputrc'です。

Readlineライブラリを使うプログラムが起動されると、
初期化ファイルが読み込まれ、
キー・バインディングが設定されます。

さらに、
`C-x C-r'コマンドを実行すると、
この初期化ファイルが再読み込みされます。
初期化ファイルに変更が加えられていれば、
その変更が反映されます。

* Menu:

* Readline Init File Syntax::	inputrcファイルの中におけるコマンドの構文

* Conditional Init Constructs::	inputrcファイルの中における条件キー・バインディング

* Sample Init File::		inputrcファイルの例



File: gdb-ja.info, Node: Readline Init File Syntax

Readline初期化ファイルの構文
----------------------------

Readline初期化ファイルの中では、ほんの少数の基本的な構文だけが使用できま
す。空行は無視されます。`#'で始まる行はコメントです。`$'で始まる行は、条
件構文を表わします（*Note Conditional Init Constructs::）。その他の行は、
変数設定とキー・バインディングを示します。

変数設定
     初期化ファイルの中で`set'コマンドを使用してReadlineの変数の値を変更
     することによって、Readlineの実行時の振る舞いを変更することができま
     す。デフォルトのEmacsスタイルのキー・バインディングを変更して、`vi'
     の行編集コマンドを使用できるようにするには、以下のようにします。

          set editing-mode vi

     以下の変数によって、実行時の振る舞いのかなりの部分が変更可能です。


     `bell-style'
          Readlineが端末のベル音を鳴らしたいと判断した場合に、何が起こる
          かを制御します。`none'がセットされると、Readlineはベル音を鳴ら
          しません。`visible'がセットされると、視覚的なベル (1) (*Note
          Readline Init File Syntax-Footnotes::) が利用可能であれば、そ
          れを使います。`audible'（デフォルト）がセットされると、
          Readlineは、端末のベル音を鳴らそうと試みます。

     `comment-begin'
          `insert-comment'コマンドが実行されたときに、行の先頭に挿入され
          る文字列です。デフォルトの値は`"#"'です。

     `completion-ignore-case'
          `on'がセットされると、Readlineは、大文字・小文字を区別せずに、
          ファイル名のマッチングや補完を行います。デフォルトの値は`off'
          です。

     `completion-query-items'
          ユーザに対して補完候補の一覧を見たいかどうか問い合わせるタイミ
          ングを決定する、補完候補の数です。補完候補の数がこの値よりも多
          いと、Readlineは、補完候補の一覧を見たいかどうかをユーザに対し
          て問い合わせることになります。この値よりも少ない場合は、問い合
          わせを行うことなく一覧を表示します。デフォルトの境界は`100'で
          す。

     `convert-meta'
          `on'がセットされると、Readlineは、第8ビットがセットされている
          文字をASCIIのキー・シーケンスに変換します。これは、該当文字の
          第8ビットを落として、その前にESC文字を付加することで、メタ・プ
          レフィックス・キー・シーケンス（meta-prefixed key sequence）に
          変換することによって行われます。デフォルトの値は`on'です。

     `disable-completion'
          `On'がセットされると、Readlineは単語補完を抑制します。補完文字
          （completion character）は、あたかも`self-insert'にマップされ
          たかのように、行内に挿入されます。デフォルトは`off'です。

     `editing-mode'
          `editing-mode'変数は、デフォルトで使用するキー・バインディング
          の種類を制御します。Readlineは、デフォルトの状態では、Emacs編
          集モードで起動します。このモードは、キー・ストロークがEmacsに
          非常に良く似ています。この変数は、`emacs'と`vi'のどちらかに設
          定することができます。

     `enable-keypad'
          `on'がセットされると、Readlineは、呼び出されたときに、アプリケー
          ション・キーパッド（application keypad）を有効にすることを試み
          ます。システムによっては、矢印キーを使用できるようにするために、
          これが必要となります。デフォルトは`off'です。

     `expand-tilde'
          `on'がセットされると、Readlineが単語補完を試みる際に、チルダの
          展開が行われます。デフォルトは`off'です。

     `horizontal-scroll-mode'
          この変数は、`on'と`off'のどちらかに設定することができます。こ
          れを`on'に設定すると、1行のテキストの長さがスクリーン幅よりも
          長い場合に、編集中の行のテキストが次の行に折り返すことなく、同
          じ行の上で水平方向にスクロールするようになります。デフォルトで
          は、この変数には`off'がセットされています。

     `keymap'
          Readlineが認識している、キー・バインディング・コマンドのカレン
          トなキーマップをセットします。セットすることのできる`keymap'名
          は、`emacs'、`emacs-standard'、`emacs-meta'、`emacs-ctlx'、
          `vi'、`vi-command'、`vi-insert'です。`vi'は`vi-command'と同等
          です。また、`emacs'は`emacs-standard'と同等です。デフォルトの
          値は、`emacs'です。`editing-mode'変数の値も、デフォルトのキー
          マップに影響を及ぼします。

     `mark-directories'
          `on'がセットされると、補完されたディレクトリ名の後ろにスラッシュ
          が付加されます。デフォルトは`on'です。

     `mark-modified-lines'
          この変数に`on'がセットされると、Readlineは、変更されたヒストリ
          行の先頭にアスタリスク（`*'）を表示します。この変数は、デフォ
          ルトでは`off'です。

     `input-meta'
          `on'がセットされると、Readlineは、8ビット入力に対する端末側の
          サポートがどうであれ、8ビット入力を有効にします（読み込まれた
          文字の第8ビットを落としません）。デフォルト値は`off'です。
          `meta-flag'は、この変数の別名です。

     `output-meta'
          `on'がセットされると、Readlineは、第8ビットがセットされている
          文字を、メタ・プレフィックス・エスケープ・シーケンス
          （meta-prefixed escape sequence）としてではなく、直接表示しま
          す。デフォルトは`off'です。

     `print-completions-horizontally'
          `on'がセットされると、Readlineは、マッチする補完候補をアルファ
          ベット順にソートして、画面の下向きにではなく、水平方向に並べて
          表示します。デフォルトは`off'です。

     `show-all-if-ambiguous'
          補完関数のデフォルトの振る舞いを変更します。`on'がセットされる
          と、複数の補完候補を持つ単語は、ベル音を鳴らすことなく、直ちに
          補完候補を一覧表示させます。デフォルト値は`off'です。

     `visible-stats'
          `on'がセットされると、補完候補を一覧表示する際に、ファイル・タ
          イプを示す文字がファイル名の後ろに付加されます。デフォルトは
          `off'です。


キー・バインディング
     初期化ファイルの中でキー・バインディングを制御するための構文は単純
     です。まず、キー・バインディングを変更したいコマンドの名前を知って
     いる必要があります。以下のセクションにおいて、コマンドの名前、その
     コマンドにデフォルトのキー・バインディングがある場合はそのバインディ
     ング、および、そのコマンドが何をするものであるかについての簡単な説
     明を、一覧にして示します。

     コマンドの名前を知っていれば、初期化ファイルの中で、コマンドにバイ
     ンドしたいキーの名前、コロン、そして最後にコマンドの名前を、1行にし
     て記述するだけです。キーの名前は、好みに応じて異なる方法で表現する
     ことができます。

     KEYNAME: FUNCTION-NAME or MACRO
          KEYNAMEは、英語で記述されたキーの名前です。例えば、以下のよう
          になります。
               Control-u: universal-argument
               Meta-Rubout: backward-kill-word
               Control-o: "> output"

          上の例では、C-uが関数`universal-argument'にバインドされ、C-oが
          その右側に記述されたマクロ（行内に`> output'というテキストを挿
          入するマクロ）を実行するようバインドされます。

     "KEYSEQ": FUNCTION-NAME or MACRO
          前の例のKEYNAMEとは異なり、KEYSEQには、キー・シーケンス全体を
          示す文字列を指定することができます。これは、キー・シーケンスを
          二重引用符で囲むことによって実現されます。以下の例に示すように、
          いくつかのGNU Emacsスタイルのキー・エスケープを使うことができ
          ますが、特殊文字の名前は認識されません。

               "\C-u": universal-argument
               "\C-x\C-r": re-read-init-file
               "\e[11~": "Function Key 1"

          上の例では、C-uが（最初の例と同様）関数`universal-argument'に、
          `C-x C-r'が関数`re-read-init-file'に、`ESC [ 1 1 ~'が`Function
          Key 1'というテキストを挿入するよう、それぞれバインドされていま
          す。


     キー・シーケンスを指定する際には、以下のGNU Emacsスタイルのエスケー
     プ・シーケンスが利用できます。

     ``\C-''
          コントロール・プレフィックス
     ``\M-''
          メタ・プレフィックス
     ``\e''
          エスケープ文字
     ``\\''
          バックスラッシュ
     ``\"''
          "
     ``\'''
          '

     GNU Emacsスタイルのエスケープ・シーケンスに加えて、別のバックスラッ
     シュ・エスケープ群が利用できます。

     `\a'
          警告（ベル）
     `\b'
          バックスペース
     `\d'
          削除
     `\f'
          フォーム・フィード
     `\n'
          改行
     `\r'
          復帰（carriage return）
     `\t'
          水平タブ
     `\v'
          垂直タブ
     `\NNN'
          ASCIIコードが8進数値のNNN （1個以上3個以下の数字）に相当する文
          字
     `\xNNN'
          ASCIIコードが16進数値のNNN （1個以上3個以下の数字）に相当する
          文字

     マクロのテキストを入力する際には、マクロ定義であることを示すために、
     単一引用符または二重引用符を使わなければなりません。引用符に囲まれ
     ないテキストは、関数名であると見なされます。マクロ本体においては、
     上記のバックスラッシュ・エスケープは展開されます。バックスラッシュ
     とそれに続く文字の組み合わせがバックスラッシュ・エスケープに該当し
     ない場合、マクロのテキストの中のバックスラッシュは、`"'や`''も含め
     て、直後にある文字を引用します。例えば、以下のバインディングによっ
     て、`C-x \'は、行内に`\'を1つ挿入することになります。
          "\C-x\\": "\\"



File: gdb-ja.info  Node: Readline Init File Syntax-Footnotes, Up: Readline Init File Syntax

(1) *訳注*：ベル音を鳴らす代わりに、画面表示をフラッシュ
させることを表わしています。



File: gdb-ja.info, Node: Conditional Init Constructs

条件初期化構文
--------------

Readlineは、Cのプリプロセッサにおける条件コンパイル機能と質的に類似した
機能を実装しています。これによって、あるテストの結果に応じてキー・バイン
ディングや変数設定が実行されるようにすることができます。4種類のパーサ指
示子が使われます。

`$if'
     `$if'は、編集モード、使用されている端末、あるいは、Readlineを使用し
     ているアプリケーションに応じてバインディングが行われるようにするこ
     とを可能にします。`$if'の後ろに、テストされる内容が行末まで続きます。
     テストされる内容をほかのものと分離するために特別に文字を使う必要は
     ありません。

     `mode'
          Readlineが`emacs'モードと`vi'モードのどちらで動作しているかを
          テストするために、`$if'指示子の一形式である`mode='が使用されま
          す。例えば、Readlineが`emacs'モードで開始されている場合にのみ、
          `emacs-standard'や`emacs-ctlx'のキーマップでバインディングをセッ
          トするようにするために、これを`set keymap'コマンドと組み合わせ
          て使用することができます。

     `term'
          `term='という形式は、端末のファンクション・キーによって特定の
          キー・シーケンスが出力されるようなバインディングを行うなどの目
          的で、端末固有のキー・バインディングを組み込むために使用するこ
          とができます。`='の右側の単語は、端末の完全名と、端末の名前の
          うち最初の`-'までの部分の両方に対してテストされます。これによ
          り、例えば`sun'は、`sun'と`sun-cmd'の両方にマッチすることにな
          ります。

     `application'
          APPLICATIONは、アプリケーション固有の設定を組み込むために使用
          されます。Readlineライブラリを使用する個々のプログラムがセット
          するAPPLICATION NAME （アプリケーション名）をテストすることが
          できます。特定のプログラムにとって役に立つ関数に対してキー・シー
          ケンスをバインドするために、これを使用することができます。例え
          ば以下のコマンドは、Bashにおいて、カレントな単語、または、1つ
          前の単語を引用符で囲むキー・シーケンスを追加します。
               $if Bash
               # カレントな単語、または、1つ前の単語を引用符で囲む
               "\C-xq": "\eb\"\ef\""
               $endif

`$endif'
     このコマンドは、前の例が示すように、`$if'コマンドを終わらせます。

`$else'
     `$if'指示子から枝分かれしたこの部分に記述されたコマンドは、テスト結
     果が偽であった場合に実行されます。

`$include'
     この指示子は、引数としてファイル名を1つ取り、そのファイルからコマン
     ドとバインディングを読み込みます。
          $include /etc/inputrc



File: gdb-ja.info, Node: Sample Init File

初期化ファイルのサンプル
------------------------

以下に、inputrcファイルの実例を示します。この中では、キー・バインディン
グ、変数割り当て、条件構文の例が示されています。

     # このファイルは、Gnu Readlineライブラリを使うプログラムの行入力編集
     # の振る舞いを制御する。Gnu Readlineライブラリを使うプログラムには、
     # FTP、Bash、Gdbなどがある。
     #
     # inputrcファイルは、C-x C-rによって再読み込みすることができる。
     # '#'で始まる行は、コメントである。
     #
     # 最初に、/etc/Inputrcからシステム全体のバインディングと変数割り当て
     # を取り込む。
     $include /etc/Inputrc

     #
     # emacsモードにおける種々のバインディングをセットする。

     set editing-mode emacs 

     $if mode=emacs

     Meta-Control-h:	backward-kill-word	関数名の後ろのテキストは無視される。

     #
     # キーパッド・モードにおける矢印キー
     #
     #"\M-OD":        backward-char
     #"\M-OC":        forward-char
     #"\M-OA":        previous-history
     #"\M-OB":        next-history
     #
     # ANSIモードにおける矢印キー
     #
     "\M-[D":        backward-char
     "\M-[C":        forward-char
     "\M-[A":        previous-history
     "\M-[B":        next-history
     #
     # 8ビット・キーパッド・モードにおける矢印キー
     #
     #"\M-\C-OD":       backward-char
     #"\M-\C-OC":       forward-char
     #"\M-\C-OA":       previous-history
     #"\M-\C-OB":       next-history
     #
     # 8ビットANSIモードにおける矢印キー
     #
     #"\M-\C-[D":       backward-char
     #"\M-\C-[C":       forward-char
     #"\M-\C-[A":       previous-history
     #"\M-\C-[B":       next-history

     C-q: quoted-insert

     $endif

     # 旧スタイルのバインディング。これがたまたまデフォルトでもある。
     TAB: complete

     # シェルとのやりとりにおいて便利なマクロ
     $if Bash
     # パス（PATH）の編集
     "\C-xp": "PATH=${PATH}\e\C-e\C-a\ef\C-f"
     # 引用符で囲まれた単語を入力するための準備 -- 先頭と末尾の二重引用符
     # を挿入して、先頭の引用符の直後に移動
     "\C-x\"": "\"\"\C-b"
     # バックスラッシュを挿入
     # （シーケンスやマクロにおいて、バックスラッシュ・エスケープをテストする）
     "\C-x\\": "\\"
     # カレントな単語、または、1つ前の単語を引用符で囲む
     "\C-xq": "\eb\"\ef\""
     # バインドされていない行再表示コマンドにバインディングを追加
     "\C-xr": redraw-current-line
     # カレント行において変数を編集
     "\M-\C-v": "\C-a\C-k$\C-y\M-\C-e\C-a\C-y="
     $endif

     # 視覚的なベルが利用可能であれば、それを使う
     set bell-style visible

     # 読み込みの際に、文字の第8ビットを落とさない
     set input-meta on

     # iso-latin1文字は、プレフィックス・メタ・シーケンスに変換せず、
     # そのまま挿入する
     set convert-meta off

     # 第8ビットがセットされている文字を、メタ・プレフィックス文字として
     # ではなく、直接表示する
     set output-meta on

     # ある単語について、150を超える補完候補が存在する場合、ユーザに対して
     # すべてを表示させたいかどうかを問い合わせる
     set completion-query-items 150

     # FTP用
     $if Ftp
     "\C-xg": "get \M-?"
     "\C-xt": "put \M-?"
     "\M-.": yank-last-arg
     $endif



File: gdb-ja.info, Node: Bindable Readline Commands

バインド可能なReadlineコマンド
==============================

* Menu:

* Commands For Moving::		行の中での移動
* Commands For History::	以前の行の入手
* Commands For Text::		テキストを変更するためのコマンド
* Commands For Killing::	キル（kill）と再挿入（yank）のためのコマンド
* Numeric Arguments::		数字引数、繰り返し回数の指定
* Commands For Completion::	Readlineによる入力補完
* Keyboard Macros::		入力された文字群の保存と再実行
* Miscellaneous Commands::	その他のコマンド

このセクションでは、キー・シーケンスにバインドすることが可能なReadlineコ
マンドについて説明します。



File: gdb-ja.info, Node: Commands For Moving

移動のためのコマンド
--------------------
`beginning-of-line (C-a)'
     カレント行の先頭に移動します。

`end-of-line (C-e)'
     行の末尾に移動します。

`forward-char (C-f)'
     1文字分先に進みます。

`backward-char (C-b)'
     1文字分後へ戻ります。

`forward-word (M-f)'
     次の単語の末尾へ移動します。単語は、文字と数字により構成されます。

`backward-word (M-b)'
     現在カーソルが指している単語、または、1つ前の単語の先頭に移動します。
     単語は、文字と数字により構成されます。

`clear-screen (C-l)'
     画面を消去し、カレント行を再表示します。その際、カレント行が画面の
     一番上になるようにします。

`redraw-current-line ()'
     カレント行を再表示します。デフォルトでは、このコマンドはバインドさ
     れていません。




File: gdb-ja.info, Node: Commands For History

ヒストリを操作するためのコマンド
--------------------------------

`accept-line (Newline, Return)'
     カーソルの位置がどこにあっても、その行を受け取ります。この行が空行
     ではない場合、`HISTCONTROL'変数と`HISTIGNORE'変数の設定にしたがって、
     それをヒストリ・リストに追加します。この行がヒストリ行である場合は、
     そのヒストリ行を最初の状態に復元します。カーソルの位置がどこにあっ
     ても、その行を受け取ります。この行が空行ではない場合、それをヒスト
     リ・リストに追加します。この行がヒストリ行である場合は、そのヒスト
     リ行を最初の状態に復元します。

`previous-history (C-p)'
     ヒストリ・リストを1つ上に移動します。

`next-history (C-n)'
     ヒストリ・リストを1つ下に移動します。

`beginning-of-history (M-<)'
     ヒストリの最初の行に移動します。

`end-of-history (M->)'
     入力ヒストリの最後の行、すなわち、現在入力中の行に移動します。

`reverse-search-history (C-r)'
     カレント行から始めて上の方向へ検索を行います。必要に応じてヒストリ
     の上の方へ移動します。インクリメンタルな検索を行います。

`forward-search-history (C-s)'
     カレント行から始めて下の方向へ検索を行います。必要に応じてヒストリ
     の下の方へ移動します。インクリメンタルな検索を行います。

`non-incremental-reverse-search-history (M-p)'
     カレント行から始めて、必要に応じてヒストリの上の方へ移動しつつ、非
     インクリメンタルな検索を使って、ユーザによって提供された文字列を上
     の方向へ検索します。

`non-incremental-forward-search-history (M-n)'
     カレント行から始めて、必要に応じてヒストリの下の方へ移動しつつ、非
     インクリメンタルな検索を使って、ユーザによって提供された文字列を下
     の方向へ検索します。

`history-search-forward ()'
     カレント行の先頭からカレントなカーソル位置（ポイント）までの間の文
     字列を、ヒストリの中で下の方向へ検索します。これは、非インクリメン
     タルな検索です。デフォルトでは、このコマンドはバインドされていませ
     ん。

`history-search-backward ()'
     カレント行の先頭からポイントまでの間の文字列を、ヒストリの中で上の
     方向へ検索します。これは、非インクリメンタルな検索です。デフォルト
     では、このコマンドはバインドされていません。

`yank-nth-arg (M-C-y)'
     1つ前に実行されたコマンドの最初の引数（通常は、1つ前の行の2つめの単
     語）を挿入します。引数Nを指定すると、1つ前に実行されたコマンドのN番
     目の単語を挿入します（1つ前に実行されたコマンドの中の最初の単語を、
     0番目の単語とします）。負の値を引数に指定すると、1つ前に実行された
     コマンドの後ろから数えてN番目の単語を挿入します

`yank-last-arg (M-., M-_)'
     1つ前に実行されたコマンドの最後の引数（1つ前のヒストリ・エントリの
     最後の単語）を挿入します。引数を指定すると、`yank-nth-arg'と同じよ
     うに動作します。`yank-last-arg'を連続して実行すると、ヒストリ・リス
     トを遡って移動していきます。したがって、各行の最後の引数が順番に挿
     入されていきます。



