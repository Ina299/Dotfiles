Info file: flex-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `flex-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.
















This file documents Version 2.3.7 - 2.5.4 of the Flex lexical scanner
generator.

This is Edition  1.03,  February 1993, 
of the `Flex Version  2.3.7 - 2.5.4 Manual'.

Copyright (C) 1992, 1993 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.








File: flex-ja.info, Node: Top, Next: Introduction, Prev: (dir), Up: (dir)

Flex
****

Flexは、入力として高級記述言語を受け取り、出力としてC言語で記述されたス
キャナを生成する、字句スキャナ生成プログラムです。Flex自身が、標準のUnix
ユーティリティと比較してより高速に動作しますし、生成されるスキャナもより
高速です。また、POSIX、Lexとの互換性も十分備えています。

これは、1993年2月発行、エディション1.03のFlex 2.3.7マニュアルです。Flex
2.5の新機能に関する情報も追加してあります。Flex 2.5の新機能に関する節の
名前には、「（Flex 2.5の補足情報）」と書かれています。

============================================================================
* Menu:

* Introduction:: Flexの必要性とその機能* Invoking Flex:: Flexの起動方法、
コマンドライン・オプション* Flex Descriptions:: Flex記述言語*
Interfacing to Flex:: FlexスキャナとC言語の結合* Other Flex Features:: 
追加的なFlex機能、一般的ではないFlex機能* Optimization:: Flexスキャナの
最適化方法* More Examples:: Flexを使うための実例* Flex and Lex:: Flexと
Lexの相違点、性能、POSIX標準への準拠度* Useful Code:: ユーザ・スキャナの
中で使うことのできるコード* Summary:: オプション、変数などの要約*
Index:: インデックス

 -- The Detailed Node Listing ---

Flex入門

* Problem Solving::             問題解決手段としてのFlex
* General Programming::         一般的なプログラミング・ツールとしてのFlex

Flexの起動

* Command Line Switches::       Flexのコマンドライン・オプション
* Command Line Switches (Flex 2.5)::  同上（Flex 2.5の補足情報）

Flex記述言語

* Comments::                    Flexのコメント・スタイルの説明
* Optional C Code::             Flex定義の先頭のCコード・セクションの説明
* Definitions::                 Flexにおける定義の書き方
* %%::                          区切り文字%%の意味
* Rules::                       Flexファイルのルール・セクション
* Pattern Matching::            パターン・マッチングに使われる部分
* Regular Expressions::         パターンのマッチング
* Start States::                ある条件にもとづいてパターン・マッチング・
                                ルールを活性化させる方法
* %option (Flex 2.5)::          %option指示子の説明

パターン・セクション

* Characters::                  Flexにおける文字、特殊文字
* Strings::                     Flexにおける文字列、特殊文字列
* Character Classes::           文字クラスの説明、その使い方
* Character Class Expressions (Flex 2.5)::  同上（Flex 2.5の補足情報）

スタート状態

* Start States Explained::      スタート状態の宣言、スキャナに対する効果
* Activating States::           スタート状態の活性化方法
* Start State Notes::           不当な宣言、排他的スタート状態のパワーに
                                関する注
* Start State Notes (Flex 2.5)::  同上 （Flex 2.5の補足情報）
* Start State Example::         スタート状態の使用例

Flexとのインターフェイス

* Flex and C::                  CとFlexのインターフェイス
* Flex and C (Flex 2.5)::       同上（Flex 2.5の補足情報）
* An Example of Flex and C::    フィルタにおける文字列代替
* Flex and Bison::              FlexとBisonの協同
* Another Example of Flex and Bison::  FlexとBisonのもう１つの実例
* Flex and C++ (Flex 2.5)::     C++とFlexのインターフェイス
                                （Flex 2.5の補足情報）

FlexとBison

* Interfacing Flex and Bison::  一般的な方法
* YYSTYPE and yylval::          単なる整数以上の情報の渡し方

FlexとBisonのもう１つの実例

* The Database Language::       データベース言語の定義
* The Implementation::          言語を解析するファイル
* Notes on the Implementation:: この実装を選択した理由に関する（簡単な）注

Flexの他の特徴

* Case Insensitive Scanners::   大文字・小文字を区別するスキャナ
* Interactive Scanners::        ユーザから入力を受け取るスキャナ
* Table Compression and Scanner Speed::  テーブル圧縮とスキャナのスピード
* Translation Tables::          文字をグループ化する別の方法
* Multiple Input Buffers::      複数の入力ストリームを受け付ける方法
* End-Of-File Rules::           EOFを処理するための特殊なルール

大文字・小文字を区別しないスキャナ

* The -i Switch::               入力において大文字・小文字を無視する方法

複数の入力バッファ

* Buffer Manipulation::         バッファ操作関数
* Buffer Manipulation (Flex 2.5)::  同上（Flex 2.5の補足情報）
* Example of Multiple Buffers::  複数バッファを使う実例

スキャナの最適化

* Optimizing for Speed::        ファスト・スキャナを作るためのフラグ、
                                関連するトピック
* Optimizing for Size::         サイズの小さいスキャナの作り方

スピードの最適化

* Removing Backtracking::       バックトラッキングの除去による性能の
                                飛躍的向上

Flexを使うその他の実例

* Example-Counting Words::      wc風のユーティリティ
* Example-Pascal Lexical Scanner::  本物の言語をスキャンする実例
* Example-Jargon Converter::    専門用語ファイルのTexinfo形式への変換

FlexとLex

* Flex::                        Flex
* Lex::                         Lex

Flex 

* Flex and POSIX::              FlexとPOSIX
* Flex and POSIX (Flex 2.5)::   FlexとPOSIX（Flex 2.5の補足情報）

役に立つコードの抜粋

* Handling Comments::           コメントの処理
* Handling Strings::            文字列の処理
* Handling Numbers::            数値の処理
* Multiple Scanners::           複数のスキャナ
* Miscellaneous::               その他

要約

* Switches Summary::            Flexコマンドライン・オプションの要約
* Switches Summary (Flex 2.5)::  同上（Flex 2.5の補足情報）
* Summary or Flex Variables and Functions::  Flex変数、Flex関数の要約
* Summary or Flex Variables and Functions (Flex 2.5)::
                                             同上（Flex 2.5の補足情報）
* Summary of Flex Characters::  演算子、特殊文字、エスケープ・シーケンス
                                以外の文字をその文字自身として受け付ける
* Summary of Flex Rules::       Flexルールの２つの構成要素

========================================================================







File: flex-ja.info, Node: Introduction, Next: Invoking Flex, Prev: Top, Up: Top

Flex入門
********

     この章では字句スキャン処理の概念を紹介し、Flexのようなツールの必要
     性を指摘します。この章の後半部分でFlexを紹介し、Flexを使うことので
     きる状況の実例をいくつか紹介します。

UnixおよびCの世界では、ファイルは通常個々のバイトが連続したものとして扱
われます。個々のバイトを集めてどのようにグループ化するかという点は、プロ
グラマが決めることです。このような抽象化は非常に強力です。というのは、ど
のようなファイルであってもこの抽象化方法によって表現することができるから
です。しかしこの方法には短所もあり、プログラマはほとんど常に生のファイル
に対して構造をあてはめなければなりません。言葉を変えると、ファイルをより
意味のある部分に分割しなければならないということです。例えば、コンパイラ
のある部分はファイルから連続した文字を受け取り、構文チェッカが理解するこ
とのできる構成要素、例えば、数値、キーワード、文字列などにグループ化しま
す。このようなことを行う理由は、コンパイラの言語パーサが処理を行うのは、
連続した文字に対してではなく、その言語のシンボルが連続したものに対してだ
からです。

データベース・アプリケーションや、バイナリ・ファイルを扱うアプリケーショ
ンは、扱うデータに対してある固定されたフォーマットというものを持っている
ことが多く、そのフォーマットを使って入力データから意味を導き出します。テ
キストを入力するプログラムは通常これとは反対で、入力を単語やシンボルに分
割しなければならないことが多いのですが、通常これらの単語やシンボルがどの
ように配置されているかを示す決まった構造というものは存在しません。したがっ
て、テキスト処理を行うプログラムは、入力された情報を意味のあるシンボルに
分割するために、"字句解析"もしくは"字句スキャン"と呼ばれる処理を行う部分
を持っていることが多く、そこで入力情報の分割が行われます。このようなこと
を行う関数群のことを字句アナライザもしくは字句スキャナ、あるいは短く「ス
キャナ」と呼びます。

一般的に、スキャナを作成するのは、プログラマにとって難しいことでも面白い
ことでもないのですが、時間のかかる作業になることはあります。普及している
プログラミング言語のほとんどは、スキャナの作成を支援する機能が不十分です。
というのは、連続した文字を単語、トークン、シンボルに分割する組み込みの機
能を持っていないからです。通常はこのような仕事を行うライブラリ・ルーチン
が存在しますが、柔軟でなかったり、使いにくいものであったり、あるいは、ルー
チンとのやりとりにあまりに多くのコードが必要になったりすることが多いため
に、実装上の細かな点によって根本的な問題が不明瞭にされてしまいます。

１つの良い例が、C言語で許されているすべての数値型（浮動小数、10進整数、
16進整数、8進整数）を処理するスキャナをC言語で記述する場合です。これは非
常に難しいということはありませんが、出来上がったコードは通常美しいとはと
ても言えないものでしょうし、その保守や拡張は容易でないことが多いのです。

ほとんどのプログラマが即座に断言するように、他人の書いたコードを保守する
のは通常あまり楽しい作業ではありません。さらに、美しくないコードを保守す
るのは、楽しいというにはほど遠いものです。このように、スキャナを書くこと
が退屈で、その保守が難しいとなると、スキャナの作成をより容易にしてくれる
方法を考えようとするに足る理由のあったことが読者にもお分かりいただけるで
しょう。

Flexは、このような問題への答なのです。

========================================================================
* Menu:

* Problem Solving:: 問題解決手段としてのFlex * General Programming:: 一
般的なプログラミング・ツールとしてのFlex
========================================================================



File: flex-ja.info, Node: Problem Solving, Next: General Programming, Prev: Introduction, Up: Introduction

問題解決手段としてのFlex
========================

Flexはプログラマに対して、字句解析処理部分をきれいに記述し、その記述にし
たがった効率的な字句スキャナを生成する方法を提供します。プログラマはFlex
に対して、必要なスキャナに関する記述情報を提供します。Flexはその記述情報
を使って、C言語で書かれたスキャナを生成します。記述に使われる言語は上級
言語であり、スキャナの記述に関してはC言語よりもはるかに適しています。そ
の上級言語を使うことで、プログラマは、文字をどのようにグループ化し、グルー
プ化が完了した時にどのようなアクションを発生させるかを指定することができ
ます。

*注：*このマニュアルのほとんどの部分はFlex、Lexの両方を対象にしています。
Lexは（Flexには劣りますが）ほとんどのUnixシステム上にある標準のスキャナ
生成ユーティリティです。両者の間に違いがある場合には、Flexを優先させてい
ます。Lexについては*Note 標準Lex: Lexで簡単に説明してあります。

ここでも１つの良い例がコンパイラです。前に議論したように、コンパイラの構
文チェッカは、文字が連続したものではなく、言語文法の構成要素を表すトーク
ンが連続したものを、入力として受け取る必要があります。Flexはこのような場
合に最適です。Flexによって生成されたスキャナが構文チェッカとファイルの仲
介役となり、構文チェッカが次の意味のあるトークンを要求するのを待ちます。
Flexはファイルを読み、プログラマが与える記述にしたがって文字をグループ化
して、マッチしたトークンを返却します。この処理は、スキャナもしくはパーサ
が終了するまで続きます。

Cのコンパイラを作成する場合、このようなことを行うために必要となるFlexの
記述情報は、コードの行数にして100行から300行くらいになるかもしれません。
この記述情報のほとんどは、シンボル・テーブルの管理、識別子の検索、型のマッ
ピング、ある数の値等の追加情報の返却を行うための補助的なCコードになるで
しょう。こうしたコード自体は記述情報の一部ではありませんが、通常、コンパ
イラによって必要とされるものです。

概念的にはFlexは、原材料（文字）を取り込み、消費者（パーサ等）がすぐに使
うことができる完成品（トークン）を製造する工場のようなものです。



File: flex-ja.info, Node: General Programming, Prev: Problem Solving, Up: Introduction

一般的なプログラミング・ツールとしてのFlex
==========================================

Flexはコンパイラにしか使えないということはありません。読者のコンピュータ
上にある、ファイルを読み込んだり、なんらかの形で文字のグループを処理する
必要のあるすべてのプログラム、特に、変換フィルタや言語ツールのことを考え
てみてください。こうしたプログラムのほとんどすべてを、Flex単体、もしくは
Flexと他のツールの組み合わせによって作成することができます。

１つの良い例が文字数のカウントです。例えば、ファイルの中の全行数、個々の
文字の出現回数、`foo'という単語の出現回数を調べるプログラムを作成したい
としましょう。標準的なツール（`grep'、`sed'、`awk'、`perl'等）で作成する
ことも、C言語のプログラムを書いて作成することもできますが、Flexで作成す
ることも可能です。他の例として、特定のキーワードを探す必要のある、メール・
リーダがあります。この場合でも、標準ツールで実現することも、FlexとC言語
で実現することもできます。

Flexを使うことで、プログラマは、スキャナの開発やファイルを構成する文字の
処理にかかる時間を大幅に減らすことができます。ほとんどの場合、Flexに対す
る入力情報は、既存のプログラミング言語で記述されたコードと比較して、より
理解しやすく、少なくとも同程度の移植性があり、保守もより簡単です。それだ
けでなく、Flexでスキャナを開発するのにかかる時間は、既存のプログラミング
言語で同等のスキャナを開発する場合と比べきわめて短くてすむので、Flexは、
プロトタイピングや、一度しか使わないプログラムやフィルタの開発に最適です。



File: flex-ja.info, Node: Invoking Flex, Next: Flex Descriptions, Prev: Introduction, Up: Top

Flexの起動
**********

     この章ではFlexを起動する基本的な方法を説明し、Flexで使用可能なコマ
     ンドライン・オプションを簡単に説明します。

Flexは記述情報を含むファイルを入力として受け取り、スキャナ機能を持つCの
ファイルに変換します。Flexを起動するためのコマンド行は以下のようになりま
す。

     flex [-bcdfinpstvFILT8] [-C[efmF]] [-SSKELETON] [FILE ...]

一般的には、単に`flex'に続けて処理すべきファイル名を入力することで実行さ
れます。

     flex myfile.l

記述情報ファイル名の末尾の`.l'は、`myfile'がFlexもしくはLexの記述ファイ
ルであることを示唆する慣例的な方法です。名前付けの慣例としてもう一つよく
見られるのが、末尾に`.lex'を使うことです。例えば、以下のようになります。

     flex myfile.lex

Flexは記述情報ファイル（`myfile.l'）を読み込み、そこに記述されたパターン
を認識するスキャナ機能を持つ`lex.yy.c'という名前のC言語ファイルを生成し
ます。記述情報の中になんらかのエラーがあれば、Flexは対応するエラー・メッ
セージを`stderr'に出力します。

========================================================================
* Menu:

* Command Line Switches:: Flexのコマンドライン・オプション
* Command Line Switches (Flex 2.5)::  同上（Flex 2.5の補足情報）
========================================================================



File: flex-ja.info, Node: Command Line Switches, Prev: Invoking Flex, Up: Invoking Flex

コマンドライン・オプション
==========================

Flexのコマンドライン・オプションは以下のような意味を持ちます。

`-b'
     `-b'オプションを指定すると`lex.backtrack'というファイルが生成されま
     す。このファイルはスキャナの記述情報を最適化する際に使用されます。
     詳細については、*Note Optimizing for Speed::。

`-c'
     このオプションはPOSIXとの互換性のために提供されているだけで、実際に
     は何もしません。POSIXでは、`-c'オプションはC言語によるアクションが
     使用されることを意味します。

`-d'
     このオプションを指定するとデバッグが可能になります。これにより生成
     されるスキャナは、実行中にスキャナの状態情報を`stderr'に出力します。

`-f'
     Flexに対して*ファスト*・スキャナ（*fast* scanner）と*フル*・スキャ
     ナ（*full* scanner）のどちらを生成するかを指示します。詳細について
     は、*Note Table Compression and Scanner Speed::。`-f'（小文字）オプ
     ションと`-F'（大文字）オプションとは異なる効果を持つ点に注意してく
     ださい。

`-i'
     Flexに対して大文字、小文字を区別しないスキャナを生成するよう指示し
     ます。詳細については、*Note Case Insensitive Scanners::。

`-n'
     このオプションはFlexにとっては何の意味も持たず、POSIXとの互換性のた
     めにのみ提供されています。POSIXでは、このフラグは`-v'オプションによ
     る出力を抑制するために使用されます。POSIXでのデフォルトは、テーブル・
     サイズが指定されない限りこのような出力を抑制するというものです。
     Flexではテーブル・サイズは意味を持たないので、このフラグは冗長です。

`-p'
     `-p'オプションが指定されると、Flexは性能レポートを`stderr'に出力し
     ます。スキャナの性能を向上させる方法に関する議論については、*Note
     Optimizing for Speed::。

`-s'
     Flexスキャナがマッチするものを見つけることができなかった場合のデフォ
     ルトのアクションは、そのマッチされなかった入力情報を`stdout'に出力
     することです。`-s'オプションはこのようなアクションを抑制し、その代
     わりに入力情報がマッチしなかった時点でスキャナを異常終了させます。

`-t'
     このオプションが指定された場合、Flexは生成されたスキャナをファイル
     `lex.yy.c'にではなく`stdout'に出力します。

`-v'
     Flexに対して*冗長*モードで動作するよう指示します。

`-F'
     Flexに対して*ファスト*・スキャナ（*fast* scanner）を生成するよう指
     示します。詳細については、*Note スキャナの最適化: Optimization。
     `-F'（大文字）は`-f'（小文字）とは異なる効果を持つ点に注意してくだ
     さい。`-f'と`-F'の相違点に関する情報については、*Note Table
     Compression and Scanner Speed::。

`-I'
     このオプションはFlexに対して*対話型*スキャナを生成するよう指示しま
     す。詳細については、*Note Interactive Scanners::。

`-L'
     デフォルトでは、デバッグを支援するために、Flexは生成されたスキャナ
     のコード中に`#line'指示子を書き込みます。このオプションによって
     `#line'指示子の書き込みは行われなくなります。

`-T'
     Flexに対して"トレース"・モードで動作するよう指示します。Flexは多く
     のメッセージを`stderr'に出力するようになります。こうしたメッセージ
     は、Flexを非常によく理解しているユーザ以外には無意味でしょう。

`-8'
     このオプションは、Flexに対して8ビット入力を受け付けるスキャナを生成
     するよう指示します。

`-C[efmF]'
     これらのオプションは、スキャン処理用のテーブルをどのように圧縮する
     かを制御します。詳細については、*Note スキャナの最適化:
     Optimization。

`-SSKELETON_FILE'
     Flexに対して、生成するスキャナのベースとしてSKELETON_FILEにより指定
     されるスケルトン・ファイルを使用するよう指示します。主に、Flex自体
     をデバッグするために使用されます。




File: flex-ja.info, Node: Command Line Switches (Flex 2.5), Prev: Command Line Switches, Up: Invoking Flex

コマンドライン・オプション（Flex 2.5の補足情報）
================================================

Flex 2.5では、前節（*Note Command Line Switches::）で説明されていない、
以下のオプションもサポートされています。

`-h'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指示
     します。

`-l'
     AT&Tにより実装されたlexとの互換性を最大限に提供します。このオプショ
     ンは、性能面でかなりの悪影響を及ぼします。また、このオプションを、
     `-f'、`-F'、`-Cf'、`-CF'、`-+'オプションと同時に指定することはでき
     ません。FlexとLexの（非）互換性の問題については、*Note Flex and
     Lex::を参照してください。

`-w'
     このオプションが指定されると、Flexは、警告メッセージを出力しません。

`-B'
     Flexに対してバッチ・スキャナを生成するよう指示します。これは、対話
     型スキャナを生成するよう指示する`-I'オプションの否定です。

`-V'
     Flexに対してバージョン番号を出力するよう指示します。

`-7'
     Flexに対して7ビット・スキャナを生成するよう指示します。これは、`-8'
     オプションの否定です。内部的に生成されるテーブルのサイズは、`-8'オ
     プションが指定された場合と比較して半分になりますが、生成されるスキャ
     ナは、8ビット文字を含む入力を処理することができなくなります。`-Cf'、
     `-CF'が指定されていない場合は、明示的に`-7'を指定しない限り、8ビッ
     ト・スキャナが生成されます。

`-+'
     Flexに対してC++スキャナ・クラスを生成するよう指示します。C++スキャ
     ナについては、*Note Flex and C++ (Flex 2.5)::を参照してください。

`-?'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指示
     します。（`-h'オプションと同じです）。

`-Ca'
     このオプションは、スキャン処理用のテーブルを`long int'の配列として
     定義するようFlexに通知します（デフォルトでは`short int'型の配列とな
     ります）。RISCマシンによっては、`long int'の方が高速に処理されるた
     め、スキャナの性能向上が期待できますが、その反面、テーブルのサイズ
     は大きくなります。

`-Cr'
     このオプションを指定して生成されたスキャナは、入力に`read()'システ
     ム・コールを使います。デフォルトでは、対話型スキャナの場合は
     `getc()'が、バッチ（非対話型）・スキャナの場合は`fread()'が使われま
     す。

`-oFILE'
     このオプションが指定されると、Flexは生成されたスキャナをFILEにより
     指定されるファイルに出力します。デフォルトでは、スキャナはファイル
     `lex.yy.c'に出力されます。

`-PPREFIX'
     Flexにより生成されるスキャナのソース・ファイルの中では、大域変数や
     大域関数の名前の先頭に接頭辞`yy'が付けられます。このオプションが指
     定されると、`yy'の代わりに、PREFIXにより指定される文字列が接頭辞と
     して使用されます。また、`-o'オプションが指定されない場合のスキャナ・
     ファイル名`lex.yy.c'も、`lex.PREFIX.c'となります。

     以下に、このオプションにより影響を受ける名前の一覧を示します。

          yy_create_buffer
          yy_delete_buffer
          yy_scan_buffer
          yy_scan_string
          yy_scan_bytes
          yy_flex_debug
          yy_init_buffer
          yy_flush_buffer
          yy_load_buffer_state
          yy_switch_to_buffer
          yyin
          yyleng
          yylex
          yylineno
          yyout
          yyrestart
          yytext
          yywrap

     `-+'オプションが指定されている場合は、影響を受けるのは`yywrap'と
     `yyFlexLexer'の２つだけです。

     このオプションにより、`yywrap()'の名前が変更されてしまう点に注意し
     てください。プログラムをリンクするためには、`PREFIXwrap'という名前
     の関数を作成する必要があります。この関数を作成したくない場合には、
     スキャナ定義ファイルの中で、`%option noyywrap'を指定して、リンク時
     に`-lfl'オプションを指定します。`%option'指示子については、*Note
     %option (Flex 2.5)::を参照してください。

`--help'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指示
     します。（`-h'オプションと同じです）。

`--version'
     Flexに対してバージョン番号を出力するよう指示します。（`-V'オプショ
     ンと同じです）。



File: flex-ja.info, Node: Flex Descriptions, Next: Interfacing to Flex, Prev: Invoking Flex, Up: Top

Flex記述言語
************

     この章では、スキャナ定義の構成要素を説明し、その使用例を示します。
     Flexを効率的に使用するためには、定義の個々の要素を完全に理解するこ
     とが非常に重要です。したがって、初めてFlexを使うユーザには、時間を
     かけてこの章を読むことをお勧めします。

Flexスキャナ定義のほとんどの要素は、必須要素ではありません。全体的な定義
フォーマットは以下のようになります。

     定義、初期Cコード
     %%
     ルール 
     %%
     他のCコード

各々について、以下において詳細に説明します。

========================================================================
* Menu:

* Comments:: Flexのコメント・スタイルの説明* Optional C Code:: Flex定義
の先頭のCコード・セクションの説明* Definitions:: Flexにおける定義の書き
方* %%:: 区切り文字%%の意味* Rules:: Flexファイルのルール・セクション*
Pattern Matching:: パターン・マッチングに使われる部分* Regular
Expressions:: パターンのマッチング* Start States:: ある条件にもとづいて
パターン・マッチング・ルールを活性化させる方法
* %option (Flex 2.5)::          %option指示子の説明
========================================================================



File: flex-ja.info, Node: Comments, Next: Optional C Code, Prev: Flex Descriptions, Up: Flex Descriptions

コメント
========

Cのコードが記述できるところには、どこにでもコメントを記述することができ
ます。コメントの書式は、Cのコメントの規則に従います。コメントは、記述情
報に影響を与えることはありません。Cスタイルのコメントは以下のようになり
ます。

     /*
     ...
     */

これに加えて、Flexでは`#'で始まるコメントも許されます。このようなコメン
トは`lex.yy.c'にはコピーされませんので、この形式のコメントを使うことは*
お勧めできません*。

*注：*C以外の言語（例えばPascal）のコードを生成するLexも存在します。この
ようなLexではコメントの書式はおそらく異なるでしょう。Flexの場合はCのコー
ドしか生成しません。



File: flex-ja.info, Node: Optional C Code, Next: Definitions, Prev: Comments, Up: Flex Descriptions

オプションのCコード
===================

プログラマは、２つの異なる方法を用いて、スキャナの中に直接Cのコードを含
めることができます。第１の方法は、"「定義、初期Cコード」"セクション（最
初の`%%'より前の部分）にコードを含めることです。第２の方法は、"「他のCコー
ド」"セクション（２番目の`%%'より後ろの部分）にコードを含めることです。
どちらの場合も、コードはそのまま`lex.yy.c'にコピーされますので、正当なコー
ドでなければなりません。

第１のセクション中のCコードは以下の形式になります。


     %{ 
        C CODE
        ...
     %}

ここで`%{...%}'というペアが、Cコード・ブロックの先頭と末尾を示すために使
われています。この形式のコードと定義は、"「定義、初期Cコード」"セクショ
ンのどこにでも自由に記述することができます。定義については次の節で説明し
ます。

Cのコードが最初のカラムから始まるのでなければ、`%{...%}'というペアは必要
ありません。しかし普通は、分かりやすくするために記述しておいた方が良いで
しょう。もう１つのポイントは、`#ifdef'等のように最左端のカラムから始まら
なければならず、かつ、通常はスキャナ記述情報の先頭に置かれる必要のあるも
のが存在するという点です。こうした場合、`%{...%}'に囲まれていないと、
Flexはそれを定義の一部であると見なすでしょう。これが、常に`%{...%}'を使
うもう１つの理由です。

最後の（"「他のCコード」"）セクション内のコードは、そのままコピーされま
す。ここには特別な宣言は必要ありません。



File: flex-ja.info, Node: Definitions, Next: %%, Prev: Optional C Code, Up: Flex Descriptions

定義
====

定義セクションにおいて、プログラマは、ある文字のグループに一意な識別子を
与え、その識別子がその文字グループに置き換えられるようにすることができま
す。定義は以下のような形式になります。

     DEFINITION_NAME    DEFINITION

DEFINITION_NAMEは*最初*のカラムから始まらなければならず、そうしないとそ
の定義は`lex.yy.c'にそのままコピーされてしまうということに注意してくださ
い。以下に一般的な定義をいくつか挙げます。

     DIGIT     [0-9]
     LETTER    [a-z]
     IDENT     [a-z_][a-z0-9_]*
     ALPHANUM  {LETTER}|{DIGIT}

DEFINITION NAMEは、そのグループの一意な識別子でなければなりません。また、
DEFINITIONはルール・セクション（後述）において正当なものであれば何でも構
いません。ルール・セクションや（上の例の`ALPHANUM'の定義において示される
ように）別の定義中において使われる場合には、定義は`{ }'によって囲まれて
いなければなりません。

FlexとLexの非常に重要な相違点に、定義を展開する時、Flexは字義どおりに丸
括弧( )で囲むのに対して、Lexは囲まないという点があります。 (1) (*Note
Definitions-Footnotes::) これは、`^'、`<<EOF>>'、`$'、`/'を定義中に入れ
ることができないことを意味しています。というのは、前述の文字は丸括弧( )
で囲まれた部分に入れることができないからです。詳細は、*Note Characters::
および*Note Flex and Lex::において説明します。

例えば、

     FUNCTION ^[a-zA-Z_][a-zA-Z0-9_]*"("
     %%
     {FUNCTION}  printf("got a function\n");

は、以下のようなプログラミング・スタイルを使っている場合の、Cの関数宣言
にマッチするように見えます。

     int
     foo()
     {
        ...
     }

しかし実際にはうまくいきません。というのは、`{FUNCTION}'が展開されると、

     (^[a-zA-Z_][a-zA-Z0-9_]*)

のようになりますが、これは不正だからです。このような種類の問題に関する説
明については、*Note Flex and POSIX::を参照してください。



File: flex-ja.info  Node: Definitions-Footnotes, Up: Definitions

(1) 訳注：Flex 2.5では、`-l'オプションを指定して生成されたスキャナ
は、Lexの場合と同じように、定義を展開する時に丸括弧( )で囲みません。


File: flex-ja.info, Node: %%, Next: Rules, Prev: Definitions, Up: Flex Descriptions

%%
==

２つのパーセント記号が、スキャナ記述情報のルール・セクションの先頭と末尾
を示します。すべてのFlex記述情報は、少なくともルール・セクションの先頭を
示す`%%'を含んでいなければなりません。



File: flex-ja.info, Node: Rules, Next: Pattern Matching, Prev: %%, Up: Flex Descriptions

ルール
======

ルールはFlexの心臓部です。ルールを書くことによって、プログラマは、スキャ
ナが何を実行するべきであるかをFlexに通知します。

通常、ルールは２つの部分から構成されます。

     PATTERN       ACTIONS

このうちPATTERNが何を認識するべきかを定義し、ACTIONSがその何かを認識した
時に何を実行するべきであるかをスキャナに知らせます。PATTERNの部分は空白
によって区切られます。これは、空白をマッチさせたい場合には、それを引用符
で囲む必要があるということを意味しています。

スキャナは、マッチするものを２つ以上見つけた場合、以下の２つのルールを使っ
てどれを受け入れるかを決めます。

  1. 後続コンテキスト（trailing context）も含めて最も長いものを受け入れ
     る。
  2. マッチするものがすべて同じ長さの場合、スキャナ定義中に最初に記述さ
     れたものを受け入れる。

ACTIONSは、空（コードなし）にするか、もしくは、１つ以上のCの文を含む単一
のコード行、`{...}'または`%{...%}'で囲まれた１行以上のコード、単一の垂直
棒（`|'）のいずれかを記述することができます。以下にいくつか例を挙げます。

     hi         |
     bonjour    |
     hello      printf("hello!\n");
     goodbye    {  printf("goodbye!\n"); }
     konnichiwa {                   
                    LINE 1      
                    ...             
                    LINE N      
                } 
     sayonara   printf("lex will not "); printf("print this\n");

どの行も複数の文を含むことができます。`|'は、そのルールにマッチするもの
が見つかった場合、次に現れるルールのアクション部に記述されているアクショ
ンが実行されるべきであることをFlexに通知します。

*注：*ほとんどのバージョンのLexは、`{'と`}'のペアの外部では単一の文しか
許しません（例えば上の`sayonara'ルールは許されません）。また、C以外の言
語をターゲットにしているLexでは、`{'と`}'のペアは、例えばPascalの場合の
`begin...end'のように、異なるシンボルに置き換える必要があるかもしれませ
ん。

ルールにマッチしなかった入力に対するデフォルトのアクションは、それを
`stdout'に出力することであり、一方、マッチしたパターンに対するデフォルト
のアクションは、それを破棄することであるという点に注意してください。これ
は、最も単純なFlexの定義が

     %%

であることを意味しています。これは、入力を変更せずそのまま`stdout'へ出力
するものです。別の単純な例として以下のようなものがあります。

     %%
     foobar

この場合、入力の中から`foobar'という文字の並びをすべて取り除き、取り除い
た結果を`stdout'に出力します。



File: flex-ja.info, Node: Pattern Matching, Next: Regular Expressions, Prev: Rules, Up: Flex Descriptions

パターン・セクション
====================

パターン・セクションは、"正規表現"と呼ばれる仕組みを使って実際のマッチン
グ処理を実行します。正規表現は、文字列、文字、文字集合（"クラス"）、およ
び演算子から構成されています。正規表現を構成する要素については次節以降で
説明します。また正規表現自体については、*Note Regular Expressions::にお
いて議論します。

========================================================================
* Menu:

* Characters:: Flexにおける文字、特殊文字* Strings:: Flexにおける文字列、
特殊文字列* Character Classes:: 文字クラスの説明、その使い方
* Character Class Expressions (Flex 2.5)::  同上（Flex 2.5の補足情報）
========================================================================



File: flex-ja.info, Node: Characters, Next: Strings, Prev: Pattern Matching, Up: Pattern Matching

文字
----

いくつかの文字はFlexにとって特別の意味があり、その文字を単独で使ったので
は、その文字自体を表すことができません。以下に、Flexにおける特殊文字とそ
の意味を表にして示します。


     `文字'
          Flexによる解釈

     `.'
          ピリオドは改行（`\n'）*以外*の任意の文字を表します。

     `\'
          バックスラッシュはエスケープ文字です。エスケープ・シーケンスは
          ANSI Cのものと同一です。

     `[ ]'
          角括弧[ ]は複数の文字を"文字クラス"にグループ化します。詳細に
          ついては、*Note Flexにおける文字のグループ化: Character
          Classes。

     `^'
          文字クラスの内部では^は否定を意味します。詳細については、*Note
          Flexにおける文字のグループ化: Character Classes。文字クラスの
          外部では、^は行の先頭を意味し、ルールの先頭にのみ置くことがで
          きます。例を以下に示します。

               `[^AB]'
                    否定クラスです。

               `^foo'
                    行の先頭にある`foo'という文字の並びにのみマッチしま
                    す。

               `foo^'
                    この場合、`^'は普通の文字であるとみなされます。この
                    ような時には、希望どおりの結果が*確実*に得られるよう
                    にするために、特別な意味を持つ文字の前にバックスラッ
                    シュ`\'を置くのが良いでしょう。このような文字の並び
                    を"エスケープ・シーケンス"と呼びます。エスケープ・シー
                    ケンスについてはこの節の最後で説明します。

     `-'
          ハイフンは文字クラスの内部において文字の範囲を表します。文字ク
          ラスの外部では、ハイフンはそれ自身を表します。詳細については、
          *Note Flexにおける文字のグループ化: Character Classes。

     `{ }'
          大括弧{ }は、定義の参照、複数行のアクションの囲み、またはある
          範囲にわたる繰り返しの定義を行います。例を挙げると、定義`FOO'
          があって、それをルールの中で参照したい場合に`{FOO}'を使います。

          与えられたパターンのある範囲にわたる繰り返しを定義するには、以
          下のような`{ REPETITION LIST }'を使います。

               %%
               f{2,5}  /* fの２回以上５回以下の繰り返し */
                       /* にマッチ                      */
               f{2,}   /* fの２回以上の繰り返しにマッチ */
               f{2}    /* fの２回の繰り返しにマッチ     */

          この用法の解釈において、 FlexとLexの間にはいくつかの相違点があ
          ります。詳細については、*Note Flex and POSIX::を参照してくださ
          い。

     `( )'
          丸括弧( )を使って優先順位を変更することができます。また、定義
          が展開される時には、その定義は暗黙のうちに丸括弧( )で囲まれる
          ことに注意してください。 (1) (*Note Characters-Footnotes::) こ
          のため、Lexとは非互換なところがでてきます。この点については、
          *Note Flex and POSIX::と*Note Definitions::で説明しています。

     `""'
          二重引用符記号は文字列を表します。引用符の内側の文字列だけがマッ
          チの対象になります。したがって、

               %%
               "string"

          は`"string"'にではなく、`string'にマッチします。

     `/'
          スラッシュは後続コンテキスト（trailing context）を設定します。
          これは、あるパターンの後ろに特定の文字の並びが続く場合のみ、そ
          のパターンを認識したいという状況です。つまり、スラッシュ`/'は
          「"ルック・アヘッド"（その先を見る）」演算子として機能するとい
          うことです。例を挙げると、

               `abcDEF'
                    `abcDEF' を認識します。

               `abc/DEF'
                    `abc'の後ろに`DEF'が続く場合に限り、`abc'を認識しま
                    す。`DEF'の部分は、あたかもまだ読まれてはいないかの
                    ように扱われ、マッチの対象になりません。

          *注：*１つのルールの中では`/'は１つだけ許されます。つまり、

               abc/def/hijkl

          は不正です。

     `< >'
          かぎ括弧< >はスタート状態を参照します。また、EOFシンボル
          （`<<EOF>>'）にも使われます。完全な説明については、*Note Start
          States::と*Note End-Of-File Rules::を参照してください。

     `? + *'
          `?'、`+'、`*'は、ある*正規表現*が現れることのできる回数を設定
          します。`?'は０回もしくは１回（その正規表現が現れることは必須
          ではないということ）を意味します。`+'は１回以上を意味します。
          `*'は０回以上を意味します。例えば、

               `a?'
                    ０個もしくは１個の`a'にマッチします。

               `a+'
                    １個以上の`a'にマッチします。

               `a*'
                    ０個以上の`a'にマッチします。

               `(ABC)+'
                    `ABC'という文字の並びが１回以上続くものにマッチしま
                    す。

               `[abQrS]?'
                    ０個もしくは１個の、（５つの文字`abQrS'から構成され
                    る）この文字クラスのメンバにマッチします。文字クラス
                    に関する詳細については、*Note Flexにおける文字のグルー
                    プ化: Character Classesを参照してください。

               `{NUM}*'
                    ０個以上の`NUM'にマッチします。ここでの`NUM'は定義で
                    す。定義に関する詳細については、*Note Definitions::
                    を参照してください。

     `|'
          OR演算子、および、特別なアクションを表します。例えば、

                  apples|oranges

          は`apples'もしくは`oranges'のいずれかにマッチし、

               apples         |
               oranges        printf("fruit!\n"); 

          は、`apples'と`oranges'の両方に対して同一の*アクション*を実行
          します。

     `$'
          ドル記号は行末を意味します。例えば、

                  end$

          はその直後が行末である場合にのみ`end'という文字の並びにマッチ
          します。これは、後ろに続くのが行末のマーカである場合のみ`end'
          にマッチする

                  end/\n

          とまったく同じです。


こうした文字のいずれかをその文字自身として表したい場合には、引用符で囲む
か、（後に示す表で説明する）エスケープ・シーケンスとして表さなければなり
ません。

Flexには３種類のエスケープ・シーケンスがあります。バックスラッシュ`\'に
続けて8進数を使うもの、`\x'に続けて16進数を使うもの、`\LETTER'という表記
法によってある１文字、または、特別な表示不可の文字を表すものの３つです。
Cをよく知っている人であれば、この３つがANSI Cのエスケープ・シーケンスで
あることに気がつくことでしょう。数値によるエスケープ・シーケンスは、100
パーセント移植性があるわけではなく、保守を困難にするので、避けるべきです。

以下に、
文字の使用に関する要約を示します。
この表中では、
`c'が単一の文字を、
`NNN'が8進定数を、
`HH'が16進定数を表します。


                         Flexにおける文字
     ============+========================================+============
       文字      |                  意味                  | 例
     ============+========================================+============
        c        | cが演算子でない場合は、文字c自体       | a
        .        | 改行（\n）以外の任意の文字             | .  
       "c"       | c                                      | "^", "$"
        \b       | バックスペース       （BS）            | [\b]
        \t       | 水平タブ             （HT）            | [\t]
        \n       | 改行                 （NL）            | [\n]
        \v       | 垂直タブ             （VT）            | [\v] 
        \f       | 頁送り               （FF）            | [\f]
        \r       | キャリッジ・リターン （CR）            | [\r]
        \\       | 単一バックスラッシュ                   | \\, \\b
        \"       | 単一引用符                             | \"
        \0       | NUL文字                                | \0
        \c       | cが上記以外の文字の場合、文字c自体     | \w
        \xHH     | 16進数HHを値として持つ文字             | \x1B 
        \NNN     | 8進数NNNを値として持つ文字             | \033





**注：*いくつかのバージョンのLexでは、
`\0'を正しく認識、またはマッチしません。これは、`\0'がNUL、つまりC文字列
の終端文字だからです。Flexでは、NULをマッチの対象にしても問題はありませ
んが、性能には若干影響します。*

さらに付け加えると、`^'演算子と`<<EOF>>'はルールの先頭にのみ置くことがで
きます。また、これらと`$'、`/'は丸括弧( )の内部に置くことはできません。
このことはまた、定義の正当性にも影響を及ぼします。というのは、展開される
時に定義は字義どおりに丸括弧( )で囲まれるからです。 (2) (*Note
Characters-Footnotes::) 詳細については、*Note Definitions::と*Note Flex
and POSIX::を参照してください。



File: flex-ja.info  Node: Characters-Footnotes, Up: Characters

(1) 訳注：Flex 2.5では、`-l'オプションを指定して生成され
たスキャナは、Lexの場合と同じように、定義を展開する時に丸括弧(
)で囲みません。

(2) 訳注：Flex 2.5では、`-l'オプションを指定して生成されたスキャナ
は、Lexの場合と同じように、定義を展開する時に丸括弧( )で囲みません。


File: flex-ja.info, Node: Strings, Next: Character Classes, Prev: Characters, Up: Pattern Matching

Flexにおける文字列
------------------

"文字列"とは、（常に、というわけではありませんが）多くの場合、引用符によっ
て囲まれる文字のグループです。エスケープ・シーケンスが使われない限り、文
字列には改行や表示不可の文字を含めることはできません。

`-i' オプション（詳細については、*Note Case Insensitive Scanners::）を使
わない限り、大文字・小文字の区別も含めた*字義どおり*の文字列に対してマッ
チが行われます。引用符付きの文字列については、引用符は認識される文字列に
は*含まれません*。

例えば、

     string
     StrING
     "STRING"
     \"string\"

はすべて正当な文字列であり、最後のものは引用符も含めてマッチされます。
Flexにおいては文字列には引用符は*必須*ではありません。したがって、キーワー
ドのグループにマッチさせる場合、

     begin
     end
     pointer
      ...

と

     "begin"
     "end"
     "pointer"
      ...

のいずれも正当です。



File: flex-ja.info, Node: Character Classes, Prev: Strings, Up: Pattern Matching

Flexにおける文字のグループ化
----------------------------

Flexでは、文字をグループ化して"文字クラス"にすることができます。文字クラ
スは、文字のグループを角括弧[ ]で囲むことにより作成されます。どのような
文字でも正当です（表示不可の文字についてはエスケープ・シーケンスを使いま
す）。また、文字の範囲をハイフン`-'を使って指定することができます。文字
クラスがルールの中で使われている場合には、Flexはそのクラスの任意のメンバ
とマッチさせ、あたかも単一文字が使われているかのように振る舞います。例え
ば、

     [a-z]
     [A-Z]*

において、最初の例は`a'から`z'までの任意の単一文字にマッチします。第２の
例は`A'から`Z'までの任意の文字が０個以上並んだものにマッチします。

*否定*文字クラスを表す正規表現を書くこともできます。否定文字クラスは、
（`\n'も含めて）文字クラスのメンバ*以外*であれば何にでもマッチします。こ
れを行うには、否定すべきクラスの先頭に`^'を置きます。（クラスの外部では
`^'は異なる意味を持つことに注意してください。）以下に、正当なクラスの例
をいくつか挙げます。

     `[abc]'
          `a'、`b'、`c'のいずれかにマッチします。

     `[abc\n]'
          `a'、`b'、`c'、`\n'のいずれかにマッチします。

     `[a-z]'
          ASCII値が`a'から`z'までの範囲にある任意の文字、すなわち、任意
          の英小文字にマッチします。

     `[^a-z]'
          `a'から`z'までの範囲にある文字*以外*の任意の文字にマッチします。

     `[ABcd]'
          `A'、`B'、`c'、`d'のいずれかにマッチします。

*注：*Flex、およびいくつかのバージョンのLexは、クラス内における逆方向の
範囲を扱うことができません。したがって、

     %% [z-a9-0] はエラー・メッセージを出力します。逆方向の範囲は指定し
ないでください。




File: flex-ja.info, Node: Character Class Expressions (Flex 2.5), Prev: Character Classes, Up: Pattern Matching

Flexにおける文字のグループ化（Flex 2.5の補足情報）
--------------------------------------------------

Flex 2.5では、文字クラスの中に"文字クラス式"を含めることができます。

文字クラス式は、形式的には、ある文字集合を識別する名前を`[:'と`:]'で囲ん
だものです。Flex 2.5では、以下の文字クラス式が有効です。

     [:alnum:] [:alpha:] [:blank:]
     [:cntrl:] [:digit:] [:graph:]
     [:lower:] [:print:] [:punct:]
     [:space:] [:upper:] [:xdigit:]

文字クラス式[:XXX:]は、ANSI Cの`isXXX()'関数がゼロ以外の値を返す文字の集
合に対応します。唯一の例外は[:blank:]で、`isblank'は（POSIXでは定義され
ているものの）ANSI Cでは定義されていないため、Flexでは、マクロ`IS_BLANK'
を

     #define IS_BLANK(c) ((c) == ' ' || (c) == '\t')

のように定義して、これが真となる文字の集合（すなわち、スペースとタブ）を
文字クラス式[:blank:]に対応させています。

文字クラス式を使えば、

     [a-zA-Z]
     [0-9]

を

     [[:alpha:]]
     [[:digit:]]

と書くことができます。

また、文字クラスの中に複数の文字クラス式を含めることができますので、

     [a-zA-Z0-9]

を、

     [[:alpha:][:digit:]]

と書くこともできます（もっとも、この例の場合は、[[:alnum:]]と書くほうが
良いでしょう）。



File: flex-ja.info, Node: Regular Expressions, Next: Start States, Prev: Pattern Matching, Up: Flex Descriptions

正規表現
========

Flexの文字、文字列、クラス、定義、および演算子を組み合わせることで、"正
規表現"として知られているものが作られます。（基本単位が数と演算子である）
数学表現と同じように、基本的な要素は単純なもの（文字、演算子、文字列、ク
ラス、および定義）ですが、要素を組み合わせることでより複雑な表現式を作る
ことができます。例えば、`c'は単一文字の正規表現で、`c'にマッチします。
`cc'は２つの正規表現をつないだものを含む正規表現で、`cc'にマッチします。
`c*'は、単一文字の正規表現`c'と、それに続く演算子`*'から構成される正規表
現で、０個以上の`c'にマッチします。正規表現の真のパワーは、個々の要素よ
りもむしろ、組み合わせ可能な方法の中にあります。

次の表は、
Flexで利用可能な正規表現をすべて示したものです。
表中において、
`c'は
（エスケープ・シーケンスを含む）
任意の単一文字を、
`r'は任意の正規表現を、
`s'は文字列を表します。
表はグループ別に編成してあり、
優先度の最も高いものが一番上にあります。

  

                           Flexにおける正規表現
     =============+=============================================+================
     正規表現     |           マッチの対象                      |   例        
     =============+=============================================+================
        c         | 特殊文字を除く任意の文字                    |  A、\n、a
        .         | 改行を除く任意の文字                        |    abc.*
        [s]       | クラスs中にある任意の文字                   |    [abc]
        [^s]      | クラスs中にない任意の文字                   |    [^abc]
        r*        | ０個以上のr                                 |  (a|b)*、[abc]*
        r+        | １個以上のr                                 |    (a|b)+
        r?        | ０個または１個のr                           |  (a|[b-q])?
        r{x,y}    | x個以上y個以下のr                           |   foo{1,5}
                  | （abc{1,3}は、abと１個以上３個以下のc）     |
        "s"       | 字義どおりの文字列s                         |    "***"
        \c        | （\cがANSI Cにおいて特別な意味を持たない    |    \"  \*
                  |   場合）c                                   |
        (r)       | r - 丸括弧()はグループ化のためのもの        |    (Aa|b)      
                  |                                             |
        r1r2      | r1の後ろにr2が続くもの                      | Aa、(A|a)[0-9]
                  |                                             |
        r1|r2     | r1またはr2                                  |     A|B
                  |                                             |
        r1/r2     | r2が後ろに続くという条件を満足するr1        |    abc/123
        ^         | 行頭                                        |    ^abc
        $         | 行末                                        |    abc$
                  |                                             |
        <start>r  | スタート状態（start状態の時、rがアクティブ）|  <command>"*/"
        <<EOF>>   | ファイルの終端（End-Of-Fileルールを参照）   |    <<EOF>>




Unixにおいてパターン検索が必要な場合には正規表現がよく使われますが、アプ
リケーションが異なると、正規表現もよく似てはいるもののまったく同一ではな
いという点に注意してください。例えば、Flex、`egrep'、`Emacs'はいずれもパ
ターン検索のテンプレートとして正規表現を使いますが、それぞれが理解する正
規表現は少しずつ異なります。特に、Flexでは定義が使われますが、`egrep'や
`Emacs'では使われませんし、`egrep'や`Emacs'は単語の先頭と末尾にマッチさ
せるための`\<'と`\>'とを提供していますが、Flexは提供していません。さらに、
`Emacs'はバッファの先頭に対するマッチングや「ファジー」なマッチング等を
行うための、特別な`\LETTER'シーケンスをほかにも数多く提供しています。



File: flex-ja.info, Node: Start States, Prev: Regular Expressions, Up: Flex Descriptions

スタート状態
============

なんらかの条件に基づいて、パターン・マッチング処理のルールを活性化するこ
とが便利な時があります。例えば、いくつかのコンピュータ言語では、重複して
いるスキャン・ルールの曖昧さを取り除くのを支援するために、パース状態を使
います。別の例としては、ある特定の入力が見つかったあとでだけ、あるルール
を活性化したいという場合があります。このような状況に対処するために、Flex
は"スタート条件"または"スタート状態"と呼ばれる単純なシステムを提供してい
ます。

========================================================================
* Menu:

* Start States Explained:: スタート状態の宣言、スキャナに対する効果*
Activating States:: スタート状態の活性化方法* Start State Notes:: 不当な
宣言、排他的スタート状態のパワーに関する注
* Start State Notes (Flex 2.5)::  同上 （Flex 2.5の補足情報）
* Start State Example::         スタート状態の使用例
========================================================================



File: flex-ja.info, Node: Start States Explained, Next: Activating States, Prev: Start States, Up: Start States

スタート状態の説明
------------------

スタート状態は、あるルールがアクティブになるのはいつであるかをFlexに通知
するブール値のようなものです。スタート状態は、定義セクションにおいて（排
他的スタート状態の場合）`%x' 、または（包含的スタート状態の場合）`%s'を
使って宣言されます。

     %x START_STATE_NAME
     %s START_STATE_NAME

START_STATE_NAMEは一意な名前でなければならない点に注意してください。つま
り、他のスタート状態や定義が同じ名前を持ってはならないということです。ス
タート状態は、１つの状態の名前、または、カンマで区切られた複数の状態の名
前をかぎ括弧< >で囲むことによって、ルール・セクションで参照されます。ス
タート状態の参照はルールの先頭になければならず、１つのルール中には１対の
かぎ括弧< >のみ許されます。このことは、

     %x state1
     %s state2
     %x state3 state4
     %%
     <state1>"foo"
     <state2,state3,state4>"bar"

が正当であり、

     integer [-+]?[0-9]*
     %x integer
     %s state1,state2,state3
     %%
     <integer>"foo"
     "bar"<state1>
     <state1>"bar"<state2,state3>

はすべて不当であることを意味しています。`integer'については同じ名前を持
つ定義が存在し、それ以外のものについてはスタート状態の参照の位置が正しく
ないか、複数の参照が存在するからです。

これまでのところでは、Flexが異なる２種類のスタート状態をサポートしている
事実から目をそらしてきました。２つのスタート状態とは、"包含的スタート状
態"（`%s'）と"排他的スタート状態"（`%x'）のことです。これら２つの相違点
は、排他的スタート状態が活性化された場合は、その状態に属するルール*だけ*
が活性化されるのに対して、包含的スタート状態の場合は、その状態に属するルー
ルとスタート状態への参照を持たないルールの両方が活性化されるという点にあ
ります。この違いを示す例を挙げると、以下のようになります。

     %s state1
     %%
     <state1>"one" printf("two");
     "three"       printf("four");

この場合、`state1'状態が活性化されている場合は`one'を`two'に置き換え、
*`state1'状態が活性化されているか否かにかかわらず*`three'を`four'に置き
換えます。デフォルトのルールにより、その他のテキストは`stdout'に出力され
ます。これに対して、

     %x state1
     %%
     <state1>"one" printf("two");
     "three"       printf("four");

は、`state1'状態が活性化されている時は`one'を`two'に置き換え、*`state1'
状態が活性化されていない時のみ*`three'を`four'に置き換えます。デフォルト
のルールにより、その他のテキストは`stdout'に出力されます。

このことは、排他的スタート状態が使われる場合には、マッチしないテキストが
`stdout'に出力されてはならないのであれば、すべての可能な入力にマッチする
ルールを、*個々*の排他的スタート状態が持たなければならないことを意味して
います。包含的スタート状態の場合は、あらゆる状態において有効な、スタート
状態への参照を持たないルールを１つ持つ必要があります。

*注：* 排他的スタート状態はPOSIXの一部であるにもかかわらず、Lexではサポー
トしていません。



File: flex-ja.info, Node: Activating States, Next: Start State Notes, Prev: Start States Explained, Up: Start States

状態の活性化
------------

スタート状態の名前を並べただけではあまり役に立ちません。つまり、スタート
状態がいつ活性化されるのかということも制御しなければなりません。活性化は、
アクションの中、または、記述情報内の追加的なCコードを記述する領域の中に
おいて、`BEGIN'を使うことで実現されます。使い方は以下のとおりです。

     BEGIN(START_STATE_NAME);

例を挙げると、以下のようになります。

     %x COMMENT
     %%
     "{"            BEGIN(COMMENT);
     <COMMENT>"$R"  
     <COMMENT>"$I"  
     <COMMENT>"$M"  
         ...  
     <COMMENT>"}"   BEGIN(INITIAL);

この場合、Pascalのコメントの先頭部分を見つけると`COMMENT'状態に移行し、
コンパイラ・オプションを認識するようになります。`BEGIN'は最初の`%%'の直
後（最初のルールの前）において使うこともでき、この場合は`yylex()'は常に
指定された状態で開始されます。

上の例においては、定義されていない`INITIAL'という状態があることに注意し
てください。この状態は常に利用可能で、*活性化された状態が１つも存在しな
い時*のスキャナの初期状態を表します。つまり、`BEGIN(INITIAL)'によって、
スキャナの状態が効果的に（もちろん、その時点においてスキャンしている箇所
を維持したまま）リセットされることを意味しています。



File: flex-ja.info, Node: Start State Notes, Next: Start State Example, Prev: Activating States, Up: Start States

スタート状態に関する注
----------------------

以下に、スタート状態の使用に関する注をいくつか示します。

   * 特殊文字

     １つのルールにおいては、単一のスタート状態、または、カンマで区切ら
     れたスタート状態のリストのみを使用することができます。また、こうし
     たスタート状態の指定はルールの先頭になければなりません。次に示すも
     のは正当です。

          %x state1
          %s state2
          %%
          <state1> "something"
          <state2> "another thing"
          <state, state2> "something else"

     しかし、次に示すものは不当です。

          %x state1
          %s state2
          %%
          wrong<state1>
          <state1><state2>"wrong"
          <state2>"wrong"<state1>

   * 排他的スタート状態

     排他的スタート状態は、他のすべての状態を「無効」にするので、強力で
     す。これは、スキャナの内部においてもう１つのスキャナを効果的に定義
     することができることを意味しています。これにより例えば、スタート状
     態次第で、CとPascalの両方をスキャンするスキャナを定義することが、理
     論的には可能になります。以下のようなコードが持つ効果を想像してみて
     ください。

          %x PASCAL
          %x C
          %%
          <PASCAL>begin     return(OPEN_BLOCK);
          <PASCAL>end       return(CLOSE_BLOCK);
          <C>{              return(OPEN_BLOCK);
          <C>}              return(CLOSE_BLOCK);

   * スタート状態の名前

     前述のとおり、スタート状態はそれ自身の名前空間を持っていません。そ
     の理由は、スタート状態が`#define'とほとんど同じ方法で整数値として定
     義されているからです。このことは、整数値と同様、スタート状態の「ス
     タック」のようなものを作成することが可能であることを意味しています。
     例えば、

          %{
              int last_state[MAX_STATES]
              int state_count = 0;
          %}
          %x FOO BAR baz
          %%
          FOO        {
                        last_state[state_count] = FOO;
                        state_count++; 
                        BEGIN(baz);
                     }
          BAR        {
                        last_state[state_count] = BAR;
                        state_count++; 
                        BEGIN(baz);
                     }
          <baz>RULE 1
               ...  
          <baz>RULE N
          <baz>END   {
                        statecount--;
                        BEGIN(last_state[statecount]);
                     } 

     は`FOO'と`BAR'の両方によって`baz'状態を活性化させ、`<baz>END'という
     ルールによって１つ前の状態に戻します。こうした「状態スタック」は将
     来、Flexの特徴的な機能になるかもしれません。 (1) (*Note Start State
     Notes-Footnotes::)



File: flex-ja.info  Node: Start State Notes-Footnotes, Up: Start State Notes

(1) 訳注：Flex 2.5は、スタート状態スタックをサポートしています。次
節（*Note Start State Notes (Flex 2.5)::）を参照してください。



File: flex-ja.info, Node: Start State Notes (Flex 2.5), Next: Start State Example, Prev: Start State Notes, Up: Start States

スタート状態に関する注（Flex 2.5の補足情報）
--------------------------------------------

Flex 2.5では、以下の新機能を利用することができます。

   * ワイルド・カード

     スタート状態`<*>'には特殊な意味があり、すべてのスタート状態にマッチ
     します。

     例えば、

          %x state1
          %%
          <state1>"one" printf("two");
          <*>"three"    printf("four");

     は、

          %s state1
          %%
          <state1>"one" printf("two");
          "three"	      printf("four");

     と同じ意味になります。

   * カレントなスタート状態

     マクロ`YY_START'により、カレントなスタート状態を参照することができ
     ます。

     前節（*Note Start State Notes::）の「スタート状態の名前」に示した例
     では、カレントなスタート状態を配列`last_state'に格納する処理を、以
     下のように記述していますが、

          FOO        {
                        last_state[state_count] = FOO;
                        ...
                     }

     この代入は、

                        last_state[state_count] = YY_START;

     のように書き換えることができます。

     Lexとの互換性のために、`YYSTATE'が、`YY_START'の別名として定義され
     ています。

   * スタート状態のスコープ

     スタート状態のスコープを定義することができます。これにより、同じス
     タート状態において複数のルールが存在する時に、その個々のルールにス
     タート状態を指定する必要がなくなります。

     スタート状態のスコープの形式は、以下のとおりです。

          <START_STATES>{
          ...
          }

     ここで、START_STATESは、単一のスタート状態、または、カンマで区切ら
     れたスタート状態のリストです。スタート状態のスコープの境界は、`{'と
     `}'によって指定されます。スタート状態のスコープを入れ子にすることも
     可能です。

     *Note Activating States::に示した例を、スタート状態のスコープを使っ
     て書き直すと、以下のようになります。

          %x COMMENT
          %%
          "{"            BEGIN(COMMENT);
          <COMMENT>{
              "$R"  
              "$I"  
              "$M"  
              ...  
              "}"        BEGIN(INITIAL);
          }

   * スタート状態スタック

     スキャナ定義ファイルで`%option stack'を指定すると、スタート状態スタッ
     クを利用できます。スタート状態スタックを操作するために、以下の関数
     が提供されています。

     `void yy_push_state(int NEW_STATE)'
          カレントなスタート状態をスタート状態スタックにプッシュし、
          NEW_STATE状態に遷移します。

     `void yy_pop_state()'
          スタート状態スタックからスタート状態をポップし、そのポップされ
          たスタート状態に遷移します。

     `int yy_top_state()'
          スタート状態スタックの先頭にあるスタート状態を返します（スター
          ト状態スタックの内容は変更されません）。

     前節（*Note Start State Notes::）の「スタート状態の名前」に示した例
     を、スタート状態スタックを使って書き直すと以下のようになります。

          %option stack
          %x FOO BAR baz
          %%
          FOO        {
                        yy_push_state(baz);
                     }
          BAR        {
                        yy_push_state(baz);
                     }
          <baz>RULE 1
               ...  
          <baz>RULE N
          <baz>END   {
                        yy_pop_state();
                     } 



File: flex-ja.info, Node: Start State Example, Prev: Start State Notes, Up: Start States

スタート状態の使用例
--------------------

プログラミングにおいて、何かをする方法を学ぶのに最良の方法は、実際にそれ
をやってみることです。そのことに留意し、スタート状態をどのように使うこと
ができるかを示す実例を以下に挙げます。


     /*
      * dates.lex: 日付の異なる形式を識別するために
      *            スタート状態を使用する例
      */

     %{
     #include <ctype.h>

     char month[20],dow[20],day[20],year[20];

     %}

     skip of|the|[ \t,]* /* この文字の並びを無視する */

     mon  (mon(day)?)    /* 曜日の名前の長い形式と短い形式の */
     tue  (tue(sday)?)   /* どちらにもマッチするよう設定する */
     wed  (wed(nesday)?)
     thu  (thu(rsday)?)
     fri  (fri(day)?)
     sat  (sat(urday)?)
     sun  (sun(day)?)

      /* 以下はすべての可能な曜日を表す */

     day_of_the_week ({mon}|{tue}|{wed}|{thu}|{fri}|{sat}|{sun})

     jan  (jan(uary)?)   /* すべての月について同様のことを行う */
     feb  (feb(ruary)?)
     mar  (mar(ch)?)
     apr  (apr(il)?)
     may  (may)
     jun  (jun(e)?)
     jul  (jul(y)?)
     aug  (aug(ust)?)
     sep  (sep(tember)?)
     oct  (oct(ober)?)
     nov  (nov(ember)?)
     dec  (dec(ember)?)

      /* 以下はすべての可能な月の名前を表す */

     first_half  ({jan}|{feb}|{mar}|{apr}|{may}|{jun})
     second_half ({jul}|{aug}|{sep}|{oct}|{nov}|{dec})
     month       {first_half}|{second_half}

      /*
       * 日、月、年の数値形式
       * これらは重複しているため、正しくパースするには、
       * スタート状態と日付の形式に関するある程度の知識
       * が必要であることに注意
       */

     nday         [1-9]|[1-2][0-9]|3[0-1] 
     nmonth       [1-9]|1[0-2]
     nyear        [0-9]{1,4}

      /* 年と日のための拡張子 */

     year_ext    (ad|AD|bc|BC)?
     day_ext     (st|nd|rd|th)?

       /*
        * このプログラムの最後にあるルールを使ってすべての無関係な
        * テキストを処理するために、非排他的なスタート状態を使う。
        * こうしないと、個々のスタート状態のブロックにルールを追加
        * しなければならなくなる。規模の大きいスキャナにおいては、
        * これは実行可能な選択肢であることが多い。なぜなら、ルール
        * の追加はスキャナのスピードに影響を与えないからである。
        * ここでは、簡潔さを優先させることにする
        */

     %s LONG SHORT
     %s DAY MONTH   /* 長い形式の日付のために追加した状態 */
     %s YEAR_FIRST YEAR_LAST YFMONTH YLMONTH

     %%

      /*
       * 曜日は常に最初に置かれ、後ろに続く日付の修飾子として
       * 機能するものと仮定される。よって、曜日は複数の日付形式
       * の間で共用可能である
       */

     <LONG>{day_of_the_week} strcpy(dow,yytext); 

      /*
       * 月-日-年という形式の日付を処理する
       * パース状態は
       * LONG->[月にマッチ]->DAY->LONG
       * のように遷移する
       */

     <LONG>{month}         strcpy(month,yytext); BEGIN(DAY);
     <DAY>{nday}{day_ext}  strcpy(day,yytext);   BEGIN(LONG);  

      /*
       * 日-月-年という形式の日付を処理する
       * パース状態は
       * LONG->[日にマッチ]->MONTH->LONG
       * のように遷移する
       */

     <LONG>{nday}{day_ext} strcpy(day,yytext);   BEGIN(MONTH);
     <MONTH>{month}        strcpy(month,yytext); BEGIN(LONG);

      /*
       * 日付の年の部分は最後に置かれるものと考えられる。したがって、
       * 年を見つけたらパースされた日付を表示することができる。もち
       * ろん、日付として不当なものであればゴミが出力されることになる
       */

     <LONG>{nyear}{year_ext} {
                               printf("Long:\n");
                               printf("  DOW   : %s \n",dow);
                               printf("  Day   : %s \n",day);
                               printf("  Month : %s \n",month);
                               printf("  Year  : %s \n",yytext);
                               strcpy(dow,"");
                               strcpy(day,"");
                               strcpy(month,"");
                             }

      /*
       * 日-月-年という形式の日付を処理する
       * SHORT状態で数値形式の日を見つけた場合は、年が日付の最後の部分
       * になると仮定する
       * パース状態は
       * SHORT->[日にマッチ]->YEAR_LAST->YLMONTH->SHORT
       * のように遷移する
       */

     <SHORT>{nday}        strcpy(day,yytext);  BEGIN(YEAR_LAST);
     <YEAR_LAST>{nmonth}  strcpy(month,yytext);BEGIN(YLMONTH);
     <YLMONTH>{nyear}     strcpy(year,yytext); BEGIN(SHORT);

      /*
       * 年-月-日という形式の日付を処理する
       * SHORT状態で数値形式の年を見つけた場合は、日が日付の最後の部分
       * になると仮定する
       * パース状態は
       * SHORT->[年にマッチ]->YEAR_FIRST->YFMONTH->SHORT 
       * のように遷移する
       */

     <SHORT>{nyear}        strcpy(year,yytext); BEGIN(YEAR_FIRST);
     <YEAR_FIRST>{nmonth}  strcpy(month,yytext);BEGIN(YFMONTH);
     <YFMONTH>{nday}       strcpy(day,yytext);  BEGIN(SHORT);

      /*
       * 数値形式の日付では、年は最初になることも最後になることも可能。
       * したがって、パースしたものをいつ表示すべきかを示すのに改行を使う
       */

     <SHORT>\n               {
                               printf("Short:\n");
                               printf("  Day   : %s \n",day);
                               printf("  Month : %s \n",month);
                               printf("  Year  : %s \n",year);
                               strcpy(year,""); 
                               strcpy(day,"");
                               strcpy(month,"");
                             }

      /*
       * 以下により、短い（数字）形式と長い（英数字）形式とを切り換える
       */

     long\n     BEGIN(LONG);
     short\n    BEGIN(SHORT);

      /*
       * 以下のルールは、無関係なテキストを見つけて破棄する
       * （マッチされたテキストはデフォルトではECHOされないが、
       *   マッチされなかったテキストはECHOされる。ピリオドは
       *   改行以外のすべての文字を見つける。改行は\nによって
       *   見つけられる）
       */

     {skip}*
     \n
     .  

この実例は、様々な形式の日付をスキャンし、構成単位に分割します。例えば、
以下のものを正しくスキャンし、日付の個々の部分を識別します。

     short
     1989:12:23
     1989:11:12
     23:12:1989
     11:12:1989
     1989/12/23
     1989/11/12
     23/12/1989
     11/12/1989
     1989-12-23
     1989-11-12
     23-12-1989
     11-12-1989
     long
     Friday the 5th of January, 1989
     Friday, 5th of January, 1989
     Friday, January 5th, 1989
     Fri, January 5th, 1989
     Fri, Jan 5th, 1989
     Fri, Jan 5, 1989
     FriJan 5, 1989
     FriJan5, 1989
     FriJan51989
     Jan51989

ファイルの最初の部分では、月、および、日付の異なる部分に使われる数字形式
を単に定義しています。この実例では、ある特定の方法でスキャン処理が進行す
るよう強制するために、スタート状態を使います。例えば、行の先頭で`1989'を
見つければ、それが日と月の組み合わせではなく年であり、したがって、日付の
次の部分が月に違いないことが分り、スキャン処理がそのとおりに進むよう強制
します。このことにより、非常に単純な状態駆動のパーサを効果的に作成したこ
とになり、日付をその構成要素にうまく分割することができるようになります
（このスキャナの内部で起こっていることをフロー・チャートに描いてみれば、
このことが明瞭に見てとれるでしょう）。

このマニュアル中の他の実例と同様に、この実例も

     flex -i dates.lex
     cc -o dates lex.yy.c -lfl

を実行することによりコンパイルすることができます。また、`examples'サブディ
レクトリにおいて単に`make dates'を実行することにより、コンパイルすること
もできます。




File: flex-ja.info, Node: %option (Flex 2.5), Prev: Start States, Up: Flex Descriptions

%option（Flex 2.5の補足情報）
=============================

Flex 2.5では、スキャナ定義ファイルの中で様々なオプションを指定することが
できます。オプションを指定するには、スキャナ定義ファイルの先頭（最初の
`%%'よりも前の部分）に、`%option'指示子を記述します。

ほとんどの`%option'指示子は、以下の形式で指定されます。

     %option OPTION_NAME

オプションOPTION_NAMEの指定を無効にするためには、オプション名の前に`no'
を付けます。

     %option noOPTION_NAME


以下に、コマンドライン・オプションと同等の効果を持つ`%option'指示子を示
します。各コマンドライン・オプションの意味については、*Note Command Line
Switches::と*Note Command Line Switches (Flex 2.5)::を参照してください。

`%option 7bit'
     -7オプション

`%option 8bit'
     -8オプション

`%option align'
     -Caオプション

`%option backup'
     -bオプション

`%option batch'
     -Bオプション

`%option c++'
     -+オプション

`%option caseful'
     -iオプションの否定

`%option case-sensitive'
     -iオプションの否定

`%option case-insensitive'
     -iオプション

`%option caseless'
     -iオプション

`%option debug'
     -dオプション

`%option default'
     -sオプションの否定

`%option ecs'
     -Ceオプション

`%option fast'
     -Fオプション

`%option full'
     -fオプション

`%option interactive'
     -Iオプション

`%option lex-compat'
     -lオプション

`%option meta-ecs'
     -Cmオプション

`%option output="FILE"'
     -oFILEオプション

`%option perf-report'
     -pオプション

`%option prefix="PREFIX"'
     -PPREFIXオプション

`%option read'
     -Crオプション

`%option stdout'
     -tオプション

`%option verbose'
     -vオプション

`%option warn'
     -wオプションの否定


次に、コマンドライン・オプションでは代替できない`%option'指示子を示しま
す。

`%option array'
     `yytext'を`char'の配列として定義します。これは、`%array'と同じです。

`%option always-interactive'
     入力を常に対話的に扱うスキャナを生成するよう指示します。これと
     `%option never-interactive'のどちらも指定されない場合、生成されたス
     キャナは、ファイルをオープンするたびに`isatty()'を呼び出して、入力
     を対話的に（１文字ずつ）読み込むべきか否かを決定します。

`%option main'
     生成されるスキャナに、以下のような`main()'関数を組み込むよう指示し
     ます。

          int main()
          	{
          	yylex();
          	return 0;
          	}

     これは、暗黙のうちに`%option noyywrap'を指定します。

`%option never-interactive'
     入力を常に対話的に扱わないスキャナを生成するよう指示します。これと
     `%option always-interactive'のどちらも指定されない場合、生成された
     スキャナは、ファイルをオープンするたびに`isatty()'を呼び出して、入
     力を対話的に（１文字ずつ）読み込むべきか否かを決定します。

`%option pointer'
     `yytext'を`char'に対するポインタとして定義します。これは、
     `%pointer'と同じです。

`%option reject'
     スキャナ定義ファイルの中で`REJECT'が使われていることを、Flexに通知
     します。Flexは通常、定義ファイルの中で`REJECT'が使われているか否か
     を自分で調査しますが、この`%option'指示子の指定は、Flex自身による判
     定結果に優先します。

`%option stack'
     スタート状態スタック（*Note Start State Notes (Flex 2.5)::を参照）
     を使用するためには、この`%option'指示子を指定しなければなりません。

`%option stdinit'
     `yyin'を`stdin'で、`yyout'を`stdout'で、それぞれ初期化します。この
     `%option'指示子が指定されない場合、あるいは、`%option nostdinit'が
     指定された場合、`yyin'と`yyout'は、`(FILE *)0'（NULLポインタ）で初
     期化されます。

`%option unput'
     `%option *no*unput'が指定されると、生成されるスキャナの中に、関数
     `unput()'が組み込まれません。 (1) (*Note %option (Flex
     2.5)-Footnotes::)

`%option yy_pop_state'
     `%option *no*yy_pop_state'が指定されると、生成されるスキャナの中に、
     関数`yy_pop_state()'が組み込まれません。ただし、`%option stack'が指
     定されていない場合は、`%option *no*yy_pop_state'の指定の有無にかか
     わらず、関数`yy_pop_state()'は組み込まれません。

`%option yy_push_state'
     `%option *no*yy_push_state'が指定されると、生成されるスキャナの中に、
     関数`yy_push_state()'が組み込まれません。ただし、`%option stack'が
     指定されていない場合は、`%option *no*yy_push_state'の指定の有無にか
     かわらず、関数`yy_push_state()'は組み込まれません。

`%option yy_scan_buffer'
     `%option *no*yy_scan_buffer'が指定されると、生成されるスキャナの中
     に、関数`yy_scan_buffer()'が組み込まれません。

`%option yy_scan_bytes'
     `%option *no*yy_scan_bytes'が指定されると、生成されるスキャナの中に、
     関数`yy_scan_bytes()'が組み込まれません。

`%option yy_scan_string'
     `%option *no*yy_scan_string'が指定されると、生成されるスキャナの中
     に、関数`yy_scan_string()'が組み込まれません。

`%option yy_top_state'
     `%option *no*yy_top_state'が指定されると、生成されるスキャナの中に、
     関数`yy_top_state()'が組み込まれません。ただし、`%option stack'が指
     定されていない場合は、`%option *no*yy_top_state'の指定の有無にかか
     わらず、関数`yy_top_state()'は組み込まれません。

`%option yyclass="CLASSNAME"'
     これは、`-+'オプションが指定されている場合（すなわち、C++スキャナを
     生成する場合）のみ有効です。これにより、CLASSNAMEにより指定される名
     前のクラスが、`yyFlexLexer'のサブクラスとして定義されます。実際にス
     キャン処理を実行するコードは、クラスCLASSNAMEのメンバ関数`yylex()'
     （`CLASSNAME::yylex()'）に実装されます。詳細については、*Note Flex
     and C++ (Flex 2.5)::を参照してください。

`%option yylineno'
     入力の行数をカウントして大域変数`yylineno'に保持するスキャナを生成
     するよう指示します。

`%option yymore'
     スキャナ定義ファイルの中で`yymore()'が使われていることを、Flexに通
     知します。Flexは通常、定義ファイルの中で`yymore()'が使われているか
     否かを自分で調査しますが、この`%option'指示子の指定は、Flex自身によ
     る判定結果に優先します。

`%option yywrap'
     `%option *no*yywrap'が指定されると、`yywrap()'はマクロとして、

          #define yywrap() 1

     のように定義されます。この結果、ファイルの終端を検出した時に、スキャ
     ナは、ほかにスキャンすべきファイルは存在しないと判断するようになり
     ます。




