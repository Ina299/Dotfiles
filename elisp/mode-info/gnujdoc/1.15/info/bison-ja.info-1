Info file: bison-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `bison-ja.texinfo'
using `texinfmt.el' version 2.38 of 3 July 1998.









START-INFO-DIR-ENTRY
* bison-ja: (bison-ja). GNU Project parser generator (yacc replacement).
END-INFO-DIR-ENTRY

このファイルはBison構文解析器生成器の説明文書です。

Copyright (C) 1988, 89, 90, 91, 92, 93, 95, 98, 1999 Free Software
Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "GNU General Public License" and "Conditions for Using
Bison" are included exactly as in the original, and provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "GNU General Public License",
"Conditions for Using Bison" and this permission notice may be included
in translations approved by the Free Software Foundation instead of in
the original English.





File: bison-ja.info, Node: Top, Next: Introduction, Prev: (dir), Up: (dir)

このマニュアルはBison 1.28の説明文書です。

* Menu:

* Introduction::      
* Conditions::        
* Copying::           GNU一般使用公有許諾書はBisonを複製したり共有したり
                        する方法を示している

チュートリアル部分:
* Concepts::          Bisonを理解するための基本概念.
* Examples::          Bisonの利用を簡単に説明した3つの例.

参照部分:
* Grammar File::      Bisonの宣言と規則を書く.
* Interface::         解析器関数`yyparse'へのC言語のインターフェース.
* Algorithm::         Bison解析器が実行時に動作する方法.
* Error Recovery::    エラー回復の規則を書く.
* Context Dependency::  言語構文がBisonが率直に扱うには複雑すぎるときに
                        何をすべきか.
* Debugging::         間違った解析をするBison解析器のデバッグをする.
* Invocation::        (解析器ソースファイルを生成するために)Bisonを実行
                      する方法.
* Table of Symbols::  Bisonの全てのキーワードの説明.
* Glossary::          基本概念の説明.
* Index::             テキストへの相互参照.

 -- The Detailed Node Listing ---

Bisonの概念

* Language and Grammar::  数学の発想と同じ、言語と文脈に依存しない文法.
* Grammar in Bison::  Bisonのために文法を表現する方法.
* Semantic Values::   それぞれのトークンや文法グループは意味値
                        （整数の値、識別子の名前、など。）
                         を取ることができる.
* Semantic Actions::  それぞれの規則はCコードを含んだアクションを持つこ
                        とができる.
* Bison Parser::      Bisonの入力と出力な何で、出力はどのように使われる
                       か。
* Stages::            Bisonの文法を書いて実行させる手順.
* Grammar Layout::    Bison文法ファイルの全体の構造.

例

* RPN Calc::          逆ポーランド記法電卓;
                        演算子の優先順位が無い、最初の例.
* Infix Calc::        中間（代数）記法電卓.
                        演算子の優先順位が導入された.
* Simple Error Recovery::  構文エラーの後も続行する.
* Multi-function Calc::  メモリと三角関数付きの電卓.
                           意味値に複数のデータ型を使用する.
* Exercises::         多機能電卓を改善するための着想.

逆ポーランド記法電卓

* Decls: Rpcalc Decls.  rpcalcのためのBisonとCの宣言.
* Rules: Rpcalc Rules.  rpcalcのための文法規則。説明付き.
* Lexer: Rpcalc Lexer.  字句解析器.
* Main: Rpcalc Main.    制御関数.
* Error: Rpcalc Error.  エラー報告関数.
* Gen: Rpcalc Gen.      文法ファイルでBisonを実行する.
* Comp: Rpcalc Compile. 出力コードにCコンパイラを実行する.

`rpcalc'のための文法規則

* Rpcalc Input::      
* Rpcalc Line::       
* Rpcalc Expr::       

多機能電卓：`mfcalc'

* Decl: Mfcalc Decl.      多機能電卓のためのBisonの宣言.
* Rules: Mfcalc Rules.    電卓のための文法規則.
* Symtab: Mfcalc Symtab.  記号表を管理するサブルーチン.

Bison文法ファイル

* Grammar Outline::   文法ファイルの概略.
* Symbols::           終端記号と非終端記号.
* Rules::             文法規則の書き方.
* Recursion::         再帰的規則の書き方.
* Semantics::         意味値とアクション.
* Declarations::      全ての種類のBison宣言の説明.
* Multiple Parsers::  一つのプログラムに一つより多くのBison構文解析器を
                        入れる.

Bison文法の概要

* C Declarations::    C宣言部の構文と使用法.
* Bison Declarations::  Bison宣言部の構文と使用法.
* Grammar Rules::     文法規則部の構文と使用法.
* C Code::            追加のCコード部の構文と使用法.

言語の意味の定義

* Value Type::        全ての意味値に一つのデータ型を指定する.
* Multiple Types::    複数の別のデータ型を指定する.
* Actions::           アクションは文法規則の意味的定義.
* Action Types::      アクションが操作するデータ型を指定する.
* Mid-Rule Actions::  ほとんどのアクションは規則の最後に行く.
                      これは規則の最中で、いつ、なぜ、どのように
                        例外アクションを使用するかを指示する.

Bison宣言

* Token Decl::        終端記号を宣言する.
* Precedence Decl::   優先順位と結合規則とともに終端を宣言する.
* Union Decl::        全ての意味値の型の集合を宣言する.
* Type Decl::         非終端記号のための型の選択を宣言する.
* Expect Decl::       シフト/還元衝突の警告を抑制する.
* Start Decl::        開始記号を指定する.
* Pure Decl::         再入構文解析器を要求する.
* Decl Summary::      全てのBison宣言の表.

構文解析器のC言語インターフェイス

* Parser Function::   `yyparse'の呼び方と、それが返すもの.
* Lexical::           トークンを読み込む関数`yylex'を提供しなければ
                        ならない.
* Error Reporting::   関数`yyerror'を提供しなければならない.
* Action Features::   アクションで使える特別な機能.

字句解析器関数`yylex'

* Calling Convention::  `yyparse'が`yylex'を呼ぶ方法.
* Token Values::      `yylex'がどのように読み込んだトークンの
                        意味値を返さなければならないか.
* Token Positions::   アクションが望むときに、どのように`yylex'が
                        テキストの位置（行数など）を返さなければならない
                        か。
* Pure Calling::      純粋な構文解析器で呼び出し型の習慣がどのように
                        違うか (*Note A Pure (Reentrant) Parser: Pure Decl.).

Bison構文解析器のアルゴリズム

* Look-Ahead::        構文解析器は何をするかを決めるときに一つ先のトーク
                        ンを見る.
* Shift/Reduce::      衝突: シフトと還元の両方が有効なとき.
* Precedence::        演算子の優先順位は衝突を解決することで動作する.
* Contextual Precedence::  演算子の優先順位が文脈に依存するとき.
* Parser States::     構文解析器はスタック付きの有限状態機械.
* Reduce/Reduce::     同じ状況に2つの規則が適用可能なとき.
* Mystery Conflicts::  正しくないように見える還元/還元衝突.
* Stack Overflow::    スタックが一杯になったときに何が起こるうか. それを
                        避ける方法.

演算子の優先順位

* Why Precedence::    優先順位が必要なことを示す例.
* Using Precedence::  Bison文法で優先順位を指定する方法.
* Precedence Examples::  前の例でこれらの機能が使われた方法.
* How Precedence::    どのように動作するか.

文脈依存性の処理

* Semantic Tokens::   トークン構文解析は意味的文脈に依存する.
* Lexical Tie-ins::   トークン構文解析は構文的文脈に依存する.
* Tie-in Recovery::   字句結び付きはエラー回復規則を書く方法に影響する.

Bisonの実行

* Bison Options::     全てのオプションが詳しく、短いオプションでアルファ
                        ベット順に説明されている.
* Option Cross Key::  長いオプションのアルファッベット順のリスト.
* VMS Invocation::    VMSでのBisonのコマンド構文.



File: bison-ja.info, Node: Introduction, Next: Conditions, Prev: Top, Up: Top

まえがき
********

Bisonは、LALR(1)文脈自由文法の文法定義を、その文法を解析するためのCで書
かれたプログラムに変換する、汎用の構文解析器生成ツールです。あなたが
Bisonに熟練すれば、簡単な電卓から複雑なプログラミング言語まで、広い範囲
の言語解析器を開発できるようになるでしょう。

BisonはYaccの上位互換です。正しく書かれたすべてのYacc文法を、変更なく
Bisonで処理できます。Yaccに親しんでいるすべての人は、ちょっと考えるだけ
で、Bisonを使えるようになるでしょう。Bisonを使い、本書を理解するためには、
C言語に精通している必要があります。

1章と2章は入門の章です。1章では、Bisonを使うための基本的な概念を説明し、
2章では3つの具体例を示します。BisonやYaccを知らない方は、1章から読みはじ
めてください。3章以降では、Bisonの仕様を詳細に解説します。

Bisonは、最初にRobert Corbettによって開発され、Richard StallmanがYacc互
換にしました。カーネギーメロン大学のWilfred Hansenが、文字列リテラル (1)
(*Note Introduction-Footnotes::)といくつかの機能を追加しました。

本書は、Bisonのバージョン 1.28に基づいています。


日本語訳にあたって
==================

本書は、株式会社アスキーの支援を受けて、慶應義塾の石川直太
（`naota@sfc.keio.ac.jp、http://www.sfc.keio.ac.jp/~naota/'）が翻訳しま
した。

なお、「GNU一般公有使用許諾書」の日本語訳については、引地さんのところの
日本語訳を使わせていただいたことをここに記して感謝いたします。

日本語訳したtexinfoファイルは、
`http://www.ascii.co.jp/pub/GNU/bison-1.25-man-jp.tgz' にあります。コマ
ンドtexi2dviなどでdviファイルを生成したり、GNU Emacsでinfoファイルへ変換
したりできます。

バージョン1.25 からバージョン 1.28の変更はgnujdocプロジェクトの一環とし
て林芳樹 (t90553@mail.ecc.u-tokyo.ac.jp) が行いました。

gnujdoc の詳細は、`http://duff.kuicr.kyoto-u.ac.jp/%7Eokuji/gnujdoc/'を
参照してください。


File: bison-ja.info  Node: Introduction-Footnotes, Up: Introduction

(1) 【訳注】2文字以上の文字列、たとえば`=='を、トークン名に使う機能。



File: bison-ja.info, Node: Conditions, Next: Copying, Prev: Introduction, Up: Top

Bisonの利用条件
***************

Bisonバージョン1.24において、フリーでないプログラムへのBisonの出力の利用
を許可するために、`yyparse'の配布条件を変えました。それまでは、Bisonによっ
て生成された構文解析器は、フリーソフトウェアのプログラム中でのみ、利用可
能でした。

GNU Cコンパイラなど他のGNUプログランミングツールには、このような制限があ
りません。それらは、いつでも、フリーでないソフトウェアの開発に利用できま
す。Bisonの利用条件が異なっていた理由は、特別な政治的判断によるものでは
ありません。BisonのすべてのソースコードにGPLを適用した結果です。

Bisonの出力であるBison構文解析器ファイルには、`yyparse'関数のためのコー
ドである、かなりの量のBisonのソースコードの一部分が、そのまま含まれます
（あなたが定義した文法によるアクションは、この関数の1か所に挿入されるだ
けで、残りの関数は変わりません）。われわれFSFが`yyparse'のコードにGPLを
適用した結果、Bisonの出力をフリーソフトウェアのみに利用するという制約が
できたのです。

ソフトウェアを専売しようとする人々への思いやりによって、われわれが条件を
変えることはありませんでした。*ソフトウェアはフリーであるべきです。* し
かし、われわれは、Bisonの利用をフリーソフトウェアに限定したことは、他の
ソフトウェアをフリーにしようとする人々を勇気づけるために、少なからず役立っ
ただろうと、結論を下しました。そこで、われわれは、その他のGNUツールの現
実的な利用条件に合わせて、Bisonの現実的な利用条件を決定することにしまし
た。




File: bison-ja.info, Node: Copying, Next: Concepts, Prev: Conditions, Up: Top

GNU GENERAL PUBLIC LICENSE
**************************
                          Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.


Preamble
========

  The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free software--to
make sure the software is free for all its users.  This General Public
License applies to most of the Free Software Foundation's software and
to any other program whose authors commit to using it.  (Some other Free
Software Foundation software is covered by the GNU Library General
Public License instead.)  You can apply it to your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it if
you want it, that you can change the software or use pieces of it in new
free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on the
     Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's source
     code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion of
     it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program or
          any part thereof, to be licensed as a whole at no charge to
          all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not apply
     to those sections when you distribute them as separate works.  But
     when you distribute the same sections as part of a whole which is a
     work based on the Program, the distribution of the whole must be on
     the terms of this License, whose permissions for other licensees
     extend to the entire whole, and thus to each and every part
     regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on a
     volume of a storage or distribution medium does not bring the other
     work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either source
     or binary form) with the major components (compiler, kernel, and so
     on) of the operating system on which the executable runs, unless
     that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses terminated
     so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this License
     to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program subject
     to these terms and conditions.  You may not impose any further
     restrictions on the recipients' exercise of the rights granted
     herein.  You are not responsible for enforcing compliance by third
     parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who receive
     copies directly or indirectly through you, then the only way you
     could satisfy both it and this License would be to refrain entirely
     from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies to
     it and "any later version", you have the option of following the
     terms and conditions either of that version or of any later version
     published by the Free Software Foundation.  If the Program does not
     specify a version number of this License, you may choose any
     version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted by
     the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                 NO WARRANTY

 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS
     AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
     OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
     FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
     PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
     DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR
     OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS


How to Apply These Terms to Your New Programs
=============================================

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND AN IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     as published by the Free Software Foundation; either version 2
     of the License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License along
     with this program; if not, write to the Free Software Foundation, Inc.,
     59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

Also add information on how to contact you by electronic and paper mail.

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'.  This is free software, and you are welcome
     to redistribute it under certain conditions; type `show c' 
     for details.

The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the program, if
necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright
     interest in the program `Gnomovision'
     (which makes passes at compilers) written 
     by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

This General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications
with the library.  If this is what you want to do, use the GNU Library
General Public License instead of this License.




File: bison-ja.info, Node: Concepts, Next: Examples, Prev: Copying, Up: Top

Bisonの概念
***********

この章では、Bisonの詳細を理解するのに欠くことのできない、多くの基礎概念
を説明します。まだBisonやyaccの使い方を知らない方は、この章を注意深く読
むことから始めてください。

* Menu:

* Language and Grammar::  数学の発想と同じ、言語と文脈に依存しない文法.
* Grammar in Bison::  Bisonのために文法を表現する方法.
* Semantic Values::   それぞれのトークンや文法グループは意味値
                        （整数の値、識別子の名前、など。）
                         を取ることができる.
* Semantic Actions::  それぞれの規則はCコードを含んだアクションを持つこ
                        とができる.
* Bison Parser::      Bisonの入力と出力な何で、出力はどのように使われる
                       か。
* Stages::            Bisonの文法を書いて実行させる手順.
* Grammar Layout::    Bison文法ファイルの全体の構造.




File: bison-ja.info, Node: Language and Grammar, Next: Grammar in Bison, Prev: Concepts, Up: Concepts

言語と文脈自由文法
==================


Bisonが言語を解析するためには、その言語が"文脈自由文法（context-free
grammar）"で記述されている必要があります。すなわち、1個以上の"文法グルー
プ（syntactic groupings）"を定め、その文法グループを部品から組み立てる規
則を与える必要があります。たとえば、C言語では、ある種のグループは「式」
と呼ばれます。式を作る規則の1つは、「1つの式とは、別の式にマイナス記号を
付けたものでもよい」かもしれません。別の規則は、「1つの式とは、整数でも
よい」かもしれません。ここから解るように、規則はしばしば再帰的になります
が、再帰を始めるための少なくとも1個の規則が必要です。


このような規則を人間が読めるように表現する、もっとも一般的な形式的な方法
は、"バッカス-ナウア記法（Backus-Naur form）"略して"BNF"です。これは、
Algol 60言語を定義するために開発されました。BNFで表現された任意の言語は、
文脈自由言語です。Bisonへの入力は、本質的には、機械可読なBNFです。

すべての文脈自由言語をBisonで扱えるわけではありません。LALR(1)だけを扱え
ます。簡単に説明すると、ちょうど1個のトークンを先読みすることによって、
入力文字列の任意の部分を解析できる必要があるということです。厳密に説明す
ると、これはLR(1)文法の説明で、LALR(1)には簡単に説明できない追加の制限が
あります。しかし、LALR(1)になれないLR(1)文法は、現実にはまれです。より詳
しい説明は*Note Mysterious Reduce/Reduce Conflicts: Mystery Conflicts。


ある言語についての形式文法的な規則では、文法的な単位またはグループを"記
号（symbol）"と呼びます。文法規則に従って小さい部分から組み立てられた記
号を"非終端記号（nonterminal symbol）"といい、"終端記号（terminal symbol）
"または"トークン型（token type）"と呼ばれるものに分解できます。本書では、
1個の終端記号に対応する入力の一部分を"トークン（token）"、1個の非終端記
号に対応する入力の一部分を"グループ（grouping）"と呼びます。

何が終端記号で何が非終端記号かを示すために、例としてC言語を使います。Cの
トークンは、識別子、定数（数値または文字列）、さまざまな予約語、算術演算
子、区切り記号です。C言語の終端記号には、「識別子」、「数値」、「文字列」、
そして、予約語、演算子、区切り記号のそれぞれに対する記号、すなわち、「i
f」、「return」、「const」、「static」、「int」、「char」、「プラス記号」、
「開きブレース」、「閉じブレース」、「カンマ」、などが含まれます（これら
のトークンは文字に分解できますが、それは文法の問題ではなく、字句解析の問
題です）。

次の例は、トークンに分解されたCの関数です。

     int             /* 予約語 `int' */
     square (x)      /* 識別子, 開きかっこ, */
                     /* 識別子, 閉じかっこ */
          int x;     /* 予約語 `int', 識別子, セミコロン */
     {               /* 開きブレース */
       return x * x; /* 予約語 `return', 識別子, */
                     /* アスタリスク, 識別子, セミコロン */
     }               /* 閉じブレース */

Cの文法的なグループには、式、文、宣言、関数定義が含まれます。これらは、C
の文法で、非終端記号、「式」、「文」、「宣言」、「関数定義」として表され
ます。完全な文法では、上記の4つの意味を表現するために、それぞれの非終端
記号について、数十個の追加の言語構築が必要です。上記の例で、関数定義は、
宣言と文を含みます。文の中で、それぞれの`x'は式であり、`x * x'も式です。

それぞれの非終端記号には、それがより単純な構成要素からどのように作られる
か示すために、文法規則が必要です。たとえば、Cの文の1つである`return'文に
ついて、文法規則を形式ばらずに書くと、次のようになります。

     「文」は、キーワード「`return'」、「式」、「セミコロン」から作るこ
     とができる。

Cの各種の文について、「文」には多くの他の規則があるでしょう。

1つの非終端記号が、言語の全体を表現するように、特別なものとして識別され
る必要があります。これを"開始記号（start symbol）"と呼びます。コンパイラ
では、これは完全な入力プログラムを意味します。C言語では、非終端記号「定
義と宣言の並び」が、この働きをします。

たとえば、`1 + 2'は有効なCの式で、Cのプログラムの有効な一部分ですが、Cプ
ログラム*全体*としては無効です。したがって、Cの文脈自由文法では、「式」
は開始記号でないとわかります。

Bison構文解析器は、入力としてトークンの列を読み、文法規則を使ってトーク
ンをグループにします。もし入力が有効であれば、最終的な結果として、トーク
ンの列全体が文法の開始記号である1つのグループの記号に還元されます。もし
われわれがCの文法を使うならば、入力全体は「定義と宣言の列」の必要があり
ます。もしそうでなければ、構文解析器が文法エラーを報告します。




File: bison-ja.info, Node: Grammar in Bison, Next: Semantic Values, Prev: Language and Grammar, Up: Concepts

形式規則からBisonの入力へ
=========================

形式文法（formal grammer）は、数学的な構成です。Bisonのために言語を定義
するためには、Bisonの書式で文法を記述した"Bison文法（Bison grammer）"ファ
イルを書く必要があります。*Note Bison Grammar Files: Grammar File。

形式文法の中での1つの非終端記号は、Bisonの入力の中で、Cの識別子のような、
1つの識別子として表現されます。`expr'、`stmt'、`declaration'のように、通
常、非終端記号は小文字で書きます。

終端記号に対するBisonの表現は、"トークン型（token type）"ともいいます。
トークン型は、C言語で使われるような識別子であるかもしれません。通常、非
終端記号からこれらを区別するために、大文字で書きます。たとえば、
`INTEGER'、`IDENTIFIER'、`IF'、`RETURN' のように書きます。言語の個々のキー
ワードを表す終端記号は、キーワードを大文字に変換してから命名するべきです。
終端記号`error'は、エラーからの回復処理のために予約されています。*Note
Symbols::。

ある終端記号は、C言語の文字定数のような、1文字リテラルを表しているかもし
れません。トークンがちょうど1文字である（たとえば、かっこ、プラス記号な
ど）ならば必ず、そのトークンに対する終端記号として、同じ文字を使うべきで
す。

終端記号を表す第3の方法は、何文字かを含むC言語の文字列定数です。詳細は
*Note Symbols::。

文法規則は、Bisonの文法の中で、もう1つの式を持ちます。たとえば、C言語の
`return'文に対するBisonの規則があります。クォート（'）で囲まれたセミコロ
ンは、文に対するC言語の文法の一部分を表す、1文字のリテラルトークンです。
クォートで囲まれていないセミコロンとコロンは、あらゆる規則の中で使われる、
Bisonの区切り文字です。

     stmt:   RETURN expr ';'
             ;

*Note Syntax of Grammar Rules: Rules。




File: bison-ja.info, Node: Semantic Values, Next: Semantic Actions, Prev: Grammar in Bison, Up: Concepts

意味値
======

形式文法は、トークンを分類法に基づいてのみ、選びます。たとえば、ある規則
が`integer constant'という終端記号について言及するならば、それは、文法的
にそこに現れてよい*任意の*整数型定数を意味します。その定数の正確な値は、
入力が解析される方法と無関係です。もし、`x+4'が文法的に正しいならば、
`x+1'も、`x+3989'も、同様に文法的に正しいのです。

しかし、いったん解析されれば、入力にとって正確な値はきわめて重要です。プ
ログラム中の定数として4と1と3989を区別できないコンパイラは、役に立ちませ
ん。そこで、Bison文法の中のそれぞれのトークンは、トークン型のほかに、"意
味値（semantic value）"を持ちます。詳細については、*Note Defining
Language Semantics: Semantics。

トークン型は、`INTEGER'、`IDENTIFIER'、`',''のように、文法の中で定義され
る終端記号です。これは、そのトークンが正しい位置に現れているか確かめ、他
のトークンとどのようにグループ化するか決めるために必要な、すべての情報を
含んでいます。文法規則は、トークンの型以外の何も知りません。

意味値は、トークンに関する、たとえば、整数の値や識別子の名前のような、トー
クン型以外のあらゆる情報を持っています（`',''のような区切り記号であるトー
クンは、意味値を持つ必要がありません）。

たとえば、ある入力されたトークンは、トークン型が`INTEGER'で、意味値が4で
あると分類されるかもしれません。別の入力されたトークンは、同じ`INTEGER'
型で、値が3989であるかもしれません。文法規則が`INTEGER'の出現を許すのな
らば、どちらのトークンも`INTEGER'型なので、受け入れられます。構文解析器
は、トークンを受け入れるときに、その意味値を記憶します。

それぞれのグループ化は、それに対応する非終端記号とともに、意味値を持てま
す。たとえば、電卓の中では、1つの式は、通常、数値である意味値を持ちます。
プログラミング言語のコンパイラの中では、1つの式は、通常、式の意味を表す
木構造の意味値を持ちます。




File: bison-ja.info, Node: Semantic Actions, Next: Bison Parser, Prev: Semantic Values, Up: Concepts

意味アクション
==============

役に立つようにするためには、プログラムは、入力を解析するだけでなく、入力
に基づくなんらかの出力を生成する必要があります。Bison文法の中では、文法
規則は、Cで書かれた"アクション（action）"を持てます。そのルールへのマッ
チを構文解析器が認識するたびに、アクションが実行されます。*Note
Actions::

多くの場合に、アクションの目的は、部品の意味値から全体の意味値を計算する
ことです。たとえば、1つの式とは2つの式の和でありうると仮定します。構文解
析器が和を認識すると、部分式それぞれは、それがどのように構成されたかを表
す意味値を持っています。アクションは、新しく認識された合成式について、同
様の意味値を構成するべきです。

以下に、1つの式が2つの部分式の和となる規則の例を示します。

     expr: expr '+' expr   { $$ = $1 + $3; }
             ;

このアクションは、2個の部分式の値から、式の和の意味値を生成する方法を示
しています。




File: bison-ja.info, Node: Bison Parser, Next: Stages, Prev: Semantic Actions, Up: Concepts

Bisonの出力――構文解析器ファイル
=================================

Bisonを使うときには、入力としてBison文法ファイルを指定します。文法で記述
された言語を解析する、Cのソースファイルが出力になります。このファイルを
"Bison構文解析器（Bison parser）"と呼びます。BisonユーティリティとBison
構文解析器は、別のプログラムであることに注意してください。Bisonユーティ
リティの出力がBison構文解析器で、あなたのプログラムの一部分になるのです。

Bison構文解析器の仕事は、文法規則に従って、トークンをグループ化すること
です。たとえば、識別子と演算子から式を組み立てます。このために、文法規則
に対応するアクションを実行します。

トークンは、"字句解析器（lexical analyzer）"と呼ばれる関数によって得られ、
その関数を（Cで書くような）なんらかの方法で与える必要があります。Bison構
文解析器は、新しいトークンを必要とするたびに、字句解析器を呼び出します。
Bison構文解析器は、トークンの「内部」がなんであるか知りません（しかし、
トークンの意味値は関係します）。一般に、字句解析器は、テキスト中の文字を
解析してトークンを得ますが、Bisonはその方法を知りません。*Note The
Lexical Analyzer Function `yylex': Lexical。

Bison構文解析器ファイルは、Cのプログラムで、`yyparse'という名前の、文法
を実装する関数を定義します。この関数は、完全なCのプログラムを構成しませ
ん。いくつかの関数を補ってやる必要があります。1つは、字句解析器です。も
う1つは、エラーを報告するために構文解析器が呼び出す、エラー報告関数です。
さらに、完全なCプログラムは`main'関数から実行を始める必要がありますので、
これを補って、そこから`yyparse'を呼び出してください。*Note Parser
C-Language Interface: Interface。

あなたが書くアクションの中でのトークンの型名と記号に関係なく、Bison構文
解析器の中で使われるすべての変数と関数の名前は、`yy'または`YY'で始まりま
す。これは、字句解析関数`yylex'とエラー報告関数`yyerror'および構文解析関
数`yyparse'のようなインターフェイス関数も含みます。また、内部で使われる
多数の識別子も同様です。したがって、本書で定義されている場合を除いて、
Bison文法ファイルの中で`yy'または`YY'で始まるCの識別子の利用は避けるべき
です。




File: bison-ja.info, Node: Stages, Next: Grammar Layout, Prev: Bison Parser, Up: Concepts

Bisonを使う手順
===============

Bisonを使って、文法の定義から実際に動くコンパイラやインタープリタを作る
までの、言語設計手順は、次のようになります。

  1. Bisonが認識できる形式で、文法を形式的に指定します（*Note Bison
     Grammar Files: Grammar File.）。言語の各文法規則に対して、その規則
     のインスタンスが認識されたときに実行されるアクションを記述します。
     アクションは、C言語の文の並びで書きます。

  2. 入力を処理し、トークンを構文解析器に渡すために、字句解析器を書きま
     す。字句解析器は、Cで手作業で書いてもかまいません（*Note The
     Lexical Analyzer Function `yylex': Lexical.）。Lexを使って生成する
     ことも可能ですが、本書ではLexの使い方については解説していません。

  3. Bisonが生成した構文解析器を呼び出す、制御関数を書きます。

  4. エラー報告関数を書きます。


このソースプログラムを実行可能なプログラムにするために、次の手順が必要で
す。

  1. 構文解析器を生成するために、Bisonを実行します。

  2. Bisonが生成したソースプログラムとその他のソースプログラムを、コンパ
     イルします。

  3. オブジェクトファイルをリンクして、最終的なプログラムを得ます。





File: bison-ja.info, Node: Grammar Layout, Prev: Stages, Up: Concepts

Bison文法の全体像
=================

Bisonユーティリティへの入力は、"Bison文法ファイル（Bison grammar file）"
です。Bison文法ファイルの一般的な書式は、次のとおりです。

     %{
     C宣言部（C DECLARATIONS）
     %}

     BISON宣言部（BISON DECLARATIONS）

     %%
     文法規則部（GRAMMAR RULES）
     %%
     追加のCプログラム部（ADDITIONAL C CODE）

Bison文法ファイル中の`%%'、`%{'、`%}'は、ファイルを節に分ける区切り記号
です。

"C宣言部"では、アクションの中で使われる型と変数を定義できます。マクロを
定義するためのプリプロセッサディレクティブや、ヘッダファイルをインクルー
ドするための`#include'命令も使用できます。

"Bison宣言部"には、終端記号、非終端記号、さらに、演算子の優先順位、さま
ざまな記号の意味値のデータ型を記述できます。

"文法規則部"では、各非終端記号をその部品から組み立てる方法を定義します。

"追加のCプログラム部"には、あなたが望むCプログラムを記述できます。よく字
句解析関数`yylex'や文法規則の中のアクションから呼ばれる関数をここに書き
ます。単純なプログラムでは、 (1) (*Note Grammar Layout-Footnotes::)ここ
に残りのプログラム全部を書きます。



File: bison-ja.info  Node: Grammar Layout-Footnotes, Up: Grammar Layout

(1) 【訳注】他のファイルに書くのではなく



File: bison-ja.info, Node: Examples, Next: Grammar File, Prev: Concepts, Up: Top

例
**

本章では、Bison文法を使って書いた例を3つ示します。逆ポーランド記法電卓、
算術（中置）記法電卓、多機能電卓です。すべてBSD UNIX 4.3上でテストしまし
た。限定的ではありますが、対話的な電卓として利用可能です。

これらの例は単純ですが、現実のプログラミング言語に対するBison文法も、書
き方は同じです。

これらの例をInfoファイルから取り出してソースファイルにコピーし、試すこと
ができます。

* Menu:

* RPN Calc::          逆ポーランド記法電卓;
                        演算子の優先順位が無い、最初の例.
* Infix Calc::        中間（代数）記法電卓.
                        演算子の優先順位が導入された.
* Simple Error Recovery::  構文エラーの後も続行する.
* Multi-function Calc::  メモリと三角関数付きの電卓.
                           意味値に複数のデータ型を使用する.
* Exercises::         多機能電卓を改善するための着想.




File: bison-ja.info, Node: RPN Calc, Next: Infix Calc, Prev: Examples, Up: Examples

逆ポーランド記法電卓
====================

最初の例は、"逆ポーランド記法（reverse polish notation）"を使う倍精度の
電卓で、演算子を後に書きます。この例は、演算子の優先順位の問題がないので、
入門には適しています。第2の例では、演算子の優先順位をどのように扱うかを
示します。

この電卓のソースファイルを`rpcalc.y'とします。Bisonの入力ファイルには、
通常`.y'という拡張子を付けます。

* Menu:

* Decls: Rpcalc Decls.  rpcalcのためのBisonとCの宣言.
* Rules: Rpcalc Rules.  rpcalcのための文法規則。説明付き.
* Lexer: Rpcalc Lexer.  字句解析器.
* Main: Rpcalc Main.    制御関数.
* Error: Rpcalc Error.  エラー報告関数.
* Gen: Rpcalc Gen.      文法ファイルでBisonを実行する.
* Comp: Rpcalc Compile. 出力コードにCコンパイラを実行する.




File: bison-ja.info, Node: Rpcalc Decls, Next: Rpcalc Rules, Prev: RPN Calc, Up: RPN Calc

`rpcalc'のための宣言
--------------------

逆ポーランド記法電卓のためのCとBisonの宣言を示します。Cと同様に`/*...*/'
はコメントです。

     /* 逆ポーランド記法電卓 */

     %{
     #define YYSTYPE double
     #include <math.h>
     %}

     %token NUM

     %% /* 文法規則とアクションが続く */

C宣言部（*Note The C Declarations Section: C Declarations.）には、2つの
プリプロセッサディレクティブがあります。

`#define'ディレクティブで、トークンとグループの意味値に対するCのデータ型
を指定するために、マクロ`YYSTYPE'を定義します（*Note Data Types of
Semantic Values: Value Type.）。Bison構文解析器は、`YYSTYPE'に定義された
型を使います。定義しないと、`int'型が使用されます。各トークンと式は、浮
動小数点数である記録値を持つので、ここでは`double'を指定します。

べき乗関数`pow'の宣言を使うために、`#include'ディレクティブを使っていま
す。

第2の部、Bison宣言は、Bisonのためにトークン型についての情報を用意します
（*Note The Bison Declarations Section: Bison Declarations.）。1文字リテ
ラルでない終端記号は、ここで宣言する必要があります（通常、1文字のリテラ
ルを宣言する必要はありません）。この例では、すべての算術演算子が1文字リ
テラルなので、数値定数に対するトークン型`NUM'だけを、終端記号として宣言
します。




File: bison-ja.info, Node: Rpcalc Rules, Next: Rpcalc Lexer, Prev: Rpcalc Decls, Up: RPN Calc

`rpcalc'のための文法規則
------------------------

逆ポーランド記法電卓のための文法規則を示します。

     input:    /* 空 */
             | input line
     ;

     line:     '\n'
             | exp '\n'  { printf ("\t%.10g\n", $1); }
     ;

     exp:      NUM             { $$ = $1;         }
             | exp exp '+'     { $$ = $1 + $2;    }
             | exp exp '-'     { $$ = $1 - $2;    }
             | exp exp '*'     { $$ = $1 * $2;    }
             | exp exp '/'     { $$ = $1 / $2;    }
           /* べき乗関数 */
             | exp exp '^'     { $$ = pow ($1, $2); }
           /* 単項のマイナス    */
             | exp 'n'         { $$ = -$1;        }
     ;
     %%

ここで定義されるrpcalc「言語」のグループは、式（`exp'）と、入力行
（`line'）と、完全な入力の写し（`input'）です。これらの非終端記号には、
「論理和」という`|'記号で区切られた、いくつかの規則があります。以下の項
で、これらの規則の意味を説明します。

言語の意味は、グループが認識されたときのアクションによって決まります。ア
クションとは、ブレースで囲まれたCのプログラムです。*Note Actions::。

これらのアクションをCで書く必要がありますが、Bisonには規則の間で意味値を
受け渡しする方法があります。それぞれのアクションで、擬似変数`$$'は、その
規則が構成しようとしているグループの意味値を示します。`$$'に値を代入する
ことが、アクションの主な仕事です。規則の部品の意味値は、`$1'、`$2'などの
名前で参照されます。

* Menu:

* Rpcalc Input::      
* Rpcalc Line::       
* Rpcalc Expr::       




File: bison-ja.info, Node: Rpcalc Input, Next: Rpcalc Line, Prev: Rpcalc Rules, Up: Rpcalc Rules

`input'の説明
.............

`input'の定義について考えます。

     input:    /* 空 */
             | input line
     ;

この定義の意味は、「完全な入力とは、空文字列であるか、あるいは、完全な入
力に入力行が続いたものである」ということです。「完全な入力」が、それ自身
を使って定義されていることに注意してください。列の中で`input'が常に左端
の記号なので、このような定義を"左再帰（left recursive）"と呼びます。
*Note Recursive Rules: Recursion。

最初の選択肢は、`:'と`|'の間に記号がないので空です。これは、（トークンを
含まない）空の入力文字列にマッチします。電卓を起動した直後に`Ctrl-d' (1)
(*Note Rpcalc Input-Footnotes::)を押しても、正しい入力と扱われるように、
この規則を入れました。通常、空に対応する選択肢を最初に置き、そこに`/* 空 
*/'と書きます。

2つめの選択肢である規則（`input line'）は、自明（空）でないすべての入力
を扱います。その意味は、「任意の数の行を読み込んだ後で、もし可能ならば、
もう1行読み込む」ということです。左再帰が、この規則を繰り返しにします。
最初の選択肢が空の入力にマッチするので、0回以上任意の回数の繰り返しにな
ります。

構文解析器関数`yyparse'は、文法エラーが発生するか、あるいは、字句解析器
がもうトークンがないと判定するまで、入力の処理を続けます。ファイルの終わ
りで起きることについては、後で考慮します。



File: bison-ja.info  Node: Rpcalc Input-Footnotes, Up: Rpcalc Input

(1) 【訳注】UNIXの標準的なコンソールの設定で、入力の終わりを示す制御文字
で、MS-DOSでは代わりに`Ctrl-z'。



File: bison-ja.info, Node: Rpcalc Line, Next: Rpcalc Expr, Prev: Rpcalc Input, Up: Rpcalc Rules

`line'の説明
............

次に、`line'の定義について考えます。

     line:     '\n'
             | exp '\n'  { printf ("\t%.10g\n", $1); }
     ;

最初の選択肢は、改行文字であるトークンです。これは、rpcalcが空行を受け入
れ、それに対応するアクションがないので、無視することを示します。第2の選
択肢は、式の後に改行が続いたものです。これが、rpcalcを有用にする選択肢で
す。問い合わせの中の`exp'が、この選択肢に現れる最初の記号なので、`exp'グ
ループの意味値は、`$1'の値です。アクションは、問い合わされた計算の結果で
ある、この値を表示します。

このアクションは、値を`$$'に代入しないので、例外的です。したがって、
`line'に対応する意味値は、初期化されず、その値は予想できなくなります。も
し、その値が使われると、この仕様はバグになりますが、われわれはこの値を使
いません。ユーザーが入力した行に対する値を表示したら、その値はもはや必要
ありません。




File: bison-ja.info, Node: Rpcalc Expr, Prev: Rpcalc Line, Up: Rpcalc Rules

`expr'の説明
............

`exp'グループは、いくつかの規則を持ち、それぞれが式の種類に対応していま
す。最初の規則は、数値そのものであるもっとも単純な式を処理します。第2の
規則は、2個の式に加算記号が続くような、加算式を処理します。第3の規則は、
減算式を処理する、といった具合です。

     exp:      NUM
             | exp exp '+'     { $$ = $1 + $2;    }
             | exp exp '-'     { $$ = $1 - $2;    }
             ...
             ;

すべての`exp'規則をまとめるために`|'を使っていますが、次のように別々に書
くことも可能です。

     exp:      NUM ;
     exp:      exp exp '+'     { $$ = $1 + $2;    } ;
     exp:      exp exp '-'     { $$ = $1 - $2;    } ;
             ...

規則のほとんどは、式の部品の値から式の値を計算するための、アクションを持っ
ています。たとえば、加算のための規則では、`$1'は式の第1の部品を、`$2'は
式の第2の部品を表します。第3の部品`'+''は、意味値には関連する情報を持ち
ませんが、もし値を持っていれば、`$3'として参照できます。`yyparse'がこの
規則を使って加算式を認識すると、式全体の値として、2個の部分式の値の和が
生成されます。*Note Actions::。

すべての規則に対してアクションを書く必要はありません。アクションを省略す
ると、Bisonは`$1'の値を`$$'に複写します。第1の規則では、`NUM'の値をその
まま複写するために、このようになっています。

ここで示したリストは、望ましい書式ですが、Bisonがこのように要求するわけ
ではありません。必要に応じて、空白、タブ、改行を置けます。次のような書き
方も可能です。

     exp   : NUM | exp exp '+' {$$ = $1 + $2; } | ...

これは、次のリストと等価です。

     exp:      NUM
             | exp exp '+'    { $$ = $1 + $2; }
             | ...

しかし、後者のほうが可読性が優れています。




File: bison-ja.info, Node: Rpcalc Lexer, Next: Rpcalc Main, Prev: Rpcalc Rules, Up: RPN Calc

`rpcalc'字句解析器
------------------

字句解析器の仕事は、低水準の構文解析で、文字または文字列をトークンに変換
します。Bison構文解析器は、字句解析器を呼び出してトークンを得ます。*Note
The Lexical Analyzer Function `yylex': Lexical。

RPN（逆ポーランド記法）電卓には、簡単な字句解析器のみが必要です。この字
句解析器は、空白とタブを読み飛ばし、数値を読み込んで`double'型の`NUM'トー
クンとして返します。数値の一部分ではないその他の文字は、独立のトークンで
す。1文字トークンのトークン符号はその文字自身であることに注意してくださ
い。

字句解析関数の戻り値は、トークン型を表す数値です。Bison規則の中でトーク
ン型を表すために使われる文字列と同じものが、その型の数値符号を表すCの式
でもあります。これには、2種類の働きがあります。もし、トークン型が文字リ
テラルならば、その数値符号は文字のASCII符号であり、数値を表すために字句
解析器の中と同じ文字リテラルを使えます。もし、トークン型が識別子ならば、
適切な番号を定義するCのマクロとして、その識別子がBisonによって定義されま
す。したがって、この例では、`NUM'は、`yylex'のために使えるマクロにもなり
ます。

トークンの意味値は、もし存在すれば、大域変数`yylval'に記憶され、Bison構
文解析器はそこを見にいきます（`yylval'のCデータ型は、文法の最初で定義さ
れる`YYSTYPE'です。*Note Declarations for `rpcalc': Rpcalc Decls.）。

ファイルの終わりに達すると、トークン型のコード0が返されます（Bisonは、正
でない任意の値を入力の終わりと認識します）。

字句解析器のプログラムの例を示します。

     /*
      * 字句解析器は、数値を読めば、double型の値をスタックに積んで
      * トークン「NUM」を返し、数値以外を読めば、その文字のアスキー符号を返す。
      * 空白とタブは読み飛ばされる。ファイルが終わると0を返す。
      */

     #include <ctype.h>

     yylex ()
     {
       int c;

       /* 空白類を読み飛ばす  */
       while ((c = getchar ()) == ' ' || c == '\t')  
         ;
       /* 数値を処理する   */
       if (c == '.' || isdigit (c))                
         {
           ungetc (c, stdin);
           scanf ("%lf", &yylval);
           return NUM;
         }
       /* ファイルの終わりを処理する  */
       if (c == EOF)                            
         return 0;
       /* 1文字を返す */
       return c;                                
     }




File: bison-ja.info, Node: Rpcalc Main, Next: Rpcalc Error, Prev: Rpcalc Lexer, Up: RPN Calc

制御関数
--------

この例の精神に則って、制御関数は、飾りのない最小限のものです。唯一必要な
ことは、構文解析の処理を始めるために、`yyparse'関数を呼び出すことです。

     main () { yyparse (); } (1) (*Note Rpcalc Main-Footnotes::)


File: bison-ja.info  Node: Rpcalc Main-Footnotes, Up: Rpcalc Main

(1) 【訳注】古いK&R-C処理系を使う場合には前述の例のままでよいのですが、
ANSI-C処理系を使う場合には、`main'関数が返す値が`int'型なので、次のよう
に書くべきです。他の関数についても同様です。本書の例のすべては古い書式で
書かれています。

     int main () { return yyparse (); }




File: bison-ja.info, Node: Rpcalc Error, Next: Rpcalc Gen, Prev: Rpcalc Main, Up: RPN Calc

エラー報告関数
--------------

`yyparse'は、構文エラーを検出すると、エラーメッセージ（必ずそうとはかぎ
りませんが、通常は`"parse error"'）を表示するために、エラー報告関数
`yyerror'を呼び出します。

     #include <stdio.h>

     yyerror (s)  /* エラーが起きるとyyparseから呼び出される */
          char *s;
     {
       printf ("%s\n", s);
     }

`yyerror'から戻った後に、Bison構文解析器は、文法に適切なエラー規則
（*Note Error Recovery::）があれば、エラーから回復し、解析を継続できます。
そうでない場合には、`yyparse'が0でない値を返します。この例では、エラー規
則を書いていないので、不正な入力はすべて電卓プログラムを終了させます。こ
れは、実際の電卓としてはきれいな動作ではありませんが、最初の例としては十
分です。




File: bison-ja.info, Node: Rpcalc Gen, Next: Rpcalc Compile, Prev: Rpcalc Error, Up: RPN Calc

構文解析器を生成するためにBisonを実行
-------------------------------------

構文解析器を生成するためにBisonを実行する前に、1つ以上のソースファイルの
すべてをどのように整えるか、決める必要があります。このような単純な例では、
すべてを1個のファイルに詰め込む方法がいちばん簡単です。`yylex'、
`yyerror'、`main'の定義を、ファイルの「追加のCコード」部の最後に置きます
（*Note The Overall Layout of a Bison Grammar: Grammar Layout.）。

大きなプロジェクトでは、ソースコードを複数のファイルに分け、まとめてリコ
ンパイルするために`make'を使うでしょう。

1つのファイルにすべてのソースが入っているならば、次のコマンドで、それを
構文解析器ファイルに変換できます。

     bison FILE_NAME.y

この例では、ファイルは`rpcalc.y'（逆ポーランド記法電卓）と呼ばれています。
Bisonは、元のファイル名から`.y'を取り除いて、`FILE_NAME.tab.c'というファ
イルを生成します。Bisonが出力したファイルには、`yyparse'のソースコードが
含まれています。入力ファイル中の追加の関数（`yylex'、`yyerror'、`main'）
は、出力にそのまま複写されます。




File: bison-ja.info, Node: Rpcalc Compile, Prev: Rpcalc Gen, Up: RPN Calc

構文解析器ファイルのコンパイル
------------------------------

構文解析器ファイルをコンパイルする方法を示します。 (1) (*Note Rpcalc
Compile-Footnotes::)

     # カレントディレクトリのファイルの一覧を見る。
     % ls
     rpcalc.tab.c  rpcalc.y

     # Bison構文解析器をコンパイルする。
     # 数学ライブラリ内の`pow'関数をリンクするために`-lm'を指定する。
     % cc rpcalc.tab.c -lm -o rpcalc

     # 再び、ファイルの一覧を見る。
     % ls
     rpcalc  rpcalc.tab.c  rpcalc.y

できた`rpcalc'ファイルは、実行可能プログラムです。`rpcalc'を実行させる例
を示します。

     % rpcalc
     4 9 +
     13
     3 7 + 3 4 5 *+-
     -13
     3 7 + 3 4 5 * + - n              単項マイナスを示す`n'に注意
     13
     5 6 / 4 n +
     -3.166666667
     3 4 ^                            べき乗関数
     81
     ^D                               入力の終わり
     %



File: bison-ja.info  Node: Rpcalc Compile-Footnotes, Up: Rpcalc Compile

(1) 【訳注】UNIX上で`cc'コマンドを使ってコンパイルする方法を示しま
す。



File: bison-ja.info, Node: Infix Calc, Next: Simple Error Recovery, Prev: RPN Calc, Up: Examples

中間記法電卓：`calc'
====================

後置記法演算子に代わって中間記法演算子を扱うようにrpcalcを変更します。中
間記法には、演算子の優先順位の概念と、適切な深さに入れ子できるかっこが必
要です。中間記法電卓を作るためのBisonソースファイル`calc.y'を示します。

     /* 中間記法電卓 -- calc */

     %{
     #define YYSTYPE double
     #include <math.h>
     %}

     /* BISON宣言 */
     %token NUM
     %left '-' '+'
     %left '*' '/'
     %left NEG     /* negation--単項マイナス */
     %right '^'    /* べき乗関数        */

     /* 文法規則が続く */
     %%
     input:    /* 空文字列 */
             | input line
     ;

     line:     '\n'
             | exp '\n'  { printf ("\t%.10g\n", $1); }
     ;

     exp:      NUM                { $$ = $1;         }
             | exp '+' exp        { $$ = $1 + $3;    }
             | exp '-' exp        { $$ = $1 - $3;    }
             | exp '*' exp        { $$ = $1 * $3;    }
             | exp '/' exp        { $$ = $1 / $3;    }
             | '-' exp  %prec NEG { $$ = -$2;        }
             | exp '^' exp        { $$ = pow ($1, $3); }
             | '(' exp ')'        { $$ = $2;         }
     ;
     %%

`yylex'、`yyerror'、`main'関数は、前の例のものと同じです。

このプログラムには、2つの重要な特徴があります。

第2の部分（Bison宣言部）では、`%left'がトークンの型とそれが左結合演算子
であると宣言します。宣言`%left'と`%right'（右結合演算子）は、結合性を持
たないトークン型名を宣言するために使われる`%token'の代わりになります（1
文字のリテラルであるトークンは、通常、宣言する必要がありません。ここでは、
結合性を宣言します）。

演算子の優先順位は、宣言が書かれる行の順序で決まります。後から宣言された
演算子ほど、高い優先順位を持ちます。したがって、べき乗の優先順位がもっと
も高く、単項の負（`NEG'）、「`*'」と「`/'」と続きます。*Note Operator
Precedence: Precedence。

もう1つの重要な特徴は、単項の負の演算子のために文法部分にある`%prec'です。
`%prec'は、単純にBisonに対して、規則`| '-' exp'は`NEG'と同じ優先順位を持
つように指示し、この例ではどちらも2番目に高い優先順位を持ちます。

以下は`calc.y'の実行例です。

     % calc
     4 + 4.5 - (34/(8*3+-3))
     6.880952381
     -56 + 2
     -54
     3 ^ 2
     9




File: bison-ja.info, Node: Simple Error Recovery, Next: Multi-function Calc, Prev: Infix Calc, Up: Examples

単純なエラー回復
================

今まで、本書では、"エラー回復（error recovery）"、つまり、構文エラーを検
出した後で構文解析を続ける方法については言及していませんでした。今までに
扱ったことは、`yyerror'を使ってエラーを報告することだけでした。`yyerror'
を呼び出した後で、特に指定しないと`yyparse'は処理を終わることを思い出し
てください。つまり、エラーを含む入力行が、電卓プログラムを終了させます。
この欠陥をどのように改善するか示しましょう。

Bison言語の文法規則には、予約語`error'があります。次の例では、`line'に対
する選択肢群に`error'を追加する方法を示します。

     line:     '\n'
             | exp '\n'   { printf ("\t%.10g\n", $1); }
             | error '\n' { yyerrok;                  }
     ;

文法へのこの追加によって、構文解析エラーが発生した場合に、簡単なエラー回
復が可能になります。評価不可能な式が読み込まれると、`line'に対する第3の
規則によってエラーが認識され、構文解析が続けられます。この場合にも、関数
`yyerror'は呼び出され、メッセージを表示します。アクションは、Bisonによっ
て自動的に定義されるマクロである`yyerrok'文を実行します。これはエラー回
復の完了を意味します（*Note Error Recovery::）。`yyerrok'と`yyerror'の違
いに注意してください。

この形式のエラー回復は、構文エラーを扱います。他の種類のエラーもあります。
たとえば、0による除算は、例外シグナルを発生し、通常は致命的です。実際の
電卓プログラムは、このシグナルをつかまえて、`longjmp'を使って`main'に戻
り、入力行の構文解析を続ける必要があります。さらに、現在の入力行の残りは
破棄されるべきです。しかし、これらの問題は、Bisonのプログラムに固有の問
題ではないので、本書では解説しません。




File: bison-ja.info, Node: Multi-function Calc, Next: Exercises, Prev: Simple Error Recovery, Up: Examples

多機能電卓：`mfcalc'
====================

Bisonの基礎についての説明が終わったので、より高度な話題に移りましょう。
前述の電卓は、5種類の機能、`+'、`-'、`*'、`/'、`^'を持っています。この電
卓に、その他の数学関数、たとえば、`sin'、`cos'などを追加するとよいでしょ
う。

中間記法電卓への新しい演算子の追加は、その演算子が1文字リテラルならば簡
単です。字句解析器`yylex'は、数値以外のすべての文字をトークンとして渡す
ので、追加の演算子に対応する文法規則を追加するだけです。しかし、次のよう
な表記方法の、より柔軟な組み込み関数が必要です。

     関数名 (引数)

さらに、電卓にメモリを追加し、名前付き変数を作り、そこに値を記憶し、後で
使えるようにしましょう。以下に多機能電卓を使う作業の例を示します。

     % mfcalc
     pi = 3.141592653589
     3.1415926536
     sin(pi)
     0.0000000000
     alpha = beta1 = 2.3
     2.3000000000
     alpha
     2.3000000000
     ln(alpha)
     0.8329091229
     exp(ln(beta1))
     2.3000000000
     %


複数の代入 (1) (*Note Multi-function Calc-Footnotes::)と関数の入れ子 (2)
(*Note Multi-function Calc-Footnotes::)が許されることに注意してください。


* Menu:

* Decl: Mfcalc Decl.      多機能電卓のためのBisonの宣言.
* Rules: Mfcalc Rules.    電卓のための文法規則.
* Symtab: Mfcalc Symtab.  記号表を管理するサブルーチン.



