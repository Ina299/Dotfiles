Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999
Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU General
Public License" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU General Public License" may be included in a translation
approved by the Free Software Foundation instead of in the original
English.





File: emacs-ja.info, Node: List Tags, Prev: Tags Search, Up: Tags

タグテーブルの照会
------------------

`M-x list-tags RET FILE RET'
     プログラムファイルFILEで定義されているタグの一覧を表示する。
`M-x tags-apropos RET REGEXP RET'
     REGEXPに一致するすべてのタグを表示する。

`M-x list-tags'は、選択されたタグテーブルに記載されているファイルのどれ
か1つのファイル名を読み取り、そのファイルで定義されているすべてのタグを
表示します。引数の『ファイル名』は、タグテーブルに記録されたファイル名と
単純に文字列として比較されます。ファイル名というよりは、文字列として読ま
れます。したがって、補完やデフォルトはありませんし、タグテーブルに格納さ
れているとおりに正確にファイル名を入力する必要があります。タグテーブル内
のファイル名にディレクトリが含まれない限り、ファイル名にもディレクトリを
含めてはいけません。

`M-x tags-appropos'は、タグに対する`apropos'にあたります （*Note
Apropos::）。このコマンドは、正規表現を読み取り、選択されたタグテーブル
の中から正規表現に一致する項目のタグをすべてみつけだし、そのタグ名を表示
します。

現在のタグテーブルに含まれるタグ名を名前空間として、バッファ内で補完を行
うこともできます。*Note Symbol Completion::。



File: emacs-ja.info, Node: Emerge, Next: C Modes, Prev: Tags, Up: Programs

emergeを用いたファイルの併合
============================

ちょっとしたミスで、1つのプログラムから2つの別の版を作ってしまうこともあ
ります。この混乱した状態を収拾するには、それらを併合する必要があります。
emergeを使うと、併合作業が容易になります。手動で比較するコマンドについて
は、*Note Comparing Files::と*Note Emerge: (ediff)Emergeを参照してくださ
い。

* Menu:

* Overview of Emerge::	How to start Emerge.  Basic concepts.
* Submodes of Emerge::	Fast mode vs. Edit mode.
			  Skip Prefers mode and Auto Advance mode.
* State of Difference::	You do the merge by specifying state A or B
			  for each difference.
* Merge Commands::	Commands for selecting a difference,
			  changing states of differences, etc.
* Exiting Emerge::	What to do when you've finished the merge.
* Combining in Emerge::	    How to keep both alternatives for a difference.
* Fine Points of Emerge::   Misc.



File: emacs-ja.info, Node: Overview of Emerge, Next: Submodes of Emerge, Up: Emerge

emergeの概要
------------

以下の4つのコマンドのいずれかでemergeを実行します。

`M-x emerge-files'
     指定した2つのファイルを併合する。

`M-x emerge-files-with-ancestor'
     共通の祖先を参照しながら、指定した2つのファイルを併合する。

`M-x emerge-buffers'
     2つのバッファを併合する。

`M-x emerge-buffers-with-ancestor'
     3番目のバッファに入っている共通の祖先を参照しながら、2つのバッファ
     を併合する。

emergeコマンドは、2つのファイル、あるいは、2つのバッファを比較して、比較
結果を3つのバッファ、つまり、各入力テキストに1つずつ（"Aバッファ"と"Bバッ
ファ"）と、併合を実施するバッファ（"併合バッファ"）に表示します。併合バッ
ファには、比較によって得られる差分だけでなく、併合したテキスト全体が表示
されます。2つの入力テキストが相違している箇所については、どちらのテキス
トを併合バッファに含めるか選択できます。

既存のバッファを入力源とするemergeコマンドでは、入力バッファがナロイング
されていると、バッファの参照可能な部分だけを使います（*Note Narrowing::）。

併合したい2つのテキストのもとである共通の祖先にあたる版を利用できるとき
には、emergeはそれを使ってどちらの選択肢が正しいのか推測します。一方の入
力と祖先との一致部分がどこかにあれば、もう一方の入力には併合結果に残すべ
き意図的な変更がなされていると推測します。共通の祖先のテキストを指定する
には、名前に`with-ancestor'の付いたコマンドを使ってください。これらのコ
マンドは、A版、B版、共通の祖先に対応する3つのファイル名かバッファ名を読
み取ります。

入力を比較してバッファの準備を終えると、つぎは対話的な併合作業が始まりま
す。併合バッファで特別な"併合コマンド"を打って併合作業を制御します。併合
バッファには、単なる差分ではなく併合したテキスト全体が表示されます。入力
テキストの各相違箇所に対して、どちら側を残すか選択したり、両者をもとにし
て編集できます。

併合バッファでは、emergeモードと呼ばれる特別なメジャーモードが使われ、こ
れらを選択するコマンドがあります。もちろん、通常のEmacsコマンドでバッファ
を編集することもできます。

emergeの注意は、いつでも"注目"相違箇所と呼ばれる相違箇所に向けられていま
す。3つのバッファ内では、注目相違点はつぎのように印が付けられます。

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

emergeはすべての相違箇所に順に番号をふります。さらに、モード行にはつねに
注目相違箇所の番号が表示されます。

通常、併合バッファはA版の内容で始まります。しかし、A版の内容が共通の祖先
の内容と一致するときには、併合バッファはB版の内容で始まります。

emergeを終えると、併合バッファにはその時点の併合済みテキストが残ります。
emerge終了時には、`C-x C-w'でファイルに保存できます。`emerge-files'や
`emerge-files-with-ancestor'に数引数を指定すると、ミニバッファで出力ファ
イル名を読み取ります。（どちらの場合でも、これがいちばん最後に聞かれるファ
イル名。）すると、emerge終了時には、併合済みのテキストがその出力ファイル
に保存されます。

emergeを終えると、通常、emergeコマンドが併合バッファをファイルに保存しま
す。emergeを`C-]'でアボートするとemergeコマンドは併合バッファを保存しま
せんが、必要ならばユーザー自身で保存できます。



File: emacs-ja.info, Node: Submodes of Emerge, Next: State of Difference, Prev: Overview of Emerge, Up: Emerge

emergeのサブモード
------------------

併合コマンドを指示するためのモードが2つ、つまり、高速モード（Fast mode）
と編集モード（Edit mode）があり、どちらかを選べます。高速モードでは、基
本的な併合コマンドは1文字で表され、通常のEmacsコマンドは禁止されています。
併合コマンドだけを使用するのであれば、高速モードが便利です。編集モードで
は、すべての併合コマンドはプレフィックス`C-c C-c'で始まり、通常のEmacsコ
マンドも使えます。このモードでは、併合バッファを編集できますが、emergeの
処理は遅くなります。

編集モードに切り替えるには`e'を使い、高速モードに切り替えるには`C-c C-c
f'を使います。モード行には、編集モードは`E'、高速モードは`F'と表示されま
す。

emergeには、特定の併合コマンドの動作に影響を与えるサブモードがさらに2つ
あります。自動前進（auto-advance）モードと優先箇所スキップ（skip-prefers）
モードです。

自動前進モードがオンであると、コマンド`a'と`b'は、自動的につぎの相違箇所
にポイントを進めます。このモードでは、どちらかの入力だけを選ぶ状況である
限り、高速に併合を行えます。モード行には`A'と表示され、自動前進モードで
あるを示します。

優先箇所スキップモードがオンであると、コマンド`n'と`p'は、A優先／B優先の
状態にある相違箇所をスキップします（*Note State of Difference::）。つま
り、どちらの版も『正しい』と推定されない相違箇所だけを調べことになります。
モード行には`S'と表示され、優先箇所スキップモードであることを示します。

自動前進モードをオン／オフするには、コマンド`s a'
（`emerge-auto-advance-mode'）を使います。優先箇所スキップモードをオン／
オフするには、コマンド`s s'（`emerge-skip-prefers-mode'）を使います。ど
ちらのコマンドも、正の数引数を指定するとオンにし、負あるいは0の数引数を
指定するとオフにし、引数を指定しないとトグル（切り替え）します。



File: emacs-ja.info, Node: State of Difference, Next: Merge Commands, Prev: Submodes of Emerge, Up: Emerge

相違箇所の状態
--------------

併合バッファ内では、相違箇所は`v'と`^'の文字だけの行に挟まれて示されます。
各相違箇所は、つぎの7つのいずれかの状態になっています。

状態A
     この相違箇所はA版の内容である。`a'コマンドは必ずこの状態にする。モー
     ド行には`A'と表示される。

状態B
     この相違箇所はB版の内容である。`b'コマンドは必ずこの状態にする。モー
     ド行には`B'と表示される。

デフォルトA
デフォルトB
     まだ決心していないので、『デフォルト』で、相違箇所は状態A（A版の内
     容）か状態B（B版の内容）である。どちらかの選択肢が『優先される』
     （下記参照）場合を除いて、相違箇所はすべてデフォルトAで始まる（つま
     り、併合バッファの内容はAバッファのコピー）。

     相違箇所を選択すると、その状態は、デフォルトAやデフォルトBから状態A
     や状態Bに遷移する。つまり、一度でも選択した相違箇所は、デフォルトA
     やデフォルトBの状態であることはなく、これらの状態はけっしてモード行
     には表示されない。

     デフォルトの状態として、コマンド`d a'はデフォルトAを選び、`d b'デフォ
     ルトBを選ぶ。これらのコマンドで選んだデフォルトの状態は、一度も選択
     してなく、かつ、どちらの版も優先されない相違箇所に適用される。併合
     作業を先頭から順に行っている場合、最後に選択した相違箇所に続く相違
     箇所群が一度も選択されていないものである。したがって、先頭から順に
     進めるのであれば、`d a'と`d b'を使い分けて、併合バッファのある部分
     ではA版をデフォルトとし、別の部分ではB版をデフォルトとすることがで
     きる。

優先A
優先B
     どちらかが"優先され"ているので、相違箇所は状態A（A版の内容）か状態B
     （B版の内容）である。つまり、明示的にはまだ選択していないが、当該箇
     所では、一方の版が共通の祖先に一致するため、他方の版のほうが正しく
     思われるのである。したがって、Aバッファが共通の祖先と一致する箇所で
     は、実際に変更されたほうが正しいものである可能性があるので、B版が優
     先される。

     これらの2つの状態は、モード行では`A*'や`B*'と表示される。

混合状態
     `x c'や`x C'コマンドの結果、相違箇所は、状態A（A版の内容）と状態B
     （B版の内容）の混合状態になっている。

     相違箇所がいったんこの状態になると、コマンド`a'や`b'に数引数を指定
     しない限り、何もしない。

     この状態は、モード行では`comb'と表示される。



File: emacs-ja.info, Node: Merge Commands, Next: Exiting Emerge, Prev: State of Difference, Up: Emerge

併合コマンド
------------

ここでは、高速モードの併合操作コマンドを示します。編集モードでは、これら
のコマンドのまえに`C-c C-c'を付けます。

`p'
     まえの相違箇所を選択する。

`n'
     つぎの相違箇所を選択する。

`a'
     この相違箇所をA版にする（状態A）。

`b'
     この相違箇所をB版にする（状態B）。

`C-u N j'
     番号Nの相違箇所を選択する。

`.'
     ポイントを含む相違箇所を選択する。このコマンドは、併合バッファ、Aバッ
     ファ、Bバッファのいずれでも使える。

`q'
     終了する。併合作業を完了。

`C-]'
     アボートする。併合作業をやめ、併合結果も保存しない。

`f'
     高速モードに移行する。（編集モードでは、実際には`C-c C-c f'コマン
     ド。）

`e'
     編集モードに移行する。

`l'
     3つのウィンドウすべてを（`C-l'のように）再表示する。

`-'
     数引数の一部を指定する。

`DIGIT'
     これも、数引数の一部を指定する。

`d a'
     併合バッファのこれ以降では、A版を選ぶ（デフォルトA）。

`d b'
     併合バッファのこれ以降では、B版を選ぶ（デフォルトB）。

`c a'
     この相違箇所のA版のテキストをキルリングにコピーする。

`c b'
     この相違箇所のB版のテキストをキルリングにコピーする。

`i a'
     この相違箇所のA版のテキストをポイント位置に挿入する。

`i b'
     この相違箇所のB版のテキストをポイント位置に挿入する。

`m'
     相違箇所の周りにポイントとマークを設定する。

`^'
     3つのウィンドウすべてを（`M-v'のように）下にスクロールする。

`v'
     3つのウィンドウすべてを（`C-v'のように）上にスクロールする。

`<'
     3つのウィンドウすべてを（`C-x <'のように）左にスクロールする。

`>'
     3つのウィンドウすべてを（`C-x >'のように）右にスクロールする。

`|'
     3つのウィンドウすべてで、水平方向のスクロール分をリセットする。

`x 1'
     併合バッファを表示しているウィンドウの高さを1行に縮小する。（フルサ
     イズに戻すには`C-u l'を使う。）

`x c'
     この相違箇所の2つの版を混合する（*Note Combining in Emerge::）。

`x f'
     emergeで作業しているファイル／バッファの名前を、ヘルプ用ウィンドウ
     に表示する。（ウィンドウをもとの状態に戻すには`C-u l'を使う。）

`x j'
     この相違箇所を、つぎの相違箇所と結合する。（`C-u x j'では、まえの相
     違箇所と結合する。）

`x s'
     この相違箇所を2つに分割する。このコマンドを使うまえに、3つのバッファ
     それぞれで、相違箇所を分割したい位置にポイントを移動しておく。

`x t'
     相違箇所の先頭や末尾にある同じ行を取り去る。このような行が現れるの
     は、A版とB版は一致しているが、共通の祖先とは一致しない場合。



File: emacs-ja.info, Node: Exiting Emerge, Next: Combining in Emerge, Prev: Merge Commands, Up: Emerge

emergeの終了
------------

`q'コマンド（`emerge-quit'）は、併合を終了し、出力ファイルを指定してあれ
ば、そこに結果を保存します。AバッファとBバッファは正しい内容に復元されま
すが、emergeがAバッファとBバッファを作成して、かつ、編集されていなければ、
それらをキルします。さらに、併合バッファでのemergeコマンドを使用禁止にし
ます。というのは、これ以降に併合コマンドを実行するとさまざまなバッファが
悪影響を受ける可能性があるからです。

`C-]'は、併合作業をアボートします。つまり、出力ファイルに書き出さずに終
ります。出力ファイルを指定していなければ、併合作業をアボートしようが終了
しようが、何の違いもありません。

他のLispプログラムからemergeコマンドが呼び出された場合、正しく終了すると
`t'、アボートしたときは`nil'が返されます。



File: emacs-ja.info, Node: Combining in Emerge, Next: Fine Points of Emerge, Prev: Exiting Emerge, Up: Emerge

2つの版の混合
-------------

相違箇所によっては、*両方*の版を残したいこともあるでしょう。そのような場
合には、`x c'を使います。すると、併合バッファはつぎのようになります。

     #ifdef NEW
     VERSION FROM A BUFFER
     #else /* not NEW */
     VERSION FROM B BUFFER
     #endif /* not NEW */

この例では、2つの版をCのプリプロセッサの条件節で分けていますが、変数
`emerge-combine-versions-template'に好みの文字列を設定すれば、このコマン
ドで使用する文字列を指定できます。この文字列内では、A版のテキストを置く
箇所には`%a'を、B版のを置く箇所には`%b'を指定します。上に示した結果を生
じるデフォルトの設定はつぎのとおりです。

     "#ifdef NEW\n%a#else /* not NEW */\n%b#endif /* not NEW */\n"



File: emacs-ja.info, Node: Fine Points of Emerge, Prev: Combining in Emerge, Up: Emerge

細かな注意点
------------

併合作業中には、AバッファやBバッファを勝手に編集してはいけません。emerge
は一時的にこれらのバッファの内容を変更しますが、最終的にはもとの状態に戻
します。

複数の併合処理を同時に進めることもできますが、別の併合処理の入力に同じバッ
ファを使用してはいけません。というのは、一時的にせよ、互いに異なる複数の
変更が1つのバッファに加えられてしまうからです。

入力ファイル全体を比較する必要があるため、emergeの開始にはしばらく時間が
かかる場合もあります。また、`diff'コマンドが完了するまで、emergeは何もで
きません。たぶん、そのうち誰かがemergeを変更して、入力ファイルが大きいと
きにはバックグラウンドで比較を行うようにするでしょう。そうすれば、emerge
がコマンドを受け付けるようになるまで、Emacsで他の作業を続けられます。

フック`emerge-startup-hook'（*Note Hooks::）が、併合処理の設定の最後に実
行されます。



File: emacs-ja.info, Node: C Modes, Next: Fortran, Prev: Emerge, Up: Programs

Cモードと関連するモード
=======================

本節では、C、C++、Objective-C、Java、CORBA IDL、Pike用の各モードで利用可
能な特別な機能について述べます。『Cモードと関連するモード』と書いたとき
には、これらのモードを意味します。

* Menu:

* Motion in C::
* Electric C::
* Hungry Delete::
* Other C Commands::
* Comments in C::



File: emacs-ja.info, Node: Motion in C, Next: Electric C, Up: C Modes

Cモードの移動コマンド
---------------------

本節では、Cモードとその関連モードでポイントを移動するコマンドについて述
べます。

`C-c C-u'
     マークをポイント位置に設定し、ポイントを含むプリプロセッサの条件節
     の先頭に後向きにポイントを戻す。数引数は反復回数として働く。負の引
     数を指定すると、条件節の末尾に前向きにポイントを移動する。後向きに
     戻る場合、`#elif'は、`#if'が続く`#else'のように扱われる。前向きに進
     む場合、`#elif'は無視される (1) (*Note Motion in C-Footnotes::)。


`C-c C-p'
     マークをポイント位置に設定し、プリプロセッサの条件節を横断して後向
     きにポイントを移動する。数引数は反復回数として働く。負の引数を指定
     すると、前向きに移動する。

`C-c C-n'
     マークをポイント位置に設定し、プリプロセッサの条件節を横断して前向
     きにポイントを移動する。数引数は反復回数として働く。負の引数を指定
     すると、後向きに移動する。

`M-a'
     もっとも内側のCの文の先頭にポイントを移動する
     （`c-beginning-of-statement'）。すでに文の先頭にポイントがある場合、
     直前の文の先頭に移動する。数引数Nを指定すると、N-1だけまえの文に移
     動する。

     ポイントが、文字列やコメントの内側、あるいは、コメントのうしろ（コ
     メントのあいだに白文字がある場合のみ）にある場合、Cの文ではなく自然
     言語の文単位で移動する。

     プログラムから呼ばれるときには、この関数は、3つの引数、つまり、反復
     回数、（これよりも後向きには戻らない）移動限界、ポイントがコメント
     の内側にある場合に自然言語の文単位の移動をするかどうか、を取るが、
     これらは省略できる。

`M-e'
     もっとも内側のCの文の末尾にポイントを移動する。`M-a'と同じだが、移
     動方向が逆（`c-end-of-statement'）。

`M-x c-backward-into-nomenclature'
     C++の命名語法の部分や単語の先頭に後向きにポイントを移動する。数引数
     Nを指定すると、N回移動する。Nが負ならば、前向きに移動する。C++の命
     名語法とは、NamingSymbolsWithMixedCaseAndNoUnderlinesのような形のシ
     ンボル名のこと（つまり、大文字で始めた単語を連結したもの）。各大文
     字が部分や単語の先頭となる。

     GNUプロジェクトでは、CやC++の識別子は、大文字小文字で区別するのでは
     なく、単語を下線で区切ることを推奨する。

`M-x c-forward-into-nomenclature'
     C++の命名語法の部分や単語の末尾に前向きにポイントを移動する。数引数
     Nを指定すると、N回移動する。


File: emacs-ja.info  Node: Motion in C-Footnotes, Up: Motion in C

(1) 【訳注】`#elif'のところで止まってしまう。



File: emacs-ja.info, Node: Electric C, Next: Hungry Delete, Prev: Motion in C, Up: C Modes

エレクトリックC文字
-------------------

Cモードとその関連モードでは、ある種の印字文字は『エレクトリック』です。
つまり、その文字自身を挿入することに加えて、現在行を字下げし直したり、改
行も挿入することさえあります。この機能は、変数`c-auto-newline'で制御され
ます。『エレクトリック』文字は、`{'、`}'、`:'、`#'、`;'、`,'、`<'、`>'、
`/'、`*'、`('、`)'です。

"自動改行"（auto-newline）機能がオン（モード行のモード名のあとに`/a'と表
示される）の場合に限り、エレクトリック文字は改行を挿入します。この機能は、
変数`c-auto-newline'で制御されます。コマンド`C-c C-a'でこの機能をオン／
オフできます。

`C-c C-a'
     自動改行機能をオン／オフする（`c-toggle-auto-state'）。数引数を指定
     した場合、正ならば自動改行機能をオンにし、負ならばオフにする。

コロン`:'はエレクトリックです。なぜなら、単独のコロンの入力の解釈として
はそれが適切だからです。しかし、C++で2つの連続するコロンを挿入する場合、
コロンのエレクトリックな動作は不便です。`C-c :'と打てば、字下げも改行の
挿入も行わずにコロンを2つ挿入できます。

`C-c :'
     行の字下げも改行の挿入もせずに、スコープ演算子を表すコロン2つをポイ
     ント位置に挿入する（`c-scope-operator'）。

エレクトリックキー`#'は、プリプロセッサ指令の始まりと思われる位置では、
行を字下げし直します。変数`c-electric-pound-behavior'の値が`(alignleft)'
のときには、このようになります。この機能をオフにするには、
`c-electric-pound-behavior'に`nil'を設定します。

変数`c-hanging-braces-alist'は、挿入された中括弧の前／後への改行の挿入を
制御します。これは、`(SYNTACTIC-SYMBOL . NL-LIST)'の形の要素から成る連想
リストです。`c-offsets-alist'に現れるほとんどの構文シンボルは、ここでも
意味を持ちます。

リストNL-LISTは、シンボル`before'か`after'のいずれか、あるいはその両方、
もしくは`nil'を含みます。中括弧が挿入されるときには、その中括弧が定義す
る構文上の文脈を`c-hanging-braces-alist'から探します。みつかれば、
NL-LISTを使って中括弧の前／後／前後のどこに改行を挿入するか決定します。
みつからなければ、デフォルトとして中括弧の前後に改行を挿入します。

変数`c-hanging-colons-alist'は、挿入されたコロンの前／後への改行の挿入を
制御します。これは、`(SYNTACTIC-SYMBOL . NL-LIST)'の形の要素から成る連想
リストです。リストNL-LISTは、シンボル`before'か`after'のいずれか、あるい
はその両方、もしくは`nil'を含みます。

コロンが挿入されるときには、そのコロンが定義する構文シンボルをこの連想リ
ストから探します。みつかれば、NL-LISTを使ってコロンの前／後のどこに改行
を挿入するか決定します。みつからなければ、改行を挿入しません。

自動改行機能がオンのときには、エレクトリック文字は自動的に改行を削除しま
す。この機能により、改行が不要だと思われるもっとも一般的な場面で改行を削
除するので、自動改行機能をユーザーにより受け入れやすくしています。Emacs
は改行を削除することが望ましいいくつかの場面を認識できますが、変数
`c-cleanup-list'を設定すれば、*どの*場面で行うか指定できます。この変数の
値はシンボルのリストです。各要素は、改行を削除してよい場面を1つ指定しま
す。以下に指定できるシンボルとその意味を示します。

`brace-catch-brace'
     `} catch (CONDITION) {'の構造全体を1行に再配置する。`catch'や
     CONDITION以外に中括弧のあいだになにもないときに`{'を打つと再配置す
     る。

`brace-else-brace'
     `} else {'の構造全体を1行に再配置する。`else'に続けて`{'を打ったと
     きに再配置するが、中括弧と`else'のあいだに空白以外の文字がない場合
     に限る。

`brace-elseif-brace'
     `} else if (...) {'の構造全体を1行に配置する。`{'を打ったときに再配
     置するが、キーワードと`if'の条件式を除いて、`}'と`{'のあいだに空白
     以外の文字がない場合に限る。

`empty-defun-braces'
     空の関数定義の中括弧、`{'と`}'を同じ行に再配置する。閉じ中括弧`}'を
     打ったときに再配置する。

`defun-close-semi'
     `struct'や同様の型宣言のあとのセミコロンを閉じ中括弧と同じ行に再配
     置する。セミコロンを打ったときに再配置する。

`list-close-comma'
     配列／合成体の初期化式の中の閉じ中括弧とそれに続くコンマを同じ行に
     再配置する。コンマを打ったときに再配置する。

`scope-operator'
     C++のスコープ演算子を表している可能性がある2つのコロンを一緒にする。
     2つめのコロンを打ったときに一緒にするが、コロンのあいだに白文字以外
     の文字がない場合に限る。



File: emacs-ja.info, Node: Hungry Delete, Next: Other C Commands, Prev: Electric C, Up: C Modes

Cの欲張りな削除機能
-------------------

"欲張りな削除"機能をオン（モード行のモード名のあとに`/h'か`/ah'で表示さ
れる）にすると、1つのDELコマンドで、直前の空白1つだけでなく、白文字すべ
てを削除します。この機能をオン／オフにするには、`C-c C-d'を使います。

`C-c C-d'
     欲張り削除機能（`c-toggle-hungry-state'）をオン／オフする。数引数を
     指定した場合、正ならば欲張り削除機能をオンにし、負ならばオフにする。

`C-c C-t'
     自動改行機能と欲張り削除機能を同時にオン／オフする 
     （`c-toggle-auto-hungry-state'）。

変数`c-hungry-delete-key'は、欲張り削除機能がオンかオフかを制御します。



File: emacs-ja.info, Node: Other C Commands, Next: Comments in C, Prev: Hungry Delete, Up: C Modes

Cモードのその他のコマンド
-------------------------

`C-M-h'
     関数定義の末尾にマークを設定し、先頭にポイントを置く
     （`c-mark-function'）。

`M-q'
     CやC++のコメントを考慮して、段落を詰め込む（`c-fill-paragraph'）。
     現在行にコメントがあったり、現在行がコメントの内側なら、コメントの
     字下げとコメント区切りを保存したまま、ポイント位置のコメントや段落
     を詰め込む。

`C-c C-e'
     リージョン内のテキストに対してCプリプロセッサを実行し、マクロ呼び出
     しを展開した結果を表示する（`c-macro-expand'）。リージョンのまえに
     あるテキストにマクロ定義があることもあるので、それらもプリプロセッ
     サに渡されるが、その部分の出力は表示しない。

     マクロを用いたCのコードをデバッグするとき、どのようにマクロが展開さ
     れるか正確に理解するのが難しいことがある。このコマンドを使えば、マ
     クロ展開のことを考える必要はない。展開結果を目にすることができる。

`C-c C-\'
     リージョン内の行末に`\'文字を挿入したり、行末の`\'の位置揃えを行う
     （`c-backslash-region'）。Cのマクロ定義を書いたり編集したあとに便利
     なコマンド。

     行末がすでに`\'で終っているなら、そのまえに置く白文字の個数を調整す
     る。そうでなければ、新たに`\'を挿入する。ただし、リージョン内の最後
     の行は特別扱いする。その行に`\'を挿入することはなく、また、`\'があ
     る場合には削除する。

`M-x cpp-highlight-buffer'
     プリプロセッサ指令の条件節に従って、テキストの一部を強調表示する。
     このコマンドは`*CPP Edit*'という名前のバッファを表示する。このバッ
     ファは、特定のプリプロセッサ条件とその内容をどのように表示するかを
     選択するグラフィックメニュー。さまざま設定を変更したあとで、
     `[A]pply these settings'をクリックする（あるいは、そのバッファへ移
     動して`a'と打つ）と、設定に応じてCモードのバッファを強調表示し直す。

`C-c C-s'
     現在のソース行に関する構文上の情報を表示する
     （`c-show-syntactic-information'）。この情報は行の字下げを指示する。



File: emacs-ja.info, Node: Comments in C, Prev: Other C Commands, Up: C Modes

Cモードのコメント
-----------------

Cモードとその関連モードでは、コメントの整形にいくつかの変数を使います。

`c-comment-only-line-offset'
     コメント開始部分だけを含んだ行に与える余分のオフセット。この変数の
     値は整数、あるいは`(NON-ANCHORED-OFFSET . ANCHORED-OFFSET)'の形のコ
     ンスセルのどちらでもかまわない。ここで、NON-ANCHORED-OFFSETは、1桁
     目以降から始まるコメントに与えるオフセット。ANCHORED-OFFSETは、0桁
     目から始まるコメントに与えるオフセット。整数値だけの場合は、`(VAL
     . 0)'と等価。

`c-comment-start-regexp'
     コメント開始の識別方法を指定するバッファにローカルな変数。

`c-hanging-comment-ender-p'
     この変数が`nil'であると、`c-fill-paragraph'は、ブロックコメントのコ
     メント終了区切りだけの行を作る。デフォルト値は`t'で、コメント終了区
     切り`*/'をコメントの最後の行の末尾に置く。

`c-hanging-comment-starter-p'
     この変数が`nil'であると、`c-fill-paragraph'は、ブロックコメントのコ
     メント開始区切りだけの行を作る。デフォルト値は`t'で、コメント開始区
     切り`/*'をコメントの最初の行の先頭に置く。



File: emacs-ja.info, Node: Fortran, Next: Asm Mode, Prev: C Modes, Up: Programs

Fortranモード
=============

Fortranモードには、Fortranの文と副プログラム向けの特別な移動コマンド、
Fortranの入れ子、行番号と継続文の約束事に従う字下げコマンドがあります。
Fortranモードには、長い行を適切なFortranの継続行に分ける専用の自動詰め込
み（fortran-auto-fill）モードがあります。

Fortranのコメントは他の言語のコメントとは異なっているので、コメントに対
する特別なコマンドもあります。Fortranのキーワードを入力するときの打鍵量
を減らせる、組み込みの略語もあります。

Fortran用のメジャーモードに切り替えるには、`M-x fortran-mode'を使います。
このコマンドは、フック`fortran-mode-hook'を実行します（*Note Hooks::）。

* Menu:

* Motion: Fortran Motion.	 Moving point by statements or subprograms.
* Indent: Fortran Indent.	 Indentation commands for Fortran.
* Comments: Fortran Comments.	 Inserting and aligning comments.
* Autofill: Fortran Autofill.	 Auto fill minor mode for Fortran.
* Columns: Fortran Columns.	 Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.	 Built-in abbrevs for Fortran keywords.
* Misc: Fortran Misc.            Other Fortran mode features.



File: emacs-ja.info, Node: Fortran Motion, Next: Fortran Indent, Up: Fortran

移動コマンド
------------

Fortran モードには、副プログラム（関数やサブルーチン）や文を単位とて移動
するための特別なコマンドがあります。また、副プログラムを囲むリージョンを
設定するコマンドもあり、副プログラムをキルしたり移動したりするのに便利で
す。


`C-M-a'
     副プログラムの先頭に移動する（`beginning-of-fortran-subprogram'）。
`C-M-e'
     副プログラムの末尾に移動する（`end-of-fortran-subprogram'）。
`C-M-h'
     副プログラムの先頭にポイントを置き、末尾にマークを設定する
     （`mark-fortran-subprogram'）。
`C-c C-n'
     現在の文かつぎの文の先頭に移動する（`fortran-next-statement'）。
`C-c C-p'
     現在の文かまえの文の先頭に移動する（`fortran-previous-statement'）。



File: emacs-ja.info, Node: Fortran Indent, Next: Fortran Comments, Prev: Fortran Motion, Up: Fortran

Fortranの字下げ
---------------

Fortranのコードでは、構文上の各種要素（行番号、コメント行指示子、継続マー
ク）は標準Fortranが要求する桁に現れるようにしなくてはいけないので、字下
げに関する特別なコマンドと機能が必要です。

* Menu:

* Commands: ForIndent Commands.  Commands for indenting Fortran.
* Contline: ForIndent Cont.      How continuation lines indent.
* Numbers:  ForIndent Num.       How line numbers auto-indent.
* Conv:     ForIndent Conv.      Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.      Variables controlling Fortran indent style.



File: emacs-ja.info, Node: ForIndent Commands, Next: ForIndent Cont, Up: Fortran Indent

Fortranの字下げコマンド
.......................

`TAB'
     現在行を字下げする（`fortran-indent-line'）。
`C-j'
     現在行を字下げしてから、字下げした新たな行を始める
     （`fortran-indent-new-line'）。
`C-M-j'
     ポイント位置で現在行を分割し、継続行を設定する。
`M-^'
     現在行と直前の行を繋げる。
`C-M-q'
     ポイントを含む副プログラムの行をすべて字下げする
     （`fortran-indent-subprogram'）。

Fortranモードでは、Fortranの行を字下げするようにTABを再定義します
（`fortran-indent-line'）。このコマンドは、行番号と継続マークを要求され
る桁位置に字下げしたうえ、それとは独立にプログラム中の入れ子に基づいて文
本体を字下げします。

キー`C-j'は`fortran-indent-new-line'を実行します。これは、現在行を字下げ
してから、新たな行を作成して字下げします。新たな行を始めるまえに、`do'ルー
プやその他のブロックを閉じる文を字下げし直すのに便利です。

キー`C-M-q'は、ポイントを含むFortranの副プログラム（関数やサブルーチン）
の行すべてを字下げするコマンド`fortran-indent-subprogram'を実行します。

キー`C-M-j'は、適切な方法でFortranの行を分割するコマンド
`fortran-split-line'を実行します。コメント行でなければ、後半部を継続行に
し、それに応じて字下げします。コメント行ならば、前後半部分とも独立したコ
メント行になります。

`M-^'は、`fortran-split-line'の逆操作を行うコマンド`fortran-join-line'を
実行します。現在行と直前の行を、Fortranコードとして適切に繋げます。



File: emacs-ja.info, Node: ForIndent Cont, Next: ForIndent Num, Prev: ForIndent Commands, Up: Fortran Indent

継続行
......

近代的なほとんどのFortranコンパイラには、継続行の記述方法が2つ用意されて
います。ある行の空白でない最初の文字が5桁目にあれば、先行する行の継続行
です。このスタイルを"固定フォーマット"と呼びます。（GNU Emacsでは、桁位
置はつねに0から数える。）変数`fortran-continuation-string'は、5桁目に置
く文字を指定します。タブ文字で始まり`0'以外の数字が続く行も継続行です。
このスタイルを"タブフォーマット"と呼びます。

Fortranモードではどちらのスタイルの継続行も利用できますが、希望するほう
を指定する必要があります。変数`indent-tabs-mode'の値で希望を指定します。
`nil'ならば固定フォーマット、`nil'以外ならばタブフォーマットになります。
モード行に文字列`Tab'があるかどうかで、現在使用しているスタイルがわかり
ます。

Fortranモードでは、テキストが慣用的なFortranの継続マーク`$'で始まる、あ
るいは、5桁目から白文字以外の文字で始まる場合には、その行を継続行として
扱います。TABで継続行を字下げすると、選択されている継続行のスタイルに変
換します。`C-M-j'でFortranの文を分割すると、継続行のスタイルに応じて新た
な行には継続マークを付けます。

継続行のスタイルは、Fortranモードでの編集に関わるその他の側面にも影響し
ます。固定フォーマットでは、文本体を置く最小桁位置は6になります。Fortran
のブロックの内側にある行を7桁目以降に字下げするときには、白文字には空白
文字を使います。一方、タブフォーマットでは、文本体を置く最小桁位置は8で、
8桁目よりまえの白文字はつねにタブ文字です。

既存のファイルに対してFortranモードに入ると、その内容から自動的に適切な
継続行のスタイルを推測しようとします。タブ文字か空白6個で始まる最初の行
でスタイルを判断します。変数`fortran-analyze-depth'で、（ファイルの先頭
から）何行分をスタイル判断に使用するか指定します。この範囲内にスタイルを
示すような行がみつからなければ、変数`fortran-tab-mode-default'がスタイル
を指定します。`nil'なら固定フォーマット、`nil'以外ならタブフォーマットで
す。



File: emacs-ja.info, Node: ForIndent Num, Next: ForIndent Conv, Prev: ForIndent Cont, Up: Fortran Indent

行番号
......

ある行の白文字以外の最初の文字が数字であれば、Fortranの字下げではそれを
行番号とみなして0桁目から4桁目のあいだに移動します。（GNU Emacsでは、桁
位置はつねに0から始まる。）

通常、4桁以下の行番号は空白1個で字下げします。変数
`fortran-line-number-indent'でこの字下げ幅を制御します。この変数の値は、
行番号の最大字下げ幅を表します。最大字下げ幅まで字下げできなくなると、行
番号の最後の桁が4桁目になるように右揃えで字下げします。この変数のデフォ
ルト値は1です。

これらの規則に従って行番号を字下げするには、行番号を挿入するだけで十分で
す。行番号の各桁が挿入されるたびに、字下げ幅を再計算します。この機能をオ
フにするには、変数`fortran-electric-line-number'に`nil'を設定します。こ
うすると、行番号の挿入はその他の文字の挿入と同様に行われます。



File: emacs-ja.info, Node: ForIndent Conv, Next: ForIndent Vars, Prev: ForIndent Num, Up: Fortran Indent

構文上の規約
............

Fortranモードでは、適切な字下げをするためのFortranプログラムの解釈を簡単
にするために、以下の規約に従っているものと仮定します。

   * 2つの入れ子になった`do'ループは、けっして`continue'文を共有しない。

   * `if'、`else'、`then'、`do'といったFortranのキーワードは、あいだに空
     白があったり、途中で行分けされない。

     一般にFortranコンパイラは文字列定数の外側にある空白を無視するが、
     Fortranモードは途中に空白が入っているキーワードを認識しない。`else
     if'や`end do'のような書き方は許されるが、2つの単語を同じ行に置いた
     場合に限る。継続行に分かれていると認識しない。

以上の規約に従っていない場合には、行を美しく字下げできないこともあります。
しかしながら、たとえ規約に従っていなくても、正しいFortranプログラムであ
れば字下げによって意味が変わることはありません。



File: emacs-ja.info, Node: ForIndent Vars, Prev: ForIndent Conv, Up: Fortran Indent

Fortranの字下げのための変数
...........................

Fortranの字下げ動作に影響する変数がいくつかあります。

`fortran-do-indent'
     `do'文の各レベルごとに追加する字下げ幅（デフォルトは3）。

`fortran-if-indent'
     `if'文の各レベルごとに追加する字下げ幅（デフォルトは3）。この値は、
     Fortran 90の`where'文の字下げにも使われる。

`fortran-structure-indent'
     `structure'、`union'、`map'の各文の各レベルごとに追加する字下げ幅
     （デフォルトは3）。

`fortran-continuation-indent'
     継続行の文本体に追加する字下げ幅（デフォルトは5）。

`fortran-check-all-num-for-matching-do'
     この変数が`nil'なら、字下げ処理では、`do'文は`continue'文で終ってい
     ると仮定する。こうすると、`continue'以外の文の字下げを計算するとき
     に、当該文が`do'文を終えるかどうか検査しなくてよいので、時間を節約
     できる。この変数が`nil'以外であれば、行番号が付いた文の字下げを計算
     するときには、当該文が`do'文を終えるかどうか検査する必要がある。デ
     フォルト値は`nil'。

`fortran-blink-matching-if'
     この変数が`t'なら、`endif'文の字下げを行うときに、対応する`if'文を
     示すために一時的にカーソルを移動する。デフォルト値は`nil'。

`fortran-minimum-statement-indent-fixed'
     固定フォーマットの継続行スタイルを採用したときの、文に対する最小字
     下げ幅。文本体の字下げ幅がこの値より小さくなることはない。デフォル
     ト値は6。

`fortran-minimum-statement-indent-tab'
     タブフォーマットの継続行スタイルを採用したときの、文に対する最小字
     下げ幅。文本体の字下げ幅がこの値より小さくなることはない。デフォル
     ト値は8。



File: emacs-ja.info, Node: Fortran Comments, Next: Fortran Autofill, Prev: Fortran Indent, Up: Fortran

Fortranのコメント
-----------------

Emacsの通常のコメント用コマンドは、コメントをコードのあとにも置けると仮
定します。Fortranでは、標準的なコメントの構文は、1つの行全体を必要としま
す。そのため、Fortranモードでは、Emacsの通常のコメント用コマンドを置き換
え、新たな変数をいくつか定義しています。

Fortranモードでは、文字`!'で始まり他のテキストのあとにも置ける非標準的な
コメントの構文も扱えます。しかし、この構文を受け付けるFortranコンパイラ
は限られるため、まえもって指定しておかない限り、Fortranモードは非標準の
コメントを使いません。このスタイルのコメントを使うには、変数
`comment-start'に`"!"'を設定します（*Note Variables::）。

`M-;'
     コメントの位置を揃えたり、新たなコメントを挿入する
     （`fortran-indent-comment'）。

`C-x ;'
     非標準の`!'コメントだけに作用する。

`C-c ;'
     リージョン内のすべての行をコメントにする。あるいは、（引数を指定す
     ると）コメントをコードに戻す（`fortran-comment-region'）。

Fortranモードの`M-;'は、コマンド`fortran-indent-comment'に再定義されてい
ます。通常の`M-;'と同じく、既存のコメントを認識して、そのテキストの桁位
置を揃えます。コメントがなければ、コメントを挿入して桁位置を揃えます。し
かし、Fortranモードのコメントの挿入と揃え方は、他のモードと同じではあり
ません。

新たにコメントを挿入する場合、現在行が空行のときは（1行全体を占める）行
コメントを挿入します。空行でないとき、非標準のコメントを使うように指定し
てあれば非標準の`!'コメントを挿入します。いずれでもないときには、現在行
のまえに行コメントを挿入します。

非標準の`!'コメントは他の言語のコメントと同じように揃えられますが、行コ
メントの場合はようすが異なります。標準の行コメントでは、コメント区切りは
つねに0桁目にある必要があります。コメント内部のテキストだけを揃えます。
`fortran-comment-indent-style'を設定して、3種類の揃え方を選べます。

`fixed'
     `fortran-comment-line-extra-indent'と文に対する最小字下げ幅を合計し
     た桁位置にテキストを揃える。デフォルトはこれ。

     文の最小字下げ幅は、固定フォーマットの継続行スタイルの場合には
     `fortran-minimum-statement-indent-fixed'の値、タブフォーマットの場
     合には`fortran-minimum-statement-indent-tab'の値。

`relative'
     コード行であるかのように揃えるが、
     `fortran-comment-line-extra-indent'だけ余計に桁をずらす。

`nil'
     行コメントのテキストを勝手に動かさない。

また、行コメントの字下げ文字を変更したければ、変数
`fortran-comment-indent-char'に好みの1文字を設定してください。

Fortranモードには、`comment-line-start'と`comment-line-start-skip'の2つ
の変数が新たに導入されています。これらは、コードのあとに置く通常のコメン
トに対する`comment-start'と`comment-start-skip'と同様の役割を、行コメン
トに対して果たします。どちらもFortranモードが適切に設定するので、変更す
る必要はありません。

Emacsの通常のコメント用コマンド`C-x ;'は、再定義されていません。このコマ
ンドは`!'コメントを扱えます。`!'コメントを使っていない場合には、このコマ
ンドはFortranモードでは役に立ちません。

コマンド`C-c ;'（`fortran-comment-region'）は、リージョン内のすべての行
の先頭に`C$$$'を挿入してコメントに変えます。数引数を指定すると、行の先頭
から`C$$$'を削除して、リージョンを生きたコードに戻します。これらのコメン
トに使う文字列は、変数`fortran-comment-region'の設定で制御できます。とこ
ろで、ここではコマンドと変数に同じ名前が使われています。LispやEmacsにお
いては、使用される文脈からコマンドと変数をつねに区別できるので、このよう
な名前の使い方が問題を起こすことはありません。



File: emacs-ja.info, Node: Fortran Autofill, Next: Fortran Columns, Prev: Fortran Comments, Up: Fortran

Fortran専用自動詰め込み（fortran-auto-fill）モード
--------------------------------------------------

Fortran専用自動詰め込み（fortran-auto-fill）モードは、挿入したFortranの
文が長くなりすぎると自動的に文を分割するマイナモードです。文を分割するに
は、`fortran-continuation-string'（*Note ForIndent Cont::）を用いて継続
行を作ります。SPC、RET、TABを打ったときや、字下げコマンドを使ったときに
分割されます。

`M-x fortran-auto-fill-mode'は、Fortran専用自動詰め込み
（fortran-auto-fill）モードがオンならばオフにし、オフならばオンにします。
このコマンドは、通常の自動詰め込み（auto-fill）モード（*Note Filling::）
である`M-x auto-fill-mode'が行うのと同じように働きます。正の数引数を指定
すると、Fortran専用自動詰め込み（fortran-auto-fill）モードをオンにし、負
であればオフにします。このモードのオン／オフは、モード行の括弧の中に
`Fill'があるかどうかで判断できます。Fortran専用自動詰め込み
（fortran-auto-fill）モードはマイナモードなので、各バッファごとに独立に
オン／オフにできます。*Note Minor Modes::。

Fortran専用自動詰め込み（fortran-auto-fill）モードは、行の長さが規定の幅
（`fill-column'の値）を越えると、空白や区切りの位置で行を分割します。
Fortran専用自動詰め込み（fortran-auto-fill）が分割する区切りは、`,'、`''、
`+'、`-'、`/'、`*'、`='、`)'です。変数`fortran-break-before-delimiters'
が`nil'の場合には、区切りのうしろで分割します。それ以外（デフォルトでも
ある）では、区切りのまえで分割します。

デフォルトではFortran専用自動詰め込み（fortran-auto-fill）モードはオフで
す。この機能を恒常的に使いたければ、`(fortran-auto-fill-mode 1)'を実行す
るフック関数を`fortran-mode-hook'に追加してください。*Note Hooks::。



File: emacs-ja.info, Node: Fortran Columns, Next: Fortran Abbrev, Prev: Fortran Autofill, Up: Fortran

桁位置の確認
------------

`C-c C-r'
     現在行の上にしばらくのあいだ『桁定規』を表示する
     （`fortran-column-ruler'）。
`C-c C-w'
     現在のウィンドウを一時的に分割して幅を72桁にする。一部のFortranコン
     パイラは1行を72文字以内に制限しているので、このコマンドを使用すれば
     1行が長くなりすぎることを防げる
     （`fortran-window-create-momentarily'）。

コマンド`C-c C-r'（`fortran-column-ruler'）は、桁定規をしばらくのあいだ、
現在行の上に表示します。桁定規は、Fortranプログラムにおいて特別な意味を
もつ桁位置を表す2行のテキストです。2行目の角括弧と中括弧で、それぞれ、行
番号と文の本体の範囲を表します。桁番号は（それらの上の）1行目に表示され
ます。

GNU Emacsでは桁番号をつねに0から数えることに注意してください。その結果、
桁定規に示される桁番号は、慣れ親しんだものより1だけ小さくなります。しか
し、それらが表す位置はFortranの標準に従ったものです。

桁定規の表示に用いるテキストは、変数`indent-tabs-mode'の値に依存します。
この変数の値が`nil'ならば、変数`fortran-column-ruler-fixed'の値を桁定規
の表示に使います。`nil'以外であれば、変数`fortran-column-ruler-tab'の内
容を表示に使います。これらの変数の内容を変更すれば、桁定規の表示を変更で
きます。

さらに桁合わせを支援するために、`C-c C-w'（`fortran-window-create'）は、
現在のウィンドウを幅が72桁になるように横位置で分割します。このウィンドウ
で編集すれば、正しいFortranのプログラムとしては長すぎる行を即座に発見で
きます。



File: emacs-ja.info, Node: Fortran Abbrev, Next: Fortran Misc, Prev: Fortran Columns, Up: Fortran

Fortranのキーワードの略語
-------------------------

Fortranモードには、一般的なキーワードや宣言に対する数多くの組み込み略語
があります。これらは、ユーザー自身が定義できる略語と同じ種類のものです。
それらを使うには、略語（abbrev）モードをオンにします。*Note Abbrevs::。

組み込み略語は他の略語と1つの点で変わっています。すべてセミコロンで始ま
ります。通常は略語にはセミコロンを使えませんが、Fortranモードでは、セミ
コロンの構文上の意味を『単語を構成する文字』に変更することで、これを可能
にしています。

たとえば、`continue'に対する組み込みFortran略語は`;c'です。略語（abbrev）
モードがオンのときに、`;c'を挿入してから空白や改行といった句読点文字を挿
入すると、`;c'は自動的に`continue'と展開されます。

組み込みFortran略語とその展開形の一覧を表示するには、`;?'あるいは`;C-h'
と打ちます。



File: emacs-ja.info, Node: Fortran Misc, Prev: Fortran Abbrev, Up: Fortran

Fortranモードのその他のコマンド
-------------------------------

`C-x n d'
     現在のFortranの副プログラムにナロイングする。

Fortranモードでは、キー`C-x n d'はコマンド`fortran-narrow-to-subprogram'
を実行するように再定義しています。このコマンドは、キーの通常の定義を
Frotran風にしたものです。バッファをポイントを含む副プログラムにナロイン
グします。



File: emacs-ja.info, Node: Asm Mode, Prev: Fortran, Up: Programs

asmモード
=========

asmモードは、アセンブリコードのファイルを編集するためのメジャーモードで
す。つぎのコマンドが定義されています。

`TAB'
     `tab-to-tab-stop'。
`C-j'
     改行を挿入し、`tab-to-tab-stop'で字下げする。
`:'
     コロンを挿入し、コロンに先行するラベルのまえの字下げを取り除く。そ
     して、`tab-to-tab-stop'を行う。
`;'
     コメントの挿入／位置揃えを行う。

変数`asm-comment-char'は、アセンブラ構文でコメントを開始する文字を指定し
ます。


File: emacs-ja.info, Node: Building, Next: Abbrevs, Prev: Programs, Up: Top

プログラムのコンパイルとテスト
******************************

前章ではプログラムの変更に便利なEmacsコマンドを説明しました。本章ではプ
ログラムの大規模な開発や保守を助けるコマンドを説明します。

* Menu:

* Compilation::         Compiling programs in languages other
                          than Lisp (C, Pascal, etc.).
* Grep Searching::      Running grep as if it were a compiler.
* Compilation Mode::    The mode for visiting compiler errors.
* Compilation Shell::   Customizing your shell properly
                          for use in the compilation buffer.
* Debuggers::	        Running symbolic debuggers for non-Lisp programs. 
* Executing Lisp::      Various modes for editing Lisp programs, 
                          with different facilities for running
                          the Lisp programs. 
* Libraries: Lisp Libraries.      Creating Lisp programs to run in Emacs.
* Interaction: Lisp Interaction.  Executing Lisp in an Emacs buffer.
* Eval: Lisp Eval.      Executing a single Lisp expression in Emacs.
* External Lisp::         Communicating through Emacs with a separate Lisp. 



File: emacs-ja.info, Node: Compilation, Next: Grep Searching, Up: Building

Emacs下でのコンパイラの実行
===========================

EmacsはCやFortranのような非対話的な言語のコンパイラを下位プロセスとして
実行でき、そのエラーログをEmacsバッファに取り込めます。また、エラーメッ
セージを解析して、コンパイルエラーを起こしたソース行を提示することもでき
ます。

`M-x compile'
     Emacs下でコンパイラを非同期に実行し、エラーメッセージを
     `*compilation*'バッファに取り込む。
`M-x grep'
     Emacs下で`grep'を非同期に実行し、一致した行を`*grep*'バッファに取り
     込む。
`M-x grep-find'
     指定した引数で`find'と`grep'を実行し、出力を`*grep*'バッファに取り
     込む。
`M-x kill-compilation'
`M-x kill-grep'
     実行中のコンパイラや`grep'のサブプロセスを停止させる。

`make'や他のコンパイルコマンドを実行するには、`M-x compile'と打ちます。
このコマンドは、ミニバッファでシェルコマンドを読み取り、そのコマンドを下
位シェルで実行し、出力結果を`*compilation*'という名のバッファに取り込み
ます。カレントバッファのデフォルトディレクトリをシェルコマンド実行時の作
業ディレクトリとして用います。そのため、通常はこのディレクトリにあるもの
をコンパイルします。

シェルコマンド行を読み取るとき、ミニバッファにはデフォルトのシェルコマン
ド行が表示されますが、これは前回`M-x compile'を使ったときのコマンドです。
単にRETだけを打鍵すると、同じシェルコマンド行を再使用します。最初の`M-x
compile'では、デフォルトは`make -k'です。デフォルトのコンパイルコマンド
は変数`compile-command'から取ります。適切なコンパイルコマンドが他にある
場合には、ファイルでこの変数のローカルな値を指定すると便利でしょう
（*Note File Variables::）。

コンパイルが始まると、バッファ`*compilation*'は別のウィンドウに表示され
ますが、選択されるわけではありません。このバッファのモード行では、括弧の
中に単語`run'か`exit'を表示してコンパイルが終了したかどうか示します。こ
のバッファを見えるようにしておく必要はありません。いずれにしても、コンパ
イルは継続されます。コンパイル中は、すべてのウィンドウのモード行に文字列
`Compiling'が表示されます。この文字列が消えれば、コンパイルは終了してい
ます。

コンパイルの進行状況を見たい場合には、`*compilation*'バッファに切り替え
てポイントをバッファの末尾に移動します。ポイントがバッファの末尾にあると、
新らたなコンパイル出力はポイントのまえに挿入されポイントは末尾に留まりま
す。ポイントがバッファの末尾にないと、コンパイル出力はバッファの末尾に追
加されますがポイントは途中の場所に留まったままです。

変数`compilation-scroll-output'に`nil'以外の値を設定すると、出力が到着す
るたびに出力に追従するようにコンパイルバッファをつねにスクロールします。

コンパイルプロセスを止めるには、`M-x kill-compilation'を実行します。コン
パイルプロセスが終了すると、`*compilation*'バッファのモード行の表示が
`run'から`signal'に変わります。一度に実行可能なコンパイルは1つだけなので、
新しくコンパイルを始めると実行中のコンパイルは停止させられます。しかし、
`M-x compile'は、実行中のコンパイルを実際に停止させるかどうか聞いてきま
す。



File: emacs-ja.info, Node: Grep Searching, Next: Compilation Mode, Prev: Compilation, Up: Building

Emacs下でのgrepによる探索
=========================

Emacsからコンパイラを実行し、コンパイルエラーを起こした行を訪れることが
できるように、`grep'を実行して一致した行を訪れることができます。これは、
`grep'が報告した一致を『エラー』として扱うことで行います。

それには、`M-x grep'と打鍵してから、`grep'をどのように実行するかを指定す
るコマンド行を入力します。普通に`grep'を実行するときに指定する引数と同じ
ものを使います。つまり、`grep'流の（普通、シェルの特殊文字をクォートする
ためにシングルクォートで囲んだ）正規表現に続けて、ワイルドカードなどを用
いたファイル名を指定します。`grep'の出力は`*grep*'バッファに入ります。ファ
イル内の対応する行を探すには、コンパイルエラーの場合と同様に、`C-x `'と
RETを使います。

`M-x grep'に前置引数を指定すると、ポイントの周りから（探すべき）タグを推
測してデフォルトの`grep'コマンドにそれを含めます。

`M-x grep-find'は`M-x grep'コマンドと同様ですが、シェルコマンドに与える
最初のデフォルトが違います。`find'と`grep'の両方を実行して、ディレクトリ
木構造下の各ファイルを探索します。*Note Dired and Find::の
`find-grep-dired'コマンドも参照してください。



File: emacs-ja.info, Node: Compilation Mode, Next: Compilation Shell, Prev: Grep Searching, Up: Building

コンパイルモード
================

`*compilation*'バッファは、コンパイル（compilation）モードと呼ばれる特別
なメジャーモードになります。このモードの主な機能は、エラーが起きたソース
行を簡単に参照できることです。

`C-x `'
     つぎのコンパイルエラーや`grep'のつぎの一致に対応する箇所を訪れる。
`RET'
     ポイントが位置するエラーメッセージに対応する箇所を訪れる。このコマ
     ンドは、コンパイルバッファで使う。
`Mouse-2'
     マウスでクリックしたエラーメッセージに対応する箇所を訪れる。

`*compilation*'でエラーメッセージにポイントを持っていってRET
（`compile-goto-error'）を打鍵すれば、そのエラーの原因となったソースを訪
問できます。あるいは、エラーメッセージを`Mouse-2'でクリックしますが、こ
のときは、あらかじめ`*compilation*'バッファに切り替えておく必要はありま
せん。

コンパイラのエラーメッセージを順番に解析するには、`C-x `'（`next-error'）
と打鍵します。`C-x'に続く文字は、シングルクォートではなくバッククォート、
すなわち、『アクサングレーブ』です。このコマンドは`*compilation*'だけで
なく、すべてのバッファで使用可能です。このコマンドは、一方のウィンドウの
先頭にエラーメッセージを表示し、別のウィンドウにエラーとなったソースコー
ドを表示します。

コンパイル開始後に最初に`C-x `'を使うと、最初のエラー箇所に移動します。
続けて`C-x `'を実行すると、次々にエラー箇所に移動していきます。RETや
`Mouse-2'で特定のエラー箇所に移動したあとに`C-x `'コマンドを実行すると、
その場所のつぎのエラー箇所に移動します。バッファの末尾に到達してもうエラー
メッセージがないと、`C-x `'コマンドは失敗し、エラーを通知します。

`C-u C-x `'は、コンパイルバッファの先頭から解析を始めます。コンパイルを
やり直さずに一連のエラーの解析をもう一度行う方法の1つです。

コンパイル（compilation）モードでは、SPCキーとDELキーを1画面分のスクロー
ルに、`M-n'と`M-p'を1つつぎ／まえのエラーメッセージへの移動に再定義しま
す。また、別のソースファイルのエラーメッセージへの移動には、`M-{'と`M-}'
コマンドを使えます。

コンパイル（compilation）モードの機能は、コンパイルマイナ
（compilation-minor）モードと呼ばれるマイナモードでも使えます。これによ
り、普通のコンパイルバッファだけでなく任意のバッファ内のエラーメッセージ
を解析できます。このマイナモードをオンにするには、`M-x
compilation-minor-mode'と打鍵します。すると、メジャーモードのコンパイル
（compilation）モードと同様にRETキーと`Mouse-2'を定義します。

バッファの内容が認識できる形式である限り、コンパイルマイナ
（compilation-minor）モードは任意のバッファで動作します。rloginバッファ
（*Note Remote Host::）では、コンパイルマイナ（compilation-minor）モード
はリモートのソースファイルをFTPで自動的に取ってきます（*Note File
Names::）。



File: emacs-ja.info, Node: Compilation Shell, Next: Debuggers, Prev: Compilation Mode, Up: Building

コンパイルのためのサブシェル
============================

Emacsはシェルを使ってコンパイルコマンドを実行しますが、非対話的なシェル
になるようなオプションを指定します。つまり、シェルはプロンプトを出さずに
実行を開始するはずです。`*compilation*'バッファに通常のシェルプロンプト
がぶざまに現れる場合は、個人のシェル初期化ファイルでプロンプトを無条件に
設定していることを意味します。（シェル初期化ファイルの名前は、`.bashrc'、
`.profile'、`.cshrc'、`.shrc'などだが、使っているシェルによってさまざま
な場合がある。）シェル初期化ファイルでは、プロンプトがすでに設定されてい
るときだけプロンプトを再設定するべきです。たとえば、`csh'では以下のよう
にします。

     if ($?prompt) set prompt = ...

bashでは以下のようにします。

     if [ "${PS1+set}" = set ]
     then PS1=...
     fi

読者のシェル初期化ファイルには、対話的なシェルに対してだけ本来は設定する
べきことがまだあるかもしれません。同じ方法を用いて、それらを状況に応じて
設定するようにできます。

MS-DOS『オペレーティングシステム』では、非同期のサブプロセスを使えません。
対応策として、MS-DOSでは`M-x compile'はコンパイルコマンドを同期的に実行
します。その結果、Emacs上で他の作業を行うには、コンパイルコマンドの終了
を待つ必要があります。*Note MS-DOS::。



File: emacs-ja.info, Node: Debuggers, Next: Executing Lisp, Prev: Compilation Shell, Up: Building

Emacs下でのデバッガの実行
=========================

GUD（Grand Unified Debugger、大統一デバッガ）ライブラリは、Emacsからさま
ざまなデバッガへのインターフェイスを提供します。フリーソフトウェアである
GDBをお勧めしますが、DBX、SDB、XDBを持っているならばそれらを使うこともで
きます。GUDは、Perlのデバッグモード、PythonのデバッガPDB、Javaデバッガ
JDBに対するインターフェイスにもなります。

* Menu:

* Starting GUD::	How to start a debugger subprocess.
* Debugger Operation::	Connection between the debugger and source buffers.
* Commands of GUD::	Key bindings for common commands.
* GUD Customization::	Defining your own commands for GUD.



File: emacs-ja.info, Node: Starting GUD, Next: Debugger Operation, Up: Debuggers

GUDの起動
---------

デバッガを開始するコマンドはいくつかあり、それぞれ、特定のデバッガに対応
しています。

`M-x gdb RET FILE RET'
     EmacsのサブプロセスとしてGDBを実行する。このコマンドは、GDBへの入出
     力用のバッファを新たに作り、そのバッファへ切り替える。GDBバッファが
     既存の場合は、そのバッファへ切り替えるだけ。

`M-x dbx RET FILE RET'
     同様に、GDBのかわりにDBXを実行する。

`M-x xdb RET FILE RET'
     同様に、GDBのかわりにXDBを実行する。ソースファイルを探索するディレ
     クトリ群を指定するには、変数`gud-xdb-directories'を使う。

`M-x sdb RET FILE RET'
     同様に、GDBのかわりにSDBを実行する。

     SDBのバージョンによっては、メッセージにソースファイル名を含めないも
     のがある。そのようなSDBを使う場合には、GUDがソースコードから関数を
     探せるように正しいタグテーブル（*Note Tags::）が必要である。タグテー
     ブルを訪問していなかったり、タグテーブルに当該関数がなかったりする
     と、`The sdb support requires a valid tag table to work'というメッ
     セージが表示される。このような場合には、作業ディレクトリに正しいタ
     グファイルを生成してからやり直す。

`M-x perldb RET FILE RET'
     PerlプログラムFILEをデバッグするためにPerlインタープリタをデバッグ
     モードで実行する。

`M-x jdb RET FILE RET'
     FILEをデバッグするためにJavaデバッガを実行する。

`M-x pdb RET FILE RET'
     FILEをデバッグするためにPythonデバッガを実行する。

これらのコマンドは引数を1つ、つまり、デバッガを起動するコマンド行を取り
ます。もっとも単純な場合は、デバッグしたい実行ファイルの名前を指定します。
デバッガに指定できるオプションを使うこともできます。しかし、シェルのワイ
ルドカードや変数名は使えません。GUDは、`-'で始まらない最初の引数をデバッ
グする実行ファイル名であると仮定します。

Emacsはデバッガプロセスを一度に1つだけ実行できます。



File: emacs-ja.info, Node: Debugger Operation, Next: Commands of GUD, Prev: Starting GUD, Up: Debuggers

デバッガの操作
--------------

GUDの下でデバッガを実行すると、デバッガは通常の入出力にEmacsバッファを使
います。このバッファをGUDバッファと呼びます。デバッガはEmacsバッファでファ
イルを訪問して、プログラムのソースファイルを表示します。このようなバッファ
の1つに矢印（`=>'）が表示され、現在実行している行を表示します。このバッ
ファでポイントを動かしても矢印は動きません。

ソースファイルを表示したバッファでは、いつでもソースファイルを編集できま
す。矢印はファイルのテキストの一部ではなく、画面上に表示されているだけで
す。ソースファイルを変更するとき、行を挿入／削除すると矢印の表示位置情報
が失われることに注意してください。GUDには、変更前のデバッガメッセージか
ら変更後の対応する行番号を知る術はありません。また、デバッガにソースの変
更を反映するには、プログラムを再コンパイルしてから再実行する必要がありま
す。

お好みならば、シェル（shell）モードの変形を用いたデバッガバッファを介し
て、デバッガプロセスを完全に制御することもできます。こうすれば、デバッガ
のすべてのコマンドを利用でき、シェル（shell）モードの履歴機能を用いてコ
マンドを繰り返し実行できます。*Note Shell Mode::。



File: emacs-ja.info, Node: Commands of GUD, Next: GUD Customization, Prev: Debugger Operation, Up: Debuggers

GUDのコマンド
-------------

GUD対話バッファはシェル（shell）モードの変形を使うので、シェル（shell）
モードのコマンドを使えます（*Note Shell Mode::）。GUDモードでは、ブレー
クポイントの設定と解除、スタックフレームの選択、プログラムのステップ実行
などのコマンドもあります。これらのコマンドはGUDバッファでもそれ以外でも
使えますが、キーバインドは異なります。

ブレークポイントコマンドは、普通、ソースファイルのバッファで使います。と
いうのは、ソース上でブレークポイントを設定／解除するのが自然だからです。
以下はブレークポイントを設定するグローバルコマンドです。

`C-x SPC'
     ポイントがあるソース行にブレークポイントを設定する。

以下はその他のGUDモード特有のコマンドです。`C-c'で始まるキー列は、GUD対
話バッファだけで使えます。`C-x C-a'で始まるキー列は、GUD対話バッファとソー
スファイル（のバッファ）の両方で使えます。

`C-c C-l'
`C-x C-a C-l'
     GUDバッファで参照した最後の行を別のウィンドウに表示する（つまり、最
     新の実行位置メッセージが指す行を表示する）。これは、コマンド
     `gud-refresh'を実行する。

`C-c C-s'
`C-x C-a C-s'
     ソースコード1行分を実行する（`gud-step'）。その行に関数呼び出しが含
     まれる場合は、呼び出された関数に入ってから停止する。

`C-c C-n'
`C-x C-a C-n'
     ソースコード1行分を実行し、関数呼び出しでも停止せずにフルスピードで
     実行する（`gud-next'）。

`C-c C-i'
`C-x C-a C-i'
     機械語1命令を実行する（`gud-stepi'）。

`C-c C-r'
`C-x C-a C-r'
     停止位置を指定せずに実行を継続する。プログラムの実行は、ブレークポ
     イントに出会う、プログラムが終了する、デバッガが監視しているシグナ
     ルを受け取るまで実行を継続する。

`C-c C-d'
`C-x C-a C-d'
     現在のソース行にブレークポイントがあるならばそれを削除する
     （`gud-remove'）。GUD対話バッファでこのコマンドを使うと、プログラム
     が最後に停止した行に適用される。

`C-c C-t'
`C-x C-a C-t'
     現在のソース行に一時的なブレークポイントを設定する。GUD対話バッファ
     でこのコマンドを使うと、プログラムが最後に停止した行に適用される。

上にあげたコマンドは、（GUDから使える）すべてのデバッガに共通です。GDBや
DBX（のあるバージョン）では、さらに以下のコマンドも使えます。

`C-c <'
`C-x C-a <'
     1つ外側のスタックフレームを選択する（`gud-up'）。これは`up'コマンド
     と等価。

`C-c >'
`C-x C-a >'
     1つ内側のスタックフレームを選択する（`gud-down'）。これは`down'コマ
     ンドと等価。

GDBを使う場合には以下のコマンドも使用できます。

`TAB'
     GDBでは、シンボル名を補完する（`gud-gdb-complete-command'）。このキー
     はGUDの対話バッファでだけ使える。また、GDBのバージョンは4.13以降で
     あること。

`C-c C-f'
`C-x C-a C-f'
     あらかじめ選択したスタックフレームから戻る（あるいは、他の理由で停
     止する）までプログラムを実行する。

これらのコマンドは、意味がある場合には数引数を反復回数として解釈します。

TABは、補完コマンドとして働くため、GDBでデバッグしているプログラムへのタ
ブの入力には使えません。タブを入力するには`C-q TAB'と打鍵します。



File: emacs-ja.info, Node: GUD Customization, Prev: Commands of GUD, Up: Debuggers

GUDのカスタマイズ
-----------------

GUDが実行を開始すると、GDBの場合は`gdb-mode-hook'、DBXの場合は
`dbx-mode-hook'、SDBの場合は`sdb-mode-hook'、XDBの場合は`xdb-mode-hook'、
Perlのデバッグモードの場合は`perldb-mode-hook'、PDBの場合は
`pdb-mode-hook'、JDBの場合は`jdb-mode-hook'のフックを実行します。これら
のフックを使って、デバッガの対話バッファ用に自前のキーバインドを定義でき
ます。*Note Hooks::。

以下は、特定のコマンド文字列をデバッガに送るコマンドを定義し、かつ、その
コマンドに対するキーバインドをデバッガの対話バッファに設定する便利な方法
です。

     (gud-def FUNCTION CMDSTRING BINDING DOCSTRING)

これは、デバッガプロセスにCMDSTRINGを送るFUNCTIONという名前のコマンドを
定義し、そのコマンドの説明文字列をDOCSTRINGとします。このように定義した
コマンドは、どのバッファでも使えます。BINDINGが`nil'以外の場合、
`gud-def'はGUDバッファのモードに対してはこのコマンドを`C-c BINDING'にバ
インドし、それ以外に対しては`C-x C-a BINDING'にバインドします。

コマンド文字列CMDSTRINGには、FUNCTIONが呼び出されたときにデータが埋め込
まれる`%'系列を含めることもできます。

`%f'
     現在のソースファイルの名前。カレントバッファがGUDバッファだった場合
     には、『現在のソースファイル』とはプログラムが停止した箇所に対応す
     るソースファイル。

`%l'
     現在のソース行番号。カレントバッファがGUDバッファだった場合には、
     『現在のソース行番号』とはプログラムが停止した箇所に対応するソース
     ファイルの行番号。

`%e'
     ポイント位置あるいはポイントに隣接するCの左辺値か関数呼び出し式。

`%a'
     ポイント位置あるいはポイントに隣接する箇所の16進数表記アドレス。

`%p'
     FUNCTIONを呼ぶときに指定された数引数を10進値表記したもの。数引数な
     しで呼ばれた場合、`%p'は空文字列。

     CMDSTRINGで`%p'を使用しなければ、定義しようとしているFUNCTIONは数引
     数を無視する。



File: emacs-ja.info, Node: Executing Lisp, Next: Lisp Libraries, Prev: Debuggers, Up: Building

Lisp式の実行
============

Emacsには、LispやSchemeのための異なったメジャーモードがいくつかあります。
これらは編集コマンドという意味では同じですが、Lisp式を実行するコマンドが
異なります。各モードには固有の目的があります。

emacs-lispモード
     このモードはEmacs Lispで実行するプログラムのソースファイル編集用。
     このモードでは、現在の関数定義を評価する`C-M-x'を定義する。*Note
     Lisp Libraries::。
lisp対話モード（Lisp Interaction mode）
     このモードはEmacs Lispの対話セッション用。ポイントの直前のS式を評価
     し、その値をバッファに挿入する`C-j'を定義する。*Note Lisp
     Interaction::。
lispモード
     このモードはEmacs Lisp以外のLispで実行するプログラムのソースコード
     編集用。このモードでは、現在の関数定義を下位のLispプロセスに送る
     `C-M-x'を定義する。*Note External Lisp::。
下位lispモード（Inferior Lisp mode）
     このモードは下位Lispプロセスとの対話セッション用。このモードは、
     lispモードとシェル（shell）モード（*Note Shell Mode::）の特別な機能
     の組み合わせ。
schemeモード
     lispモードと同様だが、Schemeプログラム編集用。
下位Schemeモード（Inferior Scheme mode）
     このモードは下位のSchemeプロセスとの対話セッション用。

Lispプログラム用の編集コマンドの大部分は事実上どこでも使えます。*Note
Programs::。



File: emacs-ja.info, Node: Lisp Libraries, Next: Lisp Interaction, Prev: Executing Lisp, Up: Building

Emacs用のLispコードのライブラリ
===============================

Emacs編集コマンドのLispコードは、習慣的に`.el'で終る名前のファイルに格納
されています。これらの拡張子は、emacs-lispモードで編集するようにEmacsに
指示します（*Note Executing Lisp::）。

Emacs Lispコードのファイルを実行するには、`M-x load-file'を使います。こ
のコマンドは、ミニバッファでファイル名を読み取り、そのファイルの内容を
Lispコードとして実行します。あらかじめファイルを訪問しておく必要はありま
せん。いずれにしても、このコマンドはディスク上のファイルを読むのであって、
Emacsバッファのテキストを読むのではありません。

LispコードのファイルをEmacs Lispライブラリのディレクトリに置いておけば、
そのファイルは`M-x load-library'でロードできます。プログラムからは、
`load-library'を呼んでロードするか、あるいは、より基本的な類似の関数で余
分な引数も指定できる`load'でロードします。

`M-x load-library'が`M-x load-file'と異なる点は、一連のディレクトリにつ
いて3つのファイル名を順に調べるということです。引数がLIBだとすると、3つ
のファイル名とは、`LIB.elc'、`LIB.el'、そして最後に`LIB'です。`LIB.elc'
というファイルが存在すれば、これは習慣として`LIB.el'をコンパイルしたもの
です。コンパイル済みのファイルはロードと実行が速いので、こちらをロードす
るほうが有利です。

`load-library'が`LIB.elc'よりも新しい`LIB.el'をみつけると、警告を出力し
ます。というのは、`.el'ファイルを変更後に再コンパイルし忘れている可能性
があるからです。

`load-library'の引数は、通常、それ自体では正しいファイル名でないことが多
いため、ファイル名の補完はできません。もちろん、このコマンドを使うとき、
指定すべき正確なファイル名を普通は知らないでしょうが。

`M-x load-library'が探索するディレクトリの順番は、変数`load-path'で指定
します。その値は、ディレクトリ名の文字列から成るリストです。リストのデフォ
ルト値には、Emacs自身のLispコードを収めたディレクトリが含まれます。個人
用のLispライブラリがあるならば、それらを1つのディレクトリにまとめ、その
ディレクトリ名を`load-path'に追加してください。リスト内の`nil'はカレント
デフォルトディレクトリを表しますが、リストに`nil'を加えることはあまり勧
められません。リストに`nil'が本当に必要だと感じたときには、それについて
は`M-x load-file'を実行するのではいけないだろうかと考えてみてください。

ライブラリの中で定義されているコマンドに対しては、そのライブラリを"自動
的にロード"（autoload）するように設定されているので、ほとんどの場合、ラ
イブラリをロードするコマンドを指定する必要はないでしょう。ライブラリをロー
ドするために`load'を呼び出すようなコマンドを1つ試してみてください。こう
すると、「自動的にロードする」という定義がライブラリ内の実際の定義で置き
換わります。

Emacs Lispコードはバイトコードにコンパイルできます。コンパイルすると、ロー
ドが速くなり、ロードしても必要な記憶容量が少なくなり、実行も速くなります。
*Note バイトコンパイル: (elisp)Byte Compilation。習慣として、ライブラリ
のコンパイル済みのコードは、ライブラリのソースファイル名に`c'を付けた名
前の別のファイルに入ります。したがって、`foo.el'のコンパイル済みのコード
は、`foo.elc'に入ります。これが、`load-library'はまず`.elc'というファイ
ルを探す理由です。



File: emacs-ja.info, Node: Lisp Eval, Next: External Lisp, Prev: Lisp Interaction, Up: Building

Emacs Lisp式の評価
==================

Emacs内で動かすつもりのLispプログラムは、emacs-lispモードで編集しましょ
う。ファイル名が`.el'で終っているファイルを編集すると、自動的にこのモー
ドになります。一方、lispモードは、他のLispシステム向けのLispプログラムを
編集するためのモードです。陽にemacs-lispモードに移るには、コマンド`M-x
emacs-lisp-mode'を使います。

Emacs内で動くプログラムのテストには、Emacsバッファにあるプログラムの一部
を評価すると便利です。たとえば、Lispの関数定義のテキストを変更してからそ
の定義を評価すると、それ以降にその関数を呼び出すと使われるようにインストー
ルされます。Lisp式を評価すると非対話的な（コマンドではない）関数を起動で
きるので、どんな種類の編集作業にも便利です。

`M-:'
     ミニバッファで1つのLisp式を読み取り、それを評価し、その値をエコー領
     域に表示する（`eval-expression'）。
`C-x C-e'
     ポイントの直前のLisp式を評価し、その値をエコー領域に表示する
     （`eval-last-sexp'）。
`C-M-x'
     ポイントを含むか直後にある関数定義（defun）を評価し、その値をエコー
     領域に表示する（`eval-defun'）。
`M-x eval-region'
     リージョン内のすべてのLisp式を評価する。
`M-x eval-current-buffer'
     バッファ内のすべてのLisp式を評価する。

`M-:'（`eval-expression'）は、Lisp式を対話的に評価するもっとも基本的なコ
マンドです。これは、ミニバッファで式を1つ読み取りますから、バッファの内
容に関係なくバッファ内でどんな式でも実行できます。式が評価されたあとは、
`M-:'を打鍵したときのカレントバッファが、ふたたびカレントバッファになり
ます。

emacs-lispモードでは、キー`C-M-x'はコマンド`eval-defun'にバインドされて
います。このコマンドはポイントを含むか直後にある関数定義をLisp式として解
析し評価します。その値はエコー領域に表示されます。このコマンドは、関数定
義のテキストの変更をLisp環境に反映するのに便利です。

`C-M-x'は`defvar'式を特別扱いします。通常、変数にすでに値が定義されてい
る場合には、`defvar'式を評価しても何もしません。しかし、`C-M-x'は、
`defvar'式で指定されている初期値に変数の値を戻します。この特別な機能は、
Lispプログラムをデバッグするときに便利です。

コマンド`C-x C-e'（`eval-last-sexp'）は、ポイントのまえにあるLisp式を評
価しその値をエコー領域に表示します。このコマンドはemacs-lispモードだけで
なく、すべてのメジャーモードで使えます。このコマンドは、`defvar'を特別扱
いしません。

`C-M-x'、`C-x C-e'、`M-:'に数引数を指定すると、値をエコー領域に表示する
かわりにカレントバッファのポイント位置に挿入します。引数の値は関係ありま
せん。

バッファでLisp式を評価するもっとも一般的なコマンドは`eval-region'です。
`M-x eval-region'は、リージョン内の1つ以上のLisp式を解析して、それらを1
つずつ順に評価します。`M-x eval-current-buffer'も同様ですが、バッファ全
体を評価します。これは、テスト準備が整ったLispコードのファイルの内容を取
り込むうまい方法です。個々の関数のバグを発見して修正したら、変更した関数
それぞれに`C-M-x'を使います。これによって、Lispの環境とソースファイルが
一致します。



File: emacs-ja.info, Node: Lisp Interaction, Next: Lisp Eval, Prev: Lisp Libraries, Up: Building

lisp対話バッファ
================

Emacsが動き始めたときに選択されるバッファ`*scratch*'は、Emacs内でLisp式
を対話的に評価するためのものです。

`*scratch*'バッファを使うもっとも簡単な方法は、Lisp式を挿入してから各式
の末尾で`C-j'と打つことです。このコマンドは、ポイントの直前のLisp式を読
み取り、それを評価し、その値を表示形式でポイントのまえに挿入します。この
結果は、評価した式とその値の完全なtypescript (1) (*Note Lisp
Interaction-Footnotes::)です。

`*scratch*'バッファのメジャーモードはlisp対話（lisp interaction）モード
であり、`C-j'のバインディングを除けばemacs-lispモードと同じです。

この機能が存在する理由を説明しましょう。Emacsが実行を開始すると何かしら
バッファが必要です。しかし、ファイルを訪問するたびに新たにバッファが作ら
れるので、このバッファはファイルを編集するのには適しません。最初のバッファ
をLispインタープリタのtypescriptにするというのが作者が考えついたもっとも
よい方法でした。`M-x lisp-interaction-mode'と打つと、カレントバッファは
lisp対話（lisp interaction）モードになります。

Emacs Lisp式を対話的に評価する別の方法は、下位emacs-lispモードを使うこと
です。このモードは、シェル（shell）モード（*Note Shell Mode::）に似たイ
ンターフェイスでEmacs Lisp式を評価できます。`M-x ielm'と打てば、下位
emacs-lispモードを使う`*ielm*'バッファが作られます。


File: emacs-ja.info  Node: Lisp Interaction-Footnotes, Up: Lisp Interaction

(1) 【訳注】入力と出力をすべて記録した対話記録



File: emacs-ja.info, Node: External Lisp, Prev: Lisp Eval, Up: Building

外部Lispの実行
==============

Emacsには他のLispシステム上でプログラムを実行する機能があります。Lispプ
ロセスをEmacsの下位プロセスとして実行し、それに式を渡して評価させること
ができます。また、Lispプログラムを編集するEmacsバッファの中で変更した関
数定義をそのまま下位のLispプロセスに渡すこともできます。

下位のLispプロセスを実行するには、`M-x run-lisp'と打ちます。このコマンド
は、シェルコマンドとして`lisp'と入力するのと同じ`lisp'という名前のプログ
ラムを実行し、プログラムの入出力は`*lisp*'という名前のEmacsバッファを介
してやりとりされます。つまり、Lispからの『端末出力』はバッファに入りポイ
ントを進め、Lispへの『端末入力』はバッファのテキストから取られます。（実
行したいLisp実行ファイルの名前を変えるには、変数`inferior-lisp-program'
を設定する。）

Lispに入力を与えるには、バッファの末尾に移動してから入力を打鍵し、最後に
RETを打ちます。`*lisp*'バッファは下位lisp（inferior lisp）モードになって
いて、シェル（shell）モード（*Note Shell Mode::）のほとんどの機能にlisp
モードの特別な特性を組み合わせています。サブプロセスに1行を送るというRET
の定義は、シェル（shell）モードの機能の1つです。

外部Lispで実行するプログラムのソースファイルにはlispモードを使います。こ
のモードは`M-x lisp-mode'で選択できます。また、ほとんどのLispシステムで
使われる`.l' (1) (*Note External Lisp-Footnotes::) や`.lsp'や`.lisp'で終
る名前のファイルにはこのモードが自動的に使われます。


実行中のLispプログラムの関数を編集しているとき、変更した定義を下位のLisp
プロセスに送るもっとも簡単な方法はキー`C-M-x'です。lispモードでは、この
キーは関数`lisp-eval-defun'を実行します。この関数は、ポイントの周りや直
後の関数定義を探し、それをLispプロセスの入力へ送ります。（Emacsはカレン
トバッファが何であるかに関わりなく、どんな下位プロセスにも入力を送ること
ができる。）

`C-M-x'コマンドの（任意のLispシステムで実行するプログラムの編集用）lisp
モードでの意味と（Emacsで実行するLispプログラムの編集用）emacs-lispモー
ドでの意味を比較してみましょう。どちらのモードでもポイントを含む関数定義
をインストールしますが、関連するLisp環境がどこにあるかに応じて、その方法
は異なります。*Note Executing Lisp::。


File: emacs-ja.info  Node: External Lisp-Footnotes, Up: External Lisp

(1) 【訳注】この拡張子はlexやflexのソースファイルにも使われる。


File: emacs-ja.info, Node: Abbrevs, Next: Picture, Prev: Building, Up: Top

略語の利用法
************

定義済みの略語（abbrev）とは、挿入時に別のテキストに展開される単語のこと
です。略語を定義するときに、それをどう展開するか指定します。たとえば、
`foo'を略語として、`find outer otter'に展開すると定義したとします。する
と、`f o o SPC'と打鍵すればバッファには`find outer otter ' (1) (*Note
Abbrevs-Footnotes::) が挿入されます。

略語の別な形に、"動的略語展開"（dynamic abbrev expansion）があります。動
的略語展開とは、バッファ中のポイントのまえにある文字列をバッファ内にある
その文字列で始まる既存の単語に展開することで、陽にコマンドを実行して行い
ます。*Note Dynamic Abbrevs::。

* Menu:

* Abbrev Concepts::   Fundamentals of defined abbrevs.
* Defining Abbrevs::  Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs:: Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::   Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::    Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::   Abbreviations for words already in the buffer.
* Dabbrev Customization:: What is a word, for dynamic abbrevs.  Case handling.


File: emacs-ja.info  Node: Abbrevs-Footnotes, Up: Abbrevs

(1) 【訳注】展開を引き起こしたSPCも挿入されることに注意。



File: emacs-ja.info, Node: Abbrev Concepts, Next: Defining Abbrevs, Up: Abbrevs

略語の考え方
============

略語とは、あらかじめどう"展開"するか定義された単語のことです。略語に続け
て、空白、タブ、ピリオドなどの単語の区切り文字を入力すると、略語は展開さ
れて展開形に置き換わります。たとえば、略語`foo'を展開形`find outer
otter'に展開するように定義しておけば、`f o o .'と打鍵すると`find outer
otter.'をバッファに挿入できます。

略語は、略語（abbrev）モード（マイナモード）がオンのときにだけ展開されま
す。略語（abbrev）モードをオフにしても定義した略語が消えてしまうわけでは
なく、つぎにオンにしたときに同じ定義をふたたび使えます。コマンド`M-x
abbrev-mode'でこのモードのオン／オフをトグル（切り替えが）できます。また、
数引数を指定した場合、引数が正のときには略語（abbrev）モードはオンになり、
それ以外のときにはオフになります。*Note Minor Modes::。`abbrev-mode'は変
数でもあります。この変数が`nil'以外のときには略語（abbrev）モードはオン
です。この変数に値を設定すると、自動的にカレントバッファにローカルな変数
になります。

略語定義は"モードに固有"にできます。つまり、あるメジャーモードのときにだ
け働くように定義できます。略語は"グローバル"にも定義でき、そのときはすべ
てのメジャーモードで使えます。同じ略語に、グローバルな定義と、さまざまな
メジャーモードに固有な定義とを持たせることができます。あるメジャーモード
に固有な定義は、グローバルな定義に優先します。

略語は、編集作業中に対話的に定義できます。略語の定義一覧を、あとで使うた
めにファイルに保存することもできます。大量の略語定義をセッションごとにロー
ドする人もいます。



File: emacs-ja.info, Node: Defining Abbrevs, Next: Expanding Abbrevs, Prev: Abbrev Concepts, Up: Abbrevs

略語の定義方法
==============

`C-x a g'
     ポイントのまえの単語を展開形として、略語を定義する。
     （`add-global-abbrev'）。
`C-x a l'
     上と同様。ただし、現在のメジャーモードに固有な略語を定義する。
     （`add-mode-abbrev'）。
`C-x a i g'
     バッファ中の1単語を略語として定義する。
     （`inverse-add-global-abbrev'）。
`C-x a i l'
     バッファ中の1単語をモードに固有な略語として定義する。
     （`inverse-add-mode-abbrev'）。
`M-x kill-all-abbrevs'
     このコマンドは現在有効なすべての略語定義を抹消し空にする。

略語を定義する普通の方法は、まず、略語に置き換わってほしい展開形のテキス
トを入力し、つぎにその直後にポイントをもっていき、`C-x a g'
（`add-global-abbrev'）と打鍵します。すると、ミニバッファを用いて略語を
読み取り、ポイントの直前の単語（群）に対する略語として登録します。展開形
として用いる単語の個数は、数引数で指定します。たとえば、略語`foo'をまえ
のように定義するには、テキスト`find outer otter'を挿入し、続いて`C-u 3
C-x a g f o o RET'と打鍵します。

`C-x a g'に数引数として0を指定すると、展開形はリージョンの内容になります。

コマンド`C-x a l'（`add-mode-abbrev'）も同様ですが、特定のモードに固有な
定義になります。モードに固有な略語は、特定のメジャーモードの中だけで有効
です。`C-x a l'は、`C-x a l'と打鍵したときのメジャーモードに対する略語を
定義します。引数の意味は`C-x a g'と同じです。

すでにバッファ内にあるテキストを略語として使いたい場合には、`C-x a g'の
かわりにコマンド`C-x a i g' （`inverse-add-global-abbrev'）、あるいは、
`C-x a l'のかわりにコマンド`C-x a i l' （`inverse-add-mode-abbrev'）を使
います。これらは『逆さ』（inverse）コマンドと呼ばれます。というのは、こ
れらのコマンドで使う（バッファにあるものとミニバッファから読むものの）2
つの文字列の用途が逆さだからです。

略語の定義を変更するには、単に新たに定義してください。略語がすでに定義さ
れていると、略語定義コマンドは置き換えてよいかどうかを確認してきます。

略語の定義を削除するには、略語定義コマンドに負の数引数を指定します。`C-u
- C-x a g'や`C-u - C-x a l'のようにします。前者はグローバルな定義を、後
者はモードに固有な定義を削除します。

`M-x kill-all-abbrevs' は、グローバルとローカルのすべての略語定義を削除
します。



