Info file: standards-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `standards-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


START-INFO-DIR-ENTRY
* Standards: (standards-ja).     GNUコーディング・スタンダード
END-INFO-DIR-ENTRY



GNU Coding Standards Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997,
1998 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.


Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.




File: standards-ja.info, Node: Top, Next: Preface, Prev: (dir), Up: (dir)

Version
*******

Last updated November 18, 1998.

* Menu:

* Preface::                     GNUコーディング・スタンダードについて
* Legal Issues::                フリーソフトウェアを自由に保つ
* Design Advice::               一般的なプログラムのデザイン
* Program Behavior::            全てのプログラムの振る舞い
* Writing C::                   Cの一番良い使い方
* Documentation::               プログラムの文書化
* Managing Releases::           リリースの過程



File: standards-ja.info, Node: Preface, Next: Legal Issues, Prev: Top, Up: Top

GNUコーディング・スタンダードについて
*************************************

GNUコーディング・スタンダードはRichard Stallmanと他のGNU Projectのボラン
ティア達によって書かれた。彼らの目的はGNUシステムをきれいで、一貫性のあ
る、インストールの容易なシステムにすることである。この文書は、移植性に優
れ、頑丈で、信頼性あるプログラムを書くためのガイドとして読むこともできる。
Cで書かれたプログラムに焦点を当てるが、規則や原理の多くは他のプログラミ
ング言語の場合でも有効である。規則は、ある方法で書く理由をしばしば記述し
てある。

この文書に対する訂正や助言はgnu@gnu.orgに送ってほしい (1) (*Note
Preface-Footnotes::)。 助言をする場合、そのための新たな用語を入れていた
だきたい。我々の時間は限られているからだ。我々は`standards.texi'か
`make-stds.texi'ファイルに対する、context diffを好むが、もしそれらのファ
イルを持っていないなら、いずれにせよメールしてほしい。

GNUコーディング・スタンダードのこのリリースは、最近ではNovember 18, 1998
に更新された。


File: standards-ja.info  Node: Preface-Footnotes, Up: Preface

(1) 訳注: この日本語訳は奥地秀則が行っている。日本語訳に対する訂正や助言
はokuji@kuicr.kyoto-u.ac.jpに送ってほしい。



File: standards-ja.info, Node: Legal Issues, Next: Design Advice, Prev: Preface, Up: Top

フリーソフトウェアを自由に保つ
******************************

この 節では、GNUソフトウェアを邪魔されないように保つための方法について議
論している。

* Menu:

* Reading Non-Free Code::       独占的プログラムの参照
* Contributions::               貢献の受け取り



File: standards-ja.info, Node: Reading Non-Free Code, Next: Contributions, Prev: Legal Issues, Up: Legal Issues

独占的プログラムの参照
======================

どんなところでも、GNUに関する作業のためや、作業中に、Unixのソースコード
を参照してはいけない！ (他の独占的プログラムについても。)

もしUnixプログラムの内部の曖昧な記憶を持っているなら、このことは、そのイ
ミテーションを書くことができない、とは言っていないが、そのイミテーション
を内部的に違った行で構成するようにしなさい。なぜなら、こうすることで、
Unixバージョンの細部とあなたの結果とを、無関係で似ていないものにする傾向
があるからだ。

例えば、Unixユーティリティは普通、メモリ使用量を最小化するように最適化さ
れている。もしあなたが代わりにスピードを追い求めれば、あなたのプログラム
はかなり異なるものになるだろう。stdioを使わずに、入力ファイル全体をコア
に置き、それを検査してよい。Unixプログラムより最近に見付かった、より賢い
アルゴリズムを使いなさい。一時ファイルの利用を省きなさい。二度やらず一回
のパスでやりなさい (我々はこれをアセンブラで行った)。

あるいは、逆に、スピードではなく単純さを強めなさい。アプリケーションによっ
ては、今日のコンピュータのスピードでは、より単純なアルゴリズムが適切であ
る。

あるいは一般性を求めなさい。例えば、Unixプログラムはよく静的なテーブルや
固定長の文字列を使っているが、それは制限を課していることになる。代わりに
動的な確保を行いなさい。あなたのプログラムを入力ファイルのNULや他の変な
文字を扱えるようにしなさい。拡張性のためにプログラミング言語を加え、その
言語でプログラムの一部を記述しなさい。

あるいは、プログラムのいくらかを独立して利用できるライブラリにしなさい。
あるいは、いつメモリを解放するか正確にトラッキングせずに、簡単なガーベー
ジ・コレクタを使うか、obstacksのような新しいGNUの機能を利用しなさい。




File: standards-ja.info, Node: Contributions, Prev: Reading Non-Free Code, Up: Legal Issues

貢献の受け取り
==============

もしあなたが作業しているプログラムが、Free Software Foundationによる著作
権を持っているなら、誰か他の人がそのプログラムに加えるコードを送ってきた
とき、我々はそれを使うのに法的な文書を必要とする。ちょうど、我々が初めに
あなたに文書に署名するよう頼むときのように。プログラムに明解でない寄与を
する人は、我々がそのプログラムにはっきりした所有権を付けるために、*誰で
もみな*何らかの類いの法的な文書に署名しなければならない。中心となった作
者だけでは十分ではないのだ。

だから、他の人からの貢献を加える前に、我々に訊いてほしい。そうすると、我々
はその文書を手に入れられるよう計らうことができる。そして、その貢献を実際
に使う前に、署名された文書を受け取ったことをあなたに伝えるまで待ちなさい。

これはプログラムをリリースする前と後の両方に当てはまる。もしバグを潰すた
めの差分を受け取り、それが顕著な変更を行うなら、我々はその変更のための法
的な文書を必要とする。

これはコメントや解説ファイルにも当てはまる。著作権法のため、コメントとコー
ドは単なるテキストである。著作権はあらゆる種類のテキストに適用されるので、
我々は全ての種類に対して法的な文書を必要とする。

法的な文書を請求するのが面倒だということは知っている。それは我々にとって
も面倒なことなのだ。しかし、もしあなたが待たなければ、不利な立場に向かっ
ていることになる。例えば、その貢献者が雇った人間が著作権放棄の文書に署名
したがらなかったとしたら？あなたはそのコードを再び取り除かなくてはならな
いかもしれない！

あちこちの数行の変更には対しては、文書を必要としない。それらは著作権の目
的からは重要でないからだ。また、もし受け取った提案が発想であって、使用す
る本当のコードでないなら、文書を必要としない。例えば、誰かがある実装を送っ
たが、あなたが同じ発想の異なる実装を書いたなら、文書を受け取る必要はない。

まさしく最悪なのは、他の貢献者を我々に伝えるのを忘れた場合だ。我々は、結
果として、いつか法廷で非常に決まり悪い思いをするかもしれない。

我々はプログラムの管理者にもっと詳細な情報を持っている。もし、GNUのため
のプログラムを(リリースされているかどうかに拘らず)実際に管理する段階に達
したら、コピーを請求していただきたい。



File: standards-ja.info, Node: Design Advice, Next: Program Behavior, Prev: Legal Issues, Up: Top

一般的なプログラムのデザイン
****************************

この 節では、プログラムを設計するときに気を付けるべき話題をいくつか議論
する。

* Menu:

* Compatibility::               他の実装との互換性
* Using Extensions::            標準的でない機能の使用
* ANSI C::                      ANSI Cの機能の使用
* Source Language::             C以外の言語の使用



File: standards-ja.info, Node: Compatibility, Next: Using Extensions, Prev: Design Advice, Up: Design Advice

他の実装との互換性
==================

ときには例外もあるが、GNU用のユーティリティプログラムやライブラリは、バー
クレーUnixの上位互換であるべきで、ANSI Cがその振る舞いを規定しているなら、
ANSI Cの上位互換に、POSIXがその振る舞いを規定していれば、POSIXの上位互換
であるべきだ。

もしこれらの標準が矛盾していたら、それぞれに対し互換モードを提供すると便
利だ。

ANSI CやPOSIXはたくさんの拡張を禁じている。拡張をどんな風に行っても構わ
ない、そうして、それを使わないための、`--ansi'とか`--posix'とか
`--compatible'オプションを含めなさい。しかしながら、その拡張が実際のプロ
グラムやスクリプトをおかしくする、十分な可能性があるなら、それは本当のと
ころ上位互換ではない。そのインターフェースを再設計してみなさい。

多くのGNUプログラムは、環境変数`POSIXLY_CORRECT'が定義されていると(例え、
それは空の値と定義されていても)、POSIXと抵触する拡張を行わない。適切であ
れば、あなたのプログラムをこの変数を認識するようにしてください。

ある機能が(プログラムやコマンド・ファイルではなく)ユーザだけに使われ、か
つ、それがUnixでは貧弱なものなら、それをまるで違った、もっと良いものに完
全に置き換えてしまってよい。(例えば、`vi'はEmacsと置き換えられている。) 
しかし互換機能も提供するのが良い。(フリーな`vi'クローンがあるので、我々
はそれを提供する。)

バークレーUnixにはない、便利な機能の追加は歓迎である。



File: standards-ja.info, Node: Using Extensions, Next: ANSI C, Prev: Compatibility, Up: Design Advice

標準的でない機能の使用
======================

すでに存在する、たくさんのGNUの機能は、相当するUnixの機能以上の便利な拡
張を数多くサポートしている。あなたのプログラムを実装する中でそれらの拡張
を使用するかどうかは難しい問題だ。

一方、その拡張を使用することで、より美しいプログラムを作ることができる。
他方、他のGNUツールが手に入らなかったら、人々はそのプログラムを構築でき
ないだろう。このために、そのプログラムはより少ないマシンでしか動かなくな
るだろう。

いくつかの拡張によって、代わりのものも提供するのが容易であるかもしれない。
例えば、"キーワード" `INLINE'を定義し、コンパイラによって、`inline'か中
身のないマクロに展開させることができる。

一般的に言って、おそらく、拡張を使わずに平易に書けるならそれらを使わない
のが最善で、大きく改善されるなら拡張を使うのが最善だ。

この規則の例外は、非常にたくさんのシステムで走る、(Emacsのような)大きく
て完成されているプログラムだ。そのようなプログラムでは、GNUの拡張の使用
によって、上手く行かなくなってしまうだろう。

別の例外は、コンパイル過程の一部として使われるプログラムだ。GNUコンパイ
ル環境の機能を立ち上げるために、他のコンパイラによってコンパイルされなけ
ればならないものはどんなものでも。もしこれらがGNUコンパイラを必要として
いると、すでにインストール済みでない限り、それらをコンパイルすることは誰
にもできない。これは良くないだろう。



File: standards-ja.info, Node: ANSI C, Next: Source Language, Prev: Using Extensions, Up: Design Advice

ANSI CとANSI以前のC
===================

決してANSI Cの "trigraph" 機能 (1) (*Note ANSI C-Footnotes::)を使っては
ならない。

ANSI Cは、今ではもうANSI Cの機能を使う(それゆえnon-ANSI コンパイラでは動
かない)新しいプログラムを書いていいぐらい広まっている。そして、もしプロ
グラムがすでにANSI Cで書かれているなら、それをnon-ANSIコンパイラをサポー
トするよう変換する必要はない。

しかしながら、ほとんどのプログラムではnon-ANSIコンパイラをサポートするの
は容易だから、プログラムを書くときにはそうするよう心掛けてもよいだろう。
ANSIプロトタイプ形式での関数定義、

     int
     foo (int x, int y)
     ...

を書く代わりに、このようなANSI以前の形式で定義を書きなさい。

     int
     foo (x, y)
          int x, y;
     ...

そして、引数のプロトタイプを特定するのに、別に宣言しなさい。

     int foo (int, int);

いずれにせよ、その関数を呼ぶ全てのファイルでANSI Cプロトタイプの恩恵を得
るためには、あるヘッダファイル内でそのような宣言を必要とする。そして、そ
れを一度書いてしまえば、ANSI以前の形式で関数定義を書くことによって失うも
のは何もない。

もしあなたがnon-ANSI Cを知らないなら、それを勉強する必要はない。ANSI Cで
書けばいい。


File: standards-ja.info  Node: ANSI C-Footnotes, Up: ANSI C

(1) 訳注: 何それ？



File: standards-ja.info, Node: Source Language, Prev: ANSI C, Up: Design Advice

C以外の言語の使用
=================

C以外の言語の使用は標準的でない機能を使うようなものだ。ユーザは問題を引
き起こすだろう。例えGCCが他の言語をサポートしていても、ユーザは、あなた
のプログラムの構築するために、その他の言語のコンパイラをインストールしな
ければならないことを不便に感じるかもしれない。例えば、あなたのプログラム
をC++で書いたら、人々はあなたのプログラムをコンパイルするためにC++コンパ
イラをインストールしなければならないだろう。このように、Cで書く方が良い
のだ。しかし他の言語を使う欠点がない状況が3つある。

   * その言語用のインタープリタをあなたのプログラムが含んでいるなら、他
     の言語を使っていい。

     例えば、あなたのプログラムがGUILEとリンクしているなら、そのプログラ
     ムの一部をSchemeやGUILEがサポートする他の言語で書いても良い。

   * その言語と一緒に使われることを特に意図しているツールでは、他の言語
     を使って良い。

     そのツールを構築したい人々は、その他の言語をいずれにせよインストー
     ルしている人々だけだろうから、これで構わないのだ。

   * もしそのアプリケーションが狭い集団に対して関心があるなら、おそらく
     そのアプリケーションのインストールが不便かどうかなど重要ではない。

CはC++や他のコンパイル用言語以上の利点を持っている。より多くの人々がC を
知っている。だから、プログラムがCで書かれていると、それを読んだり変更し
たりするのが、より多くの人々にとって容易だろう。



File: standards-ja.info, Node: Program Behavior, Next: Writing C, Prev: Design Advice, Up: Top

全てのプログラムの振る舞い
**************************

この 節では、頑丈なソフトウェアの書き方を記述する。また、エラーメッセー
ジや、コマンドラインのインターフェース、ライブラリの挙動の、汎用的な標準
についても記述する。

* Menu:

* Semantics::                   頑丈なプログラムの作成
* Libraries::                   ライブラリの挙動
* Errors::                      エラーメッセージの書式
* User Interfaces::             コマンドラインのインターフェースの標準
* Option Table::                長いオプションの表
* Memory Usage::                メモリの必要性をいつ、いかに注意するか



File: standards-ja.info, Node: Semantics, Next: Libraries, Prev: Program Behavior, Up: Program Behavior

頑丈なプログラムの作成
======================

動的に全てのデータ構造を確保することによって、ファイル名、行、ファイル、
シンボルを含む、*いかなる*データ構造の長さや数についても、勝手な制限を避
けなさい。ほとんどのUnixユーティリティでは、"長い行は黙って切り詰める"。
これはGNUユーティリティでは許容できない。

ファイルを読むユーティリティはNUL文字や、*0177以上のコードを持つ文字を含
む*あらゆる他の印字できない文字も、落とすべきではない。唯一意味のある例
外は、そういった文字を扱えない、ある種のプリンタへのインターフェースを特
別に意図したユーティリティだろう。可能な限りいつでも、UTF-8やその他のエ
ンコーディングを使って、多バイト文字を表すバイト列を適切に扱えるようにし
なさい。

エラーを無視したいと思っているのでなければ、あらゆるシステムコールのエラー
を確認しなさい。失敗したシステムコールから発生する*あらゆる* エラーメッ
セージに、もしあればファイルの名前とそのユーティリティの名前だけでなく、
(`perror'や同等のものから得られる)システムエラー文字列を含めなさい。単な
る"cannot open foo.c"や"stat failed"は十分でない。

`malloc'や`realloc'のすべての呼び出しを、ゼロを返したかどうか確認しなさ
い。例えそのブロックをもっと小さくしようとしていても、`realloc'の確認を
しなさい。2の階乗にブロックサイズを丸めるシステムでは、`realloc'はもっと
小さい領域を要求する場合に異なるブロックを得ることがある。

Unixでは、`realloc'がゼロを返す場合、記憶領域を破壊してしまう。GNU
`realloc'はこのバグを持たない。失敗すると、元のブロックは変更されない。
そのバグは直っているとみなしても構わない。もしあなたのプログラムをUnix上
で走らせたくて、こういう損失を避けたいなら、GNU `malloc' を使うことがで
きる。

`free'は解放されたブロックの中身を変えてしまうと考えなければならない。そ
のブロックの値を取り出したかったら、必ず`free'を呼ぶ前に取り出さなくては
ならない。

もし`malloc'が対話的でないプログラムで失敗したら、それを致命的なエラーに
しなさい。対話的なプログラム(ユーザからコマンドを呼んでくるもの)では、そ
のコマンドを中止して、コマンド読み込みループから返るのがより良い。こうす
ると、そのユーザは仮想メモリを解放するために他のプロセスを殺して、再びそ
のコマンドを試すことができる。

もし引数の文法が上手く行かなくなるわけでないなら、引数の解読に
`getopt_long'を使いなさい。

静的な記憶領域がプログラムの実行中に書き込まれるためであるとき、それを初
期化するための、明示的なCのコードを使いなさい。変更されないデータに対す
る、Cの初期化付き宣言を残しておきなさい。

(ファイルディレクトリや、utmp、カーネルメモリの配置のような)Unixのデータ
構造を見えにくくする、低水準のインターフェースを避けるよう努めなさい。こ
れらは互換性を失いがちだからだ。もしあるディレクトリの全ファイルを見付け
る必要があるなら、`readdir'や他の高水準のインターフェースを使いなさい。
これらはGNUによって互換性を持ってサポートされるだろう。

好ましいシグナルハンドリングの機能はBSD流の`signal'とPOSIX `sigaction'関
数である。別にあるUSGの`signal'は劣った設計だ。

今日では、POSIXシグナル関数の使用がプログラムを移植しやすくする一番簡単
な方法かもしれない。`signal'を使うと、GNU libc version 1 を使うGNU/Linux
システム上でBSDの振る舞いを得るために、`signal.h' ではなく`bsd/signal.h'
をincludeすべきだ。`signal'がUSGの振る舞いしか持たないシステムをサポート
するか、あるいは、それらを諦めてしまうかはあなた次第だ。

"あり得ない"状態を検出するエラーチェックでは、単に中止しなさい。メッセー
ジを出力する意味は普通ない。これらのチェックはバグの存在を示している。そ
のバグを直したい人なら誰でも、そのソースコードを読み、デバッガを走らせな
いといけないだろう。だから、そのソースにコメントでその問題を説明しなさい。
関係のあるデータは変数の中で、それはデバッガで検査するのは容易だろう。だ
から、それらをどこか他の位置に移す意味はない。

プログラムの終了状態として、エラーのカウントを使ってはならない。*これは
上手く行かない*。なぜなら、終了状態の値は(0から255までの) 8ビットに制限
されているからだ。そのプログラムが一回走る間に256のエラーが起きるかもし
れない。もし終了状態として256を返そうとすると、親プロセスはその状態とし
て0を見ることになり、そのプログラムが成功したかのように見えるだろう。

もし一時ファイルを作るなら、`TMPDIR'環境変数を確認しなさい。この変数が定
義されていれば、`/tmp'ではなく、指定されたディレクトリを使いなさい。



File: standards-ja.info, Node: Libraries, Next: Errors, Prev: Semantics, Up: Program Behavior

ライブラリの挙動
================

ライブラリ関数を再入可能にするよう努力しなさい。それらが動的な記憶領域の
確保を必要とするなら、少なくとも`malloc'自体は別として、再入不能を避ける
よう努力しなさい。

名前がぶつかるのを避けるために、ライブラリ用の名前付けの取り決めがある。

二文字以上の長さで、そのライブラリ用の接頭辞を決めなさい。外部に見せる関
数と変数の名前すべてに、この接頭辞を付けるべきだ。さらに、どの特定のライ
ブラリ・メンバーでも、これらのうち一つだけが入っているべきだ。これは通常
それぞれを別のソースファイルに置くことを意味する。

二つの外部シンボルが常に一緒に使われ、片方を使ってもう片方を使わないよう
な意味のあるプログラムがあり得ないようなときには、例外となる。それらは両
方とも同じファイルに入れられる。

ユーザにエントリ・ポイントとして記述されない外部シンボルは、`_'で始まる
名前を持つべきだ。それらはまた、他のライブラリと衝突するのを防ぐために、
そのライブラリのために選ばれた接頭辞を含むべきだ。これらは、好むなら、ユー
ザのエントリ・ポイントと同じファイルの中に含めても良い。

静的な関数や変数は好きなように使って良く、どんな名前付け規則にも当てはま
らなくていい。



File: standards-ja.info, Node: Errors, Next: User Interfaces, Prev: Libraries, Up: Program Behavior

エラーメッセージの書式
======================

コンパイラからのエラーメッセージは次のようであるべきだ。

     SOURCE-FILE-NAME:LINENO: MESSAGE

適切なソースファイルがあるときには、他の対話的でないプログラムからのエラー
メッセージは次のようであるべきだ。

     PROGRAM:SOURCE-FILE-NAME:LINENO: MESSAGE

関連のあるソースファイルがないときには、次のようだ。

     PROGRAM: MESSAGE

@noindent

対話的なプログラム(端末からコマンドを読んでいるもの)では、エラーメッセー
ジにプログラム名を含めない方が良い。どのプログラムが走っているかを示す場
所は、プロンプトか、スクリーンのレイアウトだ。(同じプログラムが端末以外
のソースから入力を受け取って走るとき、それは対話的ではなく、対話的でない
形式を使ってエラーメッセージを出力するのが一番良いだろう。)

文字列MESSAGEは、プログラム名やファイル名に続くときには、大文字で始める
べきではない。また、ピリオドで終わるべきではない。

対話的なプログラムからのエラーメッセージや使い方のメッセージのような他の
メッセージは大文字で始めるべきだ。しかしピリオドで終わるべきではない。



File: standards-ja.info, Node: User Interfaces, Next: Option Table, Prev: Errors, Up: Program Behavior

コマンドラインのインターフェースの標準
======================================

ユーティリティの挙動をそれを起動した名前に依存させないでください。あるユー
ティリティに別の名前をリンクすることは、ときどき有用で、そのことで何をや
るのかを換えるべきでない。

代わりに、動作時のオプションか、コンパイルするときのスィッチか、両方を別
の挙動を選択するために使いなさい。

同様に、プログラムの挙動をそれが使う出力デバイスの種類に依存しないように
してください。デバイス独立はシステム設計の重要な原理だ。単に誰かがときど
きオプションを打ち込むのを省略することに妥協してはならない。(端末を使う
ときのエラーメッセージの文法を変化させるのは構わない。なぜなら、それは人々
が依存していない別な問題だからだ。)

もし出力が端末に向かうときある挙動が最も有用で、出力がファイルかパイプな
ら他の挙動が最も有用なら、端末への出力で有用な挙動をデフォルトにして、他
の挙動のオプションを持つのが通常一番良い。

互換性のために、出力デバイスの種類に依存するプログラムを必要とする。もし
`ls'や`sh'が、あらゆるユーザが期待する方法で働かなかったら、それはひどい
だろう。これらの場合のうちいくつかでは、出力デバイスの種類に依存しない、
より好ましい別バージョンを我々は補う。例えば、`ls'にとても似ているが、デ
フォルトの出力形式が常に複数欄形式である、`dir'プログラムを提供する。

プログラムのコマンドライン・オプションをPOSIXのガイドラインに従わせるの
は良い考えだ。これを行う一番簡単な方法は、それらを解析するのに`getopt'を
使うことだ。`getopt'のGNUバージョンは、特別な引数`--'が使われなければ、
通常オプションが引数のどこにあっても良いことに注意しなさい。これはPOSIX
が規定していることではない。GNUの拡張だ。

一文字のUnix形式オプションと等価な長い名前のオプションを定義してください。
我々はこの方法でGNUをよりユーザに親しみやすいものにしたいと思っている。
これはGNUの関数`getopt_log'を使えば簡単だ。

長い名前のオプションの利点の一つはどのプログラムでも一貫したものにできる
からだ。例えば、ユーザは"verbose"オプションを持つどのGNUプログラムもそれ
が正確に`--verbose'と綴られると期待することができるべきだ。この不変性を
成すために、あなたのプログラムのオプション名を選ぶとき、共通の長いオプショ
ン名の表を見なさい (*Note Option Table::)。

普通の引数として与えられるファイル名が入力ファイルだけにするのは普通良い
考えだ。どんな出力ファイルでも(願わくは`-o'や`--output'のような)オプショ
ンによって指定されるだろう。互換性のために普通の引数として出力ファイル名
を許す場合でも、それを指定する他の方法としてオプションを与えてみなさい。
これはGNUユーティリティの一貫性を増し、そしてユーザが覚えるべき独自性を
減らすであろう。

あらゆるプログラムは次の二つの標準的なオプションをサポートすべきだ。
`--version'と`--help'だ。

`--version'
     このオプションはそのプログラムに、その名前、バージョン、出所と法的
     な状態に関する情報を、すべて標準出力に出させ、そして成功状態で終了
     させるべきだ。他のオプションや引数はこれが現れたら無視されるべきで、
     そのプログラムはその通常の機能を行うべきではない。

     最初の行をプログラムが解析しやすくする。そのバージョン・ナンバーを
     最後のスペースの後に始める。加えて、このプログラムの正しい名前を次
     の形式で含める。

          GNU Emacs 19.30

     プログラム名は固定文字列であるべきだ。それを`argv[0]'から計算しては
     *いけない*。その考えは、そのファイル名ではなく、そのプログラムの標
     準的、あるいは、正統な名前を表明することである。コマンドを`PATH'か
     ら見付けることで、正確なファイル名を見付け出す他の方法があるのだ。

     もしプログラムが大きいパッケージの補助的な部分なら、次のようにその
     プログラム名を括弧の中で記述しなさい。

          emacsserver (GNU Emacs) 19.30

     もしそのパッケージがこのプログラムのバージョン・ナンバーとは違うバー
     ジョン・ナンバーを持っているなら、閉じ括弧の直前にそのパッケージの
     バージョン・ナンバーを記述して良い。

     もしこのプログラムを含むパッケージとは別に配布されるライブラリのバー
     ジョン・ナンバーを記述*したい*のなら、記述したいそれぞれのライブラ
     リ毎に行を追加して、バージョン情報を出力することで、そうして良い。
     それらの行に最初の行と同じ形式を使いなさい。

     そのプログラムが使うライブラリ全てを、"単に完全であるためだけに"記
     述しないでください。---そうすると、たくさんの役に立たない乱雑さを生
     み出してしまうだろう。あなたがデバッグをするのに非常に重要であると
     実際に見出した場合にだけ、ライブラリのバージョン・ナンバーを記述し
     てください。

     バージョン・ナンバーの行の後の、次の行は著作権通知であるべきだ。二
     つ以上の著作権通知が必要なら、それぞれ別の行に入れなさい。

     次は、そのプログラムがフリーソフトウェアであり、ユーザは自由に複製
     したり、ある条件でそれを改変して良いという、簡単な記述が続くべきだ。
     もしそのプログラムがGNU GPLによって保護されているなら、ここでそう言
     いなさい。また、法に認められる範囲に対し、無保証であることを書きな
     さい。

     名誉を与える方法として、そのプログラムの主要な作者の名簿を出力して
     終わらせて構わない。

     これらの規則に従う出力の例を示そう。

          GNU Emacs 19.34.5
          Copyright (C) 1996 Free Software Foundation, Inc.
          GNU Emacs comes with NO WARRANTY,
          to the extent permitted by law.
          You may redistribute copies of GNU Emacs
          under the terms of the GNU General Public License.
          For more information about these matters,
          see the files named COPYING.

     これをあなたのプログラムに一致させるべきだ。当然、適切な年、著作権
     者、プログラムの名前、そして、配布条件の言及を入れ、必要に応じて残
     りの言葉遣いを換えるべきだ。

     この著作権通知は変更がなされた一番最近の年を記述するだけでいい。---
     以前のバージョンの変更に対して年を列挙する必要はない。もし不便なら、
     プログラムの名前をこの通知の中で記述しなくて良い。最初の行に現れて
     いるから。

`--help'
     このオプションはそのプログラムをどのように起動するかを、標準出力上
     に、簡単な解説を出力し、成功終了すべきだ。他のオプションや引数はこ
     れが現れたら無視すべきで、そのプログラムはその通常の機能を行うべき
     ではない。

     `--help'オプションの出力の最後の辺りで、バグ報告をどこにメールする
     かを表す行があるべきだ。こういう書式を持つ。

          Report bugs to MAILING-ADDRESS.



File: standards-ja.info, Node: Option Table, Next: Memory Usage, Prev: User Interfaces, Up: Program Behavior

長いオプションの表
==================

GNUプログラムによって使われる長いオプションの表をここで示す。きっと不完
全ではあるが、新しいプログラムが互換性を持ちたいであろうオプションをすべ
て列挙するつもりだ。もしこの表にまだない名前を使うなら、それらの表と、そ
れらの意味をgnu@gnu.orgに送ってください。我々がこの表を更新できるので 
(1) (*Note Option Table-Footnotes::)。


`after-date'
     `-N' in `tar'.

`all'
     `-a' in `du', `ls', `nm', `stty', `uname', and `unexpand'.

`all-text'
     `-a' in `diff'.

`almost-all'
     `-A' in `ls'.

`append'
     `-a' in `etags', `tee', `time'; `-r' in `tar'.

`archive'
     `-a' in `cp'.

`archive-name'
     `-n' in `shar'.

`arglength'
     `-l' in `m4'.

`ascii'
     `-a' in `diff'.

`assign'
     `-v' in `gawk'.

`assume-new'
     `-W' in Make.

`assume-old'
     `-o' in Make.

`auto-check'
     `-a' in `recode'.

`auto-pager'
     `-a' in `wdiff'.

`auto-reference'
     `-A' in `ptx'.

`avoid-wraps'
     `-n' in `wdiff'.

`background'
     For server programs, run in the background.

`backward-search'
     `-B' in `ctags'.

`basename'
     `-f' in `shar'.

`batch'
     Used in GDB.

`baud'
     Used in GDB.

`before'
     `-b' in `tac'.

`binary'
     `-b' in `cpio' and `diff'.

`bits-per-code'
     `-b' in `shar'.

`block-size'
     Used in `cpio' and `tar'.

`blocks'
     `-b' in `head' and `tail'.

`break-file'
     `-b' in `ptx'.

`brief'
     Used in various programs to make output shorter.

`bytes'
     `-c' in `head', `split', and `tail'.

`c++'
     `-C' in `etags'.

`catenate'
     `-A' in `tar'.

`cd'
     Used in various programs to specify the directory to use.

`changes'
     `-c' in `chgrp' and `chown'.

`classify'
     `-F' in `ls'.

`colons'
     `-c' in `recode'.

`command'
     `-c' in `su'; `-x' in GDB.

`compare'
     `-d' in `tar'.

`compat'
     Used in `gawk'.

`compress'
     `-Z' in `tar' and `shar'.

`concatenate'
     `-A' in `tar'.

`confirmation'
     `-w' in `tar'.

`context'
     Used in `diff'.

`copyleft'
     `-W copyleft' in `gawk'.

`copyright'
     `-C' in `ptx', `recode', and `wdiff'; `-W copyright' in `gawk'.

`core'
     Used in GDB.

`count'
     `-q' in `who'.

`count-links'
     `-l' in `du'.

`create'
     Used in `tar' and `cpio'.

`cut-mark'
     `-c' in `shar'.

`cxref'
     `-x' in `ctags'.

`date'
     `-d' in `touch'.

`debug'
     `-d' in Make and `m4'; `-t' in Bison.

`define'
     `-D' in `m4'.

`defines'
     `-d' in Bison and `ctags'.

`delete'
     `-D' in `tar'.

`dereference'
     `-L' in `chgrp', `chown', `cpio', `du', `ls', and `tar'.

`dereference-args'
     `-D' in `du'.

`diacritics'
     `-d' in `recode'.

`dictionary-order'
     `-d' in `look'.

`diff'
     `-d' in `tar'.

`digits'
     `-n' in `csplit'.

`directory'
     Specify the directory to use, in various programs.  In `ls', it
     means to show directories themselves rather than their contents.
     In `rm' and `ln', it means to not treat links to directories
     specially.

`discard-all'
     `-x' in `strip'.

`discard-locals'
     `-X' in `strip'.

`dry-run'
     `-n' in Make.

`ed'
     `-e' in `diff'.

`elide-empty-files'
     `-z' in `csplit'.

`end-delete'
     `-x' in `wdiff'.

`end-insert'
     `-z' in `wdiff'.

`entire-new-file'
     `-N' in `diff'.

`environment-overrides'
     `-e' in Make.

`eof'
     `-e' in `xargs'.

`epoch'
     Used in GDB.

`error-limit'
     Used in `makeinfo'.

`error-output'
     `-o' in `m4'.

`escape'
     `-b' in `ls'.

`exclude-from'
     `-X' in `tar'.

`exec'
     Used in GDB.

`exit'
     `-x' in `xargs'.

`exit-0'
     `-e' in `unshar'.

`expand-tabs'
     `-t' in `diff'.

`expression'
     `-e' in `sed'.

`extern-only'
     `-g' in `nm'.

`extract'
     `-i' in `cpio'; `-x' in `tar'.

`faces'
     `-f' in `finger'.

`fast'
     `-f' in `su'.

`fatal-warnings'
     `-E' in `m4'.

`file'
     `-f' in `info', `gawk', Make, `mt', and `tar'; `-n' in `sed'; `-r'
     in `touch'.

`field-separator'
     `-F' in `gawk'.

`file-prefix'
     `-b' in Bison.

`file-type'
     `-F' in `ls'.

`files-from'
     `-T' in `tar'.

`fill-column'
     Used in `makeinfo'.

`flag-truncation'
     `-F' in `ptx'.

`fixed-output-files'
     `-y' in Bison.

`follow'
     `-f' in `tail'.

`footnote-style'
     Used in `makeinfo'.

`force'
     `-f' in `cp', `ln', `mv', and `rm'.

`force-prefix'
     `-F' in `shar'.

`foreground'
     For server programs, run in the foreground; in other words, don't
     do anything special to run the server in the background.

`format'
     Used in `ls', `time', and `ptx'.

`freeze-state'
     `-F' in `m4'.

`fullname'
     Used in GDB.

`gap-size'
     `-g' in `ptx'.

`get'
     `-x' in `tar'.

`graphic'
     `-i' in `ul'.

`graphics'
     `-g' in `recode'.

`group'
     `-g' in `install'.

`gzip'
     `-z' in `tar' and `shar'.

`hashsize'
     `-H' in `m4'.

`header'
     `-h' in `objdump' and `recode'

`heading'
     `-H' in `who'.

`help'
     Used to ask for brief usage information.

`here-delimiter'
     `-d' in `shar'.

`hide-control-chars'
     `-q' in `ls'.

`idle'
     `-u' in `who'.

`ifdef'
     `-D' in `diff'.

`ignore'
     `-I' in `ls'; `-x' in `recode'.

`ignore-all-space'
     `-w' in `diff'.

`ignore-backups'
     `-B' in `ls'.

`ignore-blank-lines'
     `-B' in `diff'.

`ignore-case'
     `-f' in `look' and `ptx'; `-i' in `diff' and `wdiff'.

`ignore-errors'
     `-i' in Make.

`ignore-file'
     `-i' in `ptx'.

`ignore-indentation'
     `-I' in `etags'.

`ignore-init-file'
     `-f' in Oleo.

`ignore-interrupts'
     `-i' in `tee'.

`ignore-matching-lines'
     `-I' in `diff'.

`ignore-space-change'
     `-b' in `diff'.

`ignore-zeros'
     `-i' in `tar'.

`include'
     `-i' in `etags'; `-I' in `m4'.

`include-dir'
     `-I' in Make.

`incremental'
     `-G' in `tar'.

`info'
     `-i', `-l', and `-m' in Finger.

`initial'
     `-i' in `expand'.

`initial-tab'
     `-T' in `diff'.

`inode'
     `-i' in `ls'.

`interactive'
     `-i' in `cp', `ln', `mv', `rm'; `-e' in `m4'; `-p' in `xargs'; `-w'
     in `tar'.

`intermix-type'
     `-p' in `shar'.

`jobs'
     `-j' in Make.

`just-print'
     `-n' in Make.

`keep-going'
     `-k' in Make.

`keep-files'
     `-k' in `csplit'.

`kilobytes'
     `-k' in `du' and `ls'.

`language'
     `-l' in `etags'.

`less-mode'
     `-l' in `wdiff'.

`level-for-gzip'
     `-g' in `shar'.

`line-bytes'
     `-C' in `split'.

`lines'
     Used in `split', `head', and `tail'.

`link'
     `-l' in `cpio'.

`lint'
`lint-old'
     Used in `gawk'.

`list'
     `-t' in `cpio'; `-l' in `recode'.

`list'
     `-t' in `tar'.

`literal'
     `-N' in `ls'.

`load-average'
     `-l' in Make.

`login'
     Used in `su'.

`machine'
     No listing of which programs already use this; someone should check
     to see if any actually do, and tell gnu@gnu.org.

`macro-name'
     `-M' in `ptx'.

`mail'
     `-m' in `hello' and `uname'.

`make-directories'
     `-d' in `cpio'.

`makefile'
     `-f' in Make.

`mapped'
     Used in GDB.

`max-args'
     `-n' in `xargs'.

`max-chars'
     `-n' in `xargs'.

`max-lines'
     `-l' in `xargs'.

`max-load'
     `-l' in Make.

`max-procs'
     `-P' in `xargs'.

`mesg'
     `-T' in `who'.

`message'
     `-T' in `who'.

`minimal'
     `-d' in `diff'.

`mixed-uuencode'
     `-M' in `shar'.

`mode'
     `-m' in `install', `mkdir', and `mkfifo'.

`modification-time'
     `-m' in `tar'.

`multi-volume'
     `-M' in `tar'.

`name-prefix'
     `-a' in Bison.

`nesting-limit'
     `-L' in `m4'.

`net-headers'
     `-a' in `shar'.

`new-file'
     `-W' in Make.

`no-builtin-rules'
     `-r' in Make.

`no-character-count'
     `-w' in `shar'.

`no-check-existing'
     `-x' in `shar'.

`no-common'
     `-3' in `wdiff'.

`no-create'
     `-c' in `touch'.

`no-defines'
     `-D' in `etags'.

`no-deleted'
     `-1' in `wdiff'.

`no-dereference'
     `-d' in `cp'.

`no-inserted'
     `-2' in `wdiff'.

`no-keep-going'
     `-S' in Make.

`no-lines'
     `-l' in Bison.

`no-piping'
     `-P' in `shar'.

`no-prof'
     `-e' in `gprof'.

`no-regex'
     `-R' in `etags'.

`no-sort'
     `-p' in `nm'.

`no-split'
     Used in `makeinfo'.

`no-static'
     `-a' in `gprof'.

`no-time'
     `-E' in `gprof'.

`no-timestamp'
     `-m' in `shar'.

`no-validate'
     Used in `makeinfo'.

`no-wait'
     Used in `emacsclient'.

`no-warn'
     Used in various programs to inhibit warnings.

`node'
     `-n' in `info'.

`nodename'
     `-n' in `uname'.

`nonmatching'
     `-f' in `cpio'.

`nstuff'
     `-n' in `objdump'.

`null'
     `-0' in `xargs'.

`number'
     `-n' in `cat'.

`number-nonblank'
     `-b' in `cat'.

`numeric-sort'
     `-n' in `nm'.

`numeric-uid-gid'
     `-n' in `cpio' and `ls'.

`nx'
     Used in GDB.

`old-archive'
     `-o' in `tar'.

`old-file'
     `-o' in Make.

`one-file-system'
     `-l' in `tar', `cp', and `du'.

`only-file'
     `-o' in `ptx'.

`only-prof'
     `-f' in `gprof'.

`only-time'
     `-F' in `gprof'.

`output'
     In various programs, specify the output file name.

`output-prefix'
     `-o' in `shar'.

`override'
     `-o' in `rm'.

`overwrite'
     `-c' in `unshar'.

`owner'
     `-o' in `install'.

`paginate'
     `-l' in `diff'.

`paragraph-indent'
     Used in `makeinfo'.

`parents'
     `-p' in `mkdir' and `rmdir'.

`pass-all'
     `-p' in `ul'.

`pass-through'
     `-p' in `cpio'.

`port'
     `-P' in `finger'.

`portability'
     `-c' in `cpio' and `tar'.

`posix'
     Used in `gawk'.

`prefix-builtins'
     `-P' in `m4'.

`prefix'
     `-f' in `csplit'.

`preserve'
     Used in `tar' and `cp'.

`preserve-environment'
     `-p' in `su'.

`preserve-modification-time'
     `-m' in `cpio'.

`preserve-order'
     `-s' in `tar'.

`preserve-permissions'
     `-p' in `tar'.

`print'
     `-l' in `diff'.

`print-chars'
     `-L' in `cmp'.

`print-data-base'
     `-p' in Make.

`print-directory'
     `-w' in Make.

`print-file-name'
     `-o' in `nm'.

`print-symdefs'
     `-s' in `nm'.

`printer'
     `-p' in `wdiff'.

`prompt'
     `-p' in `ed'.

`query-user'
     `-X' in `shar'.

`question'
     `-q' in Make.

`quiet'
     Used in many programs to inhibit the usual output.  *Note:* every
     program accepting `--quiet' should accept `--silent' as a synonym.

`quiet-unshar'
     `-Q' in `shar'

`quote-name'
     `-Q' in `ls'.

`rcs'
     `-n' in `diff'.

`re-interval'
     Used in `gawk'.

`read-full-blocks'
     `-B' in `tar'.

`readnow'
     Used in GDB.

`recon'
     `-n' in Make.

`record-number'
     `-R' in `tar'.

`recursive'
     Used in `chgrp', `chown', `cp', `ls', `diff', and `rm'.

`reference-limit'
     Used in `makeinfo'.

`references'
     `-r' in `ptx'.

`regex'
     `-r' in `tac' and `etags'.

`release'
     `-r' in `uname'.

`reload-state'
     `-R' in `m4'.

`relocation'
     `-r' in `objdump'.

`rename'
     `-r' in `cpio'.

`replace'
     `-i' in `xargs'.

`report-identical-files'
     `-s' in `diff'.

`reset-access-time'
     `-a' in `cpio'.

`reverse'
     `-r' in `ls' and `nm'.

`reversed-ed'
     `-f' in `diff'.

`right-side-defs'
     `-R' in `ptx'.

`same-order'
     `-s' in `tar'.

`same-permissions'
     `-p' in `tar'.

`save'
     `-g' in `stty'.

`se'
     Used in GDB.

`sentence-regexp'
     `-S' in `ptx'.

`separate-dirs'
     `-S' in `du'.

`separator'
     `-s' in `tac'.

`sequence'
     Used by `recode' to chose files or pipes for sequencing passes.

`shell'
     `-s' in `su'.

`show-all'
     `-A' in `cat'.

`show-c-function'
     `-p' in `diff'.

`show-ends'
     `-E' in `cat'.

`show-function-line'
     `-F' in `diff'.

`show-tabs'
     `-T' in `cat'.

`silent'
     Used in many programs to inhibit the usual output.  *Note:* every
     program accepting `--silent' should accept `--quiet' as a synonym.

`size'
     `-s' in `ls'.

`socket'
     Specify a file descriptor for a network server to use for its
     socket, instead of opening and binding a new socket.  This provides
     a way to run, in a nonpriveledged process, a server that normally
     needs a reserved port number.

`sort'
     Used in `ls'.

`source'
     `-W source' in `gawk'.

`sparse'
     `-S' in `tar'.

`speed-large-files'
     `-H' in `diff'.

`split-at'
     `-E' in `unshar'.

`split-size-limit'
     `-L' in `shar'.

`squeeze-blank'
     `-s' in `cat'.

`start-delete'
     `-w' in `wdiff'.

`start-insert'
     `-y' in `wdiff'.

`starting-file'
     Used in `tar' and `diff' to specify which file within a directory
     to start processing with.

`statistics'
     `-s' in `wdiff'.

`stdin-file-list'
     `-S' in `shar'.

`stop'
     `-S' in Make.

`strict'
     `-s' in `recode'.

`strip'
     `-s' in `install'.

`strip-all'
     `-s' in `strip'.

`strip-debug'
     `-S' in `strip'.

`submitter'
     `-s' in `shar'.

`suffix'
     `-S' in `cp', `ln', `mv'.

`suffix-format'
     `-b' in `csplit'.

`sum'
     `-s' in `gprof'.

`summarize'
     `-s' in `du'.

`symbolic'
     `-s' in `ln'.

`symbols'
     Used in GDB and `objdump'.

`synclines'
     `-s' in `m4'.

`sysname'
     `-s' in `uname'.

`tabs'
     `-t' in `expand' and `unexpand'.

`tabsize'
     `-T' in `ls'.

`terminal'
     `-T' in `tput' and `ul'.  `-t' in `wdiff'.

`text'
     `-a' in `diff'.

`text-files'
     `-T' in `shar'.

`time'
     Used in `ls' and `touch'.

`to-stdout'
     `-O' in `tar'.

`total'
     `-c' in `du'.

`touch'
     `-t' in Make, `ranlib', and `recode'.

`trace'
     `-t' in `m4'.

`traditional'
     `-t' in `hello'; `-W traditional' in `gawk'; `-G' in `ed', `m4',
     and `ptx'.

`tty'
     Used in GDB.

`typedefs'
     `-t' in `ctags'.

`typedefs-and-c++'
     `-T' in `ctags'.

`typeset-mode'
     `-t' in `ptx'.

`uncompress'
     `-z' in `tar'.

`unconditional'
     `-u' in `cpio'.

`undefine'
     `-U' in `m4'.

`undefined-only'
     `-u' in `nm'.

`update'
     `-u' in `cp', `ctags', `mv', `tar'.

`usage'
     Used in `gawk'; same as `--help'.

`uuencode'
     `-B' in `shar'.

`vanilla-operation'
     `-V' in `shar'.

`verbose'
     Print more information about progress.  Many programs support this.

`verify'
     `-W' in `tar'.

`version'
     Print the version number.

`version-control'
     `-V' in `cp', `ln', `mv'.

`vgrind'
     `-v' in `ctags'.

`volume'
     `-V' in `tar'.

`what-if'
     `-W' in Make.

`whole-size-limit'
     `-l' in `shar'.

`width'
     `-w' in `ls' and `ptx'.

`word-regexp'
     `-W' in `ptx'.

`writable'
     `-T' in `who'.

`zeros'
     `-z' in `gprof'.


File: standards-ja.info  Node: Option Table-Footnotes, Up: Option Table

(1) 訳注: ここには訳するほど難解な事はないはずなので、原文のまま。



File: standards-ja.info, Node: Memory Usage, Prev: Option Table, Up: Program Behavior

メモリの使用
============

概して、たった数メガしかメモリを使わないなら、メモリの使用を減らす努力を
行うことに悩まないように。例えば、数メガ以上のファイルを扱うことが他の事
情で実際的でなかったら、それらを処理するのに入力ファイル全体をコアに読み
込むことは理に適っている。

しかしながら、普通に非常に大きいファイルを扱うことのある、`cat'や`tail'
のようなプログラムにとって、それが処理できるファイルの大きさを人為的に制
限する手法の使用は避けることが重要だ。もしプログラムが行毎に働き、ユーザ
が提供する任意の入力ファイルが与えられるならば、一行だけをメモリに保持す
るべきだ。なぜなら、これは大して難しくなく、全て一度にコアに入るよりも大
きいファイルを扱えることをユーザが望むだろうからだ。

もしあなたのプログラムが複雑なデータ構造を作るなら、単にコアにそれを作っ
て、もし`malloc'がゼロを返したら致命的なエラーにしてしまいなさい。



File: standards-ja.info, Node: Writing C, Next: Documentation, Prev: Program Behavior, Up: Top

Cの一番良い使い方
*****************

この 節では、GNUソフトウェアを書くときの一番良いC言語の使い方について助
言を与える。

* Menu:

* Formatting::                  あなたのソースコードの書式
* Comments::                    あなたの仕事のコメント
* Syntactic Conventions::       Cの構成のきれいな利用
* Names::                       変数と関数の名前付け
* System Portability::          異なるオペレーティング・システム間の移植性
* CPU Portability::             様々なCPUの種類のサポート
* System Functions::            "標準"ライブラリ関数の移植性
* Internationalization::        国際化の手法
* Mmap::                        `mmap'の安全な使い方



File: standards-ja.info, Node: Formatting, Next: Comments, Prev: Writing C, Up: Writing C

あなたのソースコードの書式
==========================

C関数の本体を開始する開き大括弧をゼロ列目に置き、他の開き大括弧や開き丸
括弧や開き角括弧をゼロ列目に置かないようにするのは重要だ。いくつかのツー
ルは、C関数の始まりを探すのに、ゼロ列目の開き大括弧を捜す。これらのツー
ルはそういう風にフォーマットされていないコードでは上手く動かないだろう。

関数定義で、関数の名前がゼロ列目で始まっていることも重要だ。人々はこれの
おかげで関数定義を探すのが楽になり、あるツールがそれらを認識するのも楽に
なるかもしれない。こうして、適切な書式は次のようになる。

     static char *
     concat (s1, s2)        /* Name starts in column zero here */
          char *s1, *s2;
     {                     /* Open brace in column zero here */
       ...
     }

あるいは、もしANSI Cを使いたいなら、次のように定義をフォーマットする。

     static char *
     concat (char *s1, char *s2)
     {
       ...
     }

ANSI Cでは、もし引数が上手く一行に収まらないなら、次のようにそれを分ける。

     int
     lots_of_args (int an_integer, long a_long, short a_short,
                   double a_double, float a_float)
     ...

関数の本体では、次のようにフォーマットされたコードを好んでいる。

     if (x < foo (y, z))
       haha = bar[4] + 5;
     else
       {
         while (z)
           {
             haha += foo (z, z);
             z--;
           }
         return ++x + bar ();
       }

我々は開き丸括弧の前とコンマの後にスペースがあるとプログラムを読むのがよ
り簡単であることを見出している。とりわけコンマの後は。

式を複数行に分けるとき、演算子の後ではなく、それの前で分ける。こうするの
が正しいやり方だ。

     if (foo_this_is_long && bar > win (x, y, z)
         && remaining_condition)

字下げが同じところで、異なる優先度の二つの演算子を持たないようにしなさい。
例えば、こう書いてはいけない。

     mode = (inmode[j] == VOIDmode
             || GET_MODE_SIZE (outmode[j]) > GET_MODE_SIZE (inmode[j])
            ? outmode[j] : inmode[j]);

代わりに、字下げが入れ子を表すよう、余分な丸括弧を使う。

     mode = ((inmode[j] == VOIDmode
              || (GET_MODE_SIZE (outmode[j]) > GET_MODE_SIZE (inmode[j])))
             ? outmode[j] : inmode[j]);

Emacsがそのコードを適切に字下げするよう、余分な丸括弧を入れなさい。例え
ば、次の字下げは手でやるといい感じだが、Emacsは台なしにしてしまう。

     v = rup->ru_utime.tv_sec*1000 + rup->ru_utime.tv_usec/1000
         + rup->ru_stime.tv_sec*1000 + rup->ru_stime.tv_usec/1000;

でも開き括弧一組を加えると問題は解決する。

     v = (rup->ru_utime.tv_sec*1000 + rup->ru_utime.tv_usec/1000
          + rup->ru_stime.tv_sec*1000 + rup->ru_stime.tv_usec/1000);

do-while文は次のようにフォーマットする。

     do
       {
         a = foo (a);
       }
     while (a > 0);

フォームフィード文字 (control-L) を使って、プログラムを(関数の中ではなく) 
論理的な位置でページに分割してほしい。ページがどれぐらいの長さかなんて問
題じゃない。印刷されるページに合わせなくていいのだから。フォームフィード
は行の中にそれ自身だけを置くべきだ。




File: standards-ja.info, Node: Comments, Next: Syntactic Conventions, Prev: Formatting, Up: Writing C

あなたの仕事のコメント
======================

どんなプログラムでもそれが何なのか簡単に表すコメントで始まるべきだ。例:
`fmt - filter for simple filling of text'.

英語は全ての国のほとんど全てのプログラマが読むことのできる唯一の言語なの
で、GNUプログラムでは英語でコメントを書いてほしい。もしあなたが英語を上
手く書けないなら、出来るだけ上手く英語でコメントを書き、他の人々にそれら
を書き直すのを手伝ってくれるよう頼んでください。もし英語でコメントを書く
ことができないなら、一緒に仕事してくれる誰かを探して、あなたのコメントを
英語に翻訳してもらってください。

それぞれの関数に、その関数が何をやり、どういう引数を受け取り、引数のあり
得る値が何を意味し、そして何に使われるのかを表すコメントを書いてください。
もしCの型が習慣的なやり型で使われるなら、Cの引数宣言の意味をくどくどと複
製する必要はない。もしその利用が(実際には文字列の最初ではなく、二文字目
のアドレスである`char *'型の引数のような)標準的でないものだったら、ある
いは、(改行を含む文字列は動作保証されない、というような)期待される方法で
は働かない値があり得るなら、そう書くのを忘れないようにしなさい。

また、もしあるなら、返り値の意味を説明しなさい。

Emacsのセンテンス・コマンド(sentence command)が働くように、コメントの行
の最後の後に二つのスペースを置いてください。また、完全な文を書き、最初の
単語を大文字で書いてください。もし小文字の識別子が文の最初に来たら、それ
を大文字で書いてはいけない! 綴りを変えると違う識別子になる。もし小文字で
文を始めるのが好きじゃないなら、文を違うように書きなさい(例えば、"The
identifier lower-case is ...")。

関数の上のコメントは、引数の値について言うときにその引数の名前を使えば、
ずっとはっきりする。変数名それ自体は小文字であるべきだが、変数そのもので
はなく、その値について言っているときには大文字で書きなさい。従って、"an
inode"よりも、"the inode number NODE_NUM"である。

普通コメントに関数の名前を再び言うことに意味はない。なぜなら、読者は自分
でそれを見ることができるからだ。関数自身がスクリーンの一番下からはみ出て
しまうぐらいコメントが長いときは例外かもしれない。

静的な変数それぞれにも、次のようにコメントがあるべきだ。

     /* Nonzero means truncate lines in the display;
        zero means continue them.  */
     int truncate_lines;

すべての`#endif'に、入れ子になっていない(たった数行の)短い条件分岐の場合
を除いて、コメントを付けるべきだ。そのコメントには、*その意味を含めて*、
終了する条件分岐の状態を記すべきだ。`#else'はその条件と続くコードの*意味
*を記述するコメントを持つべきだ。例えば、

     #ifdef foo
       ...
     #else /* not foo */
       ...
     #endif /* not foo */
     #ifdef foo
       ...
     #endif /* foo */

しかし、対照的に、`#ifndef'では次のようなコメントを書く。

     #ifndef foo
       ...
     #else /* foo */
       ...
     #endif /* foo */
     #ifndef foo
       ...
     #endif /* not foo */



File: standards-ja.info, Node: Syntactic Conventions, Next: Names, Prev: Comments, Up: Writing C

Cの構成のきれいな利用
=====================

関数への全ての引数を明示的に宣言してください。それらが単に`int'だからと
いう理由で省いていけない。

外部関数とソースファイルの後ろに現れる関数の宣言は、ファイルの先頭の近く
一箇所か、ヘッダファイルの中に書くべきだ。関数の中に`extern'宣言を置いて
はいけない。

以前、一つの関数内で繰り返し繰り返し異なる値のために(`tem'のような名前で)
同じ局所変数を使うのが普通のやり方だった。こうする代わりに、別の目的毎に
別の局所変数を宣言し、意味のある名前を付ける方がより良い。これでプログラ
ムがより理解しやすくなるだけでなく、良いコンパイラの最適化を促進するので
ある。また、局所変数の宣言をそれぞれ、それを全て使用する一番小さい領域に
入れることができる。こうすると、プログラムがさらにきれいになるのだ。

大域識別子を隠す局所変数や引数を使ってはならない。

複数行に及ぶ一つの宣言で複数の変数を宣言してはいけない。代わりに、それぞ
れ行で新しく宣言を始めなさい。例えば、こうする代わりに、

     int    foo,
            bar;

こう書くか、

     int foo, bar;

あるいは、こうする。

     int foo;
     int bar;

(もしそれらが大域変数なら、いずれにせよその前にコメントを付けるべきだ。)

他の`if'文に入れ子になる`if'-`else'文があるとき、必ずその`if'-`else'の周
りに大括弧を付ける。従って、次のように決して書いてはならない。

     if (foo)
       if (bar)
         win ();
       else
         lose ();

常に次のようにする。

     if (foo)
       {
         if (bar)
           win ();
         else
           lose ();
       }

もし`else'文の中に入れ子になる`if'文があれば、次のように、`then'部分をそ
の前の`then'部分のように字下げして一行に`else if'を書くか、

     if (foo)
       ...
     else if (bar)
       ...

あるいは、次のように大括弧の中に入れ子の`if'を書く。

     if (foo)
       ...
     else
       {
         if (bar)
           ...
       }

同じ宣言で、構造体のタグや変数、typedefを一緒に宣言してはならない。代わ
りに、構造体のタグを別に宣言して、それから変数やtypedefを宣言する。

`if'条件文内で代入しないようにしなさい。例えば、こう書いてはいけない。

     if ((foo = (char *) malloc (sizeof *foo)) == 0)
       fatal ("virtual memory exhausted");

代わりに、こう書く。

     foo = (char *) malloc (sizeof *foo);
     if (foo == 0)
       fatal ("virtual memory exhausted");

`lint'をおとなしくするのに、プログラムを見苦しくしてはならない。`void'へ
のキャストを入れないでください。キャストなしのゼロは、可変引数の関数を呼
ぶときを除くと、ヌル・ポインタ定数として全く結構である。



File: standards-ja.info, Node: Names, Next: System Portability, Prev: Syntactic Conventions, Up: Writing C

変数と関数の名前付け
====================

プログラムの大域的な変数や関数の名前はコメントのように働く。だから、簡潔
な名前を選ばないように。---代わりに、その変数や関数の意味について役に立
つ情報を与える名前を探しなさい。GNUプログラムでは、名前は他のコメントと
同様英語であるべきである。

局所変数の名前はもっと短くていい。なぜなら、それらは一つの文脈の中でだけ
使われ、そこでは(たぶん)コメントがそれらの目的を説明している。

ある名前の単語を分けるのに、Emacsの単語コマンドがその中で使えるように、
アンダースコアを使ってください。小文字にしておきなさい。大文字をマクロや
`enum'定数や一定の取り決めに従う接頭辞のために取っておきなさい。

例えば、`ignore_space_change_flag'のような名前を使うべきだ。
`iCantReadThis'のような名前を使ってはいけない。

コマンドラインのオプションが指定されたかどうかを示す変数は、オプションの
文字ではなく、オプションの意味にちなんだ名前を付けるべきだ。コメントがオ
プションの正確な意味とその文字の両方を記述すべきだ。例えば、

     /* Ignore changes in horizontal whitespace (-b).  */
     int ignore_space_change_flag;

一定の整数値に名前を定義したいとき、`#define'よりも`enum'を使いなさい。
GDBは列挙定数について知っている。

古いSystem Vシステムで不必要な問題を引き起こさないよう、14文字以下のファ
イル名を使いなさい。これを試験するのに`doschk'というプログラムを使うこと
ができる。`doschk'はまた、MS-DOSファイルシステムにファイルが置かれたとし
たら、名前が衝突する可能性を試験する。---注意してもしなくても構わないも
のだ。



File: standards-ja.info, Node: System Portability, Next: CPU Portability, Prev: Names, Up: Writing C

システム間の移植性
==================

Unixの世界では、"移植性"は異なるUnixバージョンに移植することを言っている。
GNUプログラムにとって、この種の移植性は望ましいが、最も重要ではない。

GNUソフトウェアの主要な目的は、GNUカーネルの上で走り、GNU Cコンパイラで
コンパイルされ、様々なCPU上で動くことだ。異なるCPU上のGNUシステム間の多
様性の量と種類は、今日のLinuxに基づくGNUシステムやBSDシステム間の多様性
と比較できる程度であろう。だから、絶対に必要な移植性の種類はかなり限られ
ている。

しかしたくさんのユーザがGNUソフトウェアをGNUでないUnixやUnix-likeシステ
ムで走らせている。だから、さまざまなUnix-likeシステムをサポートすること
が望ましい。最も重要ではないけれど。

ほとんどのUnix-likeシステムへの移植性を得る一番簡単な方法はAutoconfを使
うことだ。あなたのプログラムがAutoconfが提供できる以上にホスト・プラット
ホームに関する情報を知る必要があることはあまりない。単にそういう情報を必
要とするプログラムの大部分はすでに書かれているから。

準内部的データベース(例えば、ディレクトリ)のフォーマットを使わないように
しなさい。もっと高水準の方法(`readdir')があるときは。

MSDOS、Windows、Macintosh、VMS、MVSのような、Unixに似てないシステムにつ
いて言うと、それらをサポートするのは普通しない方がいいぐらい大変な仕事だ。

計画されているGNUカーネルはまだ出来てないが、GNU Cライブラリのマニュアル
を見ることで、それが提供するであろう機能がどれなのか分かる。GNUカーネル
はMachに基づいているから、Machの機能も利用できるだろう。しかしながら、
Machの機能を使用すると、おそらくあなたのプログラムを今日デバッグする困難
に見舞われるだろう (1) (*Note System Portability-Footnotes::)。


File: standards-ja.info  Node: System Portability-Footnotes, Up: System Portability

(1) 訳注: 今日デバッグするってどういうこと？ 原文: However, if you use
Mach features, you'll probably have trouble debugging your program
today.



File: standards-ja.info, Node: CPU Portability, Next: System Functions, Prev: System Portability, Up: Writing C

CPU間の移植性
=============
GNUシステムでさえ、CPUタイプ間の違いのせいで異なってしまうだろう。--- 例
えば、バイト順序や境界の必要性の違いなどだ。こういう違うを扱うことは絶対
に不可欠だ。しかし、`int'が32ビットより小さい可能性を扱うために努力して
はいけない。GNUでは16ビットのマシンはサポートしない。

`int'オブジェクトのアドレスがまたその一番下のバイトのアドレスであるとみ
なしてはいけない。これはビッグ・エンディアンのマシンでは誤りだ。だから、
次の間違いをしてはいけない。

     int c;
     ...
     while ((c = getchar()) != EOF)
       write(file_descriptor, &c, 1);

関数を呼ぶとき、さまざまな型のポインタ間やポインタと整数間での違いを心配
する必要はない。ほとんどのマシンでは、いずれにせよ違いはない。違いのある
わずかなマシンについて言うと、それらの全てがANSI Cをサポートしているので、
それらのシステム上でそのコードが動くように、(ANSI Cでだけ使われるように
条件付けされた)プロトタイプを使うことができる。

ある場合には、整数とポインタの引数を無差別に同じ関数へ渡し、いかなるシス
テムでもプロトタイプを使わないでも構わない。例えば、多くのGNUプログラム
は`printf'やその類いに引数をどんどん渡すエラー報告関数を持っている。

     error (s, a1, a2, a3)
          char *s;
          int a1, a2, a3;
     {
       fprintf (stderr, "error: ");
       fprintf (stderr, s, a1, a2, a3);
     }

実際、これは全てのマシンで動作し、他の"正しい"やり方よりずっと単純だ。そ
のような関数に対してプロトタイプを使うことを*しない*ように。

しかしながら、本当に必要としているのでないなら、ポインタを整数にキャスト
しないようにしなさい。これらの仮定は実に移植性を減らしており、ほとんどの
プログラムでは簡単に避けられる。ポインタから整数にキャストすることが不可
欠な --アドレスだけでなく型情報をあるワードに収めるLispインタープリタ、
のような-- 場合には、そうして構わないが、異なるワードサイズを扱う明示的
な準備をしなくてはならないだろう。



File: standards-ja.info, Node: System Functions, Next: Internationalization, Prev: CPU Portability, Up: Writing C

システム関数の呼び出し
======================

Cの実装は十分に違う。ANSI Cは非互換性を減らすが、無くなりはしない。その
一方では、多くのユーザがGNUソフトウェアをANSI以前のコンパイラでコンパイ
ルしたがる。この章では、移植性を不必要に失くさないよう、標準Cライブラリ
関数をどれぐらいたくさん、あるいは、少なく使うか、推奨する方法を見せる。

   * `sprintf'の値を使ってはいけない。あるシステムでは書かれた文字の数を
     返し、すべてのシステムでそうだというわけではない。

   * `main'は`int'型を返すと宣言するべきだ。それは`exit'を呼ぶか、整数状
     態コードを返すことによって終了するべきだ。決して未定義の値を返すこ
     とができないようにしなさい。

   * システム関数を明示的に宣言してはならない。

     あるシステムでは、システム関数の宣言はほとんどが間違っている。衝突
     を最小化するために、システム関数を宣言するのをシステムのヘッダファ
     イルに任せなさい。もしヘッダが関数を宣言しなければ、宣言せずに置い
     ておきなさい。

     関数を宣言せずに使うのはきれいじゃないように見えるかもしれないが、
     実際にはこれが本当に起こるシステム上の、ほとんどのシステムライブラ
     リ関数に対して上手く働く。対照的に、現実の宣言は頻繁に現実の衝突を
     引き起こしている。

   * もしシステム関数を宣言しなければならないなら、引数の型を指定しては
     いけない。ANSIプロトタイプではなく、古い形式の宣言を使いなさい。関
     数を特定すればするほど、衝突しがちになる。

   * 特に、無条件に`malloc'や`realloc'を宣言してはいけない。

     ほとんどのGNUプログラムは、慣習的に`xmalloc'や`xrealloc'と名付けら
     れる関数の中で、たった一回だけそれらを使用する。これらの関数はそれ
     ぞれ`malloc'や`realloc'を呼び、結果を確認する。

     `xmalloc'や`xrealloc'はあなたのプログラムで定義されるので、型の衝突
     の危険性なしに他のファイルにそれらを宣言できる。

     ほとんどのシステム上で、`int'はポインタと同じ長さだ。それゆえ、
     `malloc'や`realloc'の呼び出しは上手く動く。数少ない例外的なシステム
     (ほとんどは64ビット・マシン)では、`malloc'や`realloc'の*条件付き*宣
     言を使うか、これらの宣言をそれらのシステムに特化した設定ファイルに
     置くことができる。

   * 文字列関数は特別な扱いが必要だ。いくつかのUnixシステムは`string.h' 
     というヘッダファイルを持っている。他では`strings.h'を持っている。どっ
     ちのファイル名も可搬性がない。できることは二つある。どっちのファイ
     ルをインクルードするかAutoconfで見付け出すか、どっちもインクルード
     しないかだ。

   * 文字列のファイルをどっちもインクルードしないなら、普通の方法ではヘッ
     ダファイルから文字列関数の宣言を得ることができない。

     このことは、あなたが思うよりも問題を起こさない。多くのシステムがま
     だサポートしていないので、いずれにせよ、新しいANSI文字列関数は避け
     るべきだ。使って良い文字列関数は次の通りだ。

          strcpy   strncpy   strcat   strncat
          strlen   strcmp    strncmp
          strchr   strrchr

     複製や連結の関数は、それらの値を使わない限り、宣言なしで上手く働く。
     宣言なしにそれらの値を使うと、ポインタの大きさが`int'の大きさと違う
     システムや、おそらく他の場合に失敗する。それらの値を使うのを避ける
     のはささいなことだから、そうしなさい。

     比較の関数や`strlen'は、ほとんどのシステムで、おそらくGNUソフトウェ
     アが動くすべてのシステムで、宣言なしに上手く働く。少数のシステムで*
     条件付きで*それらを宣言することが必要だと気付くかもしれない。

     検索関数は`char *'を返すと宣言されなければならない。幸運にも、それ
     らが返すデータ型には多様性がない。しかしそれらの名前には多様性があ
     る。あるシステムでは、それらの関数に`index'と`rindex'という名前を付
     けている。他のシステムでは、`strchr'と`strrchr'という名前を使う。あ
     るシステムは両方の名前をサポートするが、どっちも全てのシステムで働
     くわけではない。

     片方の組の名前を取り出し、プログラム中でそれを使うべきだ。(今日では、
     新しいプログラムには`strchr'と`strrchr'を選ぶのがより良い。それらは
     標準のANSI名だから。) それらの名前を両方とも`char *'を返す関数とし
     て宣言しなさい。それらの名前をサポートしないシステムでは、他方の組
     のことばをマクロとして定義しなさい。例えば、`strchr'と`strrchr'の名
     前を通して使いたいなら、ファイルの始め(あるいはヘッダに)次のように
     書いておく。

          #ifndef HAVE_STRCHR
          #define strchr index
          #endif
          #ifndef HAVE_STRRCHR
          #define strrchr rindex
          #endif

          char *strchr ();
          char *strrchr ();

ここでは、`HAVE_STRCHR'と`HAVE_STRRCHR'が対応する関数が存在するシステム
では定義されるマクロだとみなしている。それらを適切に定義する一つのやり方
はAutoconfを使うことだ。



File: standards-ja.info, Node: Internationalization, Next: Mmap, Prev: System Functions, Up: Writing C

国際化
======

GNUはあるプログラムのメッセージを様々な言語に翻訳するのを容易にするGNU
gettextと呼ばれるライブラリを持っている。あらゆるプログラムでこのライブ
ラリを使うべきだ。メッセージがプログラムに現れるとき、それらに英語を使い
なさい。そして、それらを他の言語に翻訳するための方法をgettextで提供しな
さい。

GNU gettextの使用は翻訳が必要かもしれない、それぞれの文字列の周りに
`gettext'マクロの呼び出しを付けることを含む --次のように。

     printf (gettext ("Processing file `%s'..."));

こうすると、GNU gettextが文字列`"Processing file `%s'..."'を翻訳されたバー
ジョンで置き換えられる。

一度プログラムがgettextを使うことになったら、翻訳が必要な新しい文字列を
加えるとき、`gettext'への呼び出しを書く地点を作ってください。

あるパッケージでのGNU gettextの使用は、そのパッケージに対して"テキスト領
域名"を指定することを含む。テキスト領域名はこのパッケージの翻訳を他のパッ
ケージの翻訳と分離するのに使われる。通常、テキスト領域名はパッケージの名
前と同じであるべきだ --例えば、GNU file utilityのために`fileutils'が使わ
れる。

gettextが上手く働くようにするために、単語や文の構造に仮定を設けるコード
を書かないようにしなさい。文の正確なテキストがデータによって変わるのよう
にしたいとき、条件付けられた単語や句を単一の文脈構成に押し込むよりも、そ
れぞれ完全な文を含む二つ以上の文字列定数を使いなさい。

これがやるべきではないものの例だ。

     printf ("%d file%s processed", nfiles,
             nfiles != 1 ? "s" : "");

この例の問題は複数形が`s'を加えることで行われると仮定していることだ。も
し書式文字列にgettextを適用するなら、次のように、メッセージが異なる単語
を使うことができるが、

     printf (gettext ("%d file%s processed"), nfiles,
             nfiles != 1 ? "s" : "");

複数形が`s'を使うようになお強制されている。これがより良い方法だ。

     printf ((nfiles != 1 ? "%d files processed"
              : "%d file processed"),
             nfiles);

このやり方で、二つの文字列それぞれに独立してgettextを適用できる。

     printf ((nfiles != 1 ? gettext ("%d files processed")
              : gettext ("%d file processed")),
             nfiles);

こうすると、"file"という単語の複数形を作る、いかなる方法でも実現でき、
"processed"に対して、単語が一致しないといけない言語を扱うこともできる。

同じような問題は次のコードで文脈の構造の水準で現れる。

     printf ("#  Implicit rule search has%s been done.\n",
             f->tried_implicit ? "" : " not");

このコードに`gettext'呼び出しを与えても、すべての言語で正しい結果を得ら
れるわけではない。なぜなら、いくつかの言語で否定は文中に一つよりもたくさ
んの場所で単語を加える必要があるからだ。対照的に、`gettext'呼び出しの追
加は、もしそのコードが次のように始まるなら、簡単に行える。

     printf (f->tried_implicit
             ? "#  Implicit rule search has been done.\n",
             : "#  Implicit rule search has not been done.\n");



File: standards-ja.info, Node: Mmap, Prev: Internationalization, Up: Writing C

Mmap
====

`mmap'がすべてのファイルに働くとも、すべてのファイルで失敗するとも、みな
してはいけない。一部のファイルでは上手く行き、他では駄目かもしれない。

`mmap'を使う適切な方法は、使いたい特定のファイルで試してみることだ。
---そして、もし`mmap'が働かなかったら、`read'や`write'を
使う他の方法で作業することに頼りなさい。

この用心が必要である理由はGNUカーネル(HURD)はユーザが拡張可能なファイル
システムを提供することで、そこではたくさんの異なる種類の"普通のファイル" 
があり得る。それらの多くは`mmap'をサポートするが、いくつかはしない。プロ
グラムをすべてのそういうファイルを扱えるようにすることは重要だ。



File: standards-ja.info, Node: Documentation, Next: Managing Releases, Prev: Writing C, Up: Top

プログラムの文書化
******************

* Menu:

* GNU Manuals::                 適切なマニュアルの執筆
* Manual Structure Details::    特定の構造の慣習
* NEWS File::                   NEWSファイル補足マニュアル
* Change Logs::                 変更の記録
* Man Pages::                   manページは二番目だ。
* Reading other Manuals::       どれほど他のマニュアルから学ぶことができるか。



File: standards-ja.info, Node: GNU Manuals, Next: Manual Structure Details, Prev: Documentation, Up: Documentation

GNUマニュアル
=============

GNUシステムの一部を文書にする好ましい方法はTexinfo整形言語でマニュアルを
書くことだ。Texinfoのマニュアルを、ハードコピーか、`info'やEmacsのInfoサ
ブシステム(`C-h i')を使って利用できるオンラインのバージョンで見なさい。

プログラマはしばしば、彼らが知っている実装の構造に従う文書を構成するのが
最も自然だと感じる。しかしこの構造はそのプログラムの使い方を説明するには
必ずしも良いとは言えない。それはユーザには関係がなく、ユーザを混乱させる
かもしれない。

段落の文から別々のマニュアルに論題を分類することまで、あらゆる水準で、文
書を構成する正しい方法は、それを読むときにユーザが心に抱くであろう概念や
疑問に従う。ときどきこの考えの構造は文書化されるソフトウェアの実装の構造
と一致する。---でもしばしばそれらは異なる。しばしば良い文書を執筆するた
めに学ぶ一番重要な部分は、実装のように文書を構成していて、もっと良い別の
構成について考えるときに気付くことを学ぶことだ。

例えば、GNUシステムのそれぞれのプログラムはおそらく一つのマニュアルに記
述されるべきだ。しかしこれはそれぞれのプログラムがそれ自身のマニュアルに
文書化されるべきであることを意味していない。このことはユーザが理解するの
を助ける構造よりもむしろ、その実装の構造に従っているだろう。

代わりに、それぞれのマニュアルは密接な*論題*を包含するべきだ。例えば、
`diff'のマニュアルと`diff3'のマニュアルの代わりに、`cmp'だけでなく、これ
らのプログラム両方も包含する、"ファイルの比較" のマニュアルが一つある。
それらのプログラムを一緒に文書にすることで、全体の主題をよりすっきりさせ
ることができる。

プログラムを論じるマニュアルはそのプログラムのコマンドライン・オプション
全てとそのコマンド全てを記述すべきだ。それはそれらの使用例を与えるべきだ。
しかしマニュアルを機能の列挙として構成してはならない。代わりに、副題によっ
て、論理的に構成しなさい。プログラムが行う仕事について考えるときにユーザ
が尋ねるであろう質問を提出しなさい。

概して、GNUマニュアルは指導書と参考書の両方に役に立つべきだ。それはInfo 
によりそれぞれの論題に対する便利な手段のために、そして(付録は別として)通
読するために作り上げられるべきだ。GNUマニュアルは始めから通して読む初心
者への良い紹介を行うべきで、ハッカーが欲しがる詳細のすべてを与えるべきで
もある。

そのことは最初に思われるほど難しくない。それぞれの章をその論題の論理的な
分類として整理しなさい。しかしその節を整頓して、それらのテキストを執筆し
なさい。その章を通読することが意味を為すように。その著書を章に構成すると
きや、節を段落に構成するとき、同様にしなさい。その標語は、*それぞれの地
点で、先行するテキストによって上げられた最も基本的で最も重要な話題を提出
しなさい*、だ。

必要なら、マニュアルの最初に、純粋に指導的で、主題の基礎を包含する、余分
な章を入れなさい。これらは初心者がマニュアルの残りを理解するための枠組み
を提供する。Bisonのマニュアルはこれの使い方の良い例を提供する。

GNUの文書を書き方の手本としてUnixのmanページを使ってはいけない。それらの
ほとんどは簡潔で、構成が悪く、根底にある概念について不適切な説明を与えて
いる。(もちろん例外はある。) またUnixのmanページはGNUマニュアルで使用す
るものとは異なる、特有の構成を使用する。

Unixの文書で使われる"pathname"という用語を使わないでください。代わりに
"file name"(二語)を使いなさい。"path"という用語は検索パスに対してのみ使
用し、それはファイル名のリストだ。

コンピュータ・プログラムへの間違った入力を表すのに、"illegal"という用語
を使わないでください。このためには"invalid"を使い、"illegal"という用語は
違法のために確保してください。



File: standards-ja.info, Node: Manual Structure Details, Next: NEWS File, Prev: GNU Manuals, Up: Documentation

マニュアルの構造の詳細
======================

マニュアルの表紙は、そのマニュアルで記述されるプログラムやパッケージのバー
ジョンを述べるべきだ。マニュアルの一番上の節もまたこの情報を含むべきだ。
もしマニュアルがプログラムより頻繁に、あるいは、無関係に変更されているな
ら、それらの場所の両方で、そのマニュアルのバージョン・ナンバーを記述しな
さい。

そのマニュアルで記述されるそれぞれのプログラムは、`PROGRAM Invocation'と
か`Invoking PROGRAM'と名付けられた節を持つべきだ。この節は(もしあれば、
その副節と共に)そのプログラムのコマンドラインの引数とそれの走らせ方(人々
がmanページで探し求める情報の類い)を記すべきだ。そのプログラムが使う、す
べてのオプションと引数のテンプレートを含む`@example'で始めなさい。

あるいは、項目の名前が上の様式の一つに合う表に項目を書きなさい。これは、
その節の本当の名前とは関係なしに、この目的のための節として、項目が指し示
す節を識別する (1) (*Note Manual Structure Details-Footnotes::)。

プログラム名を指定し、そのマニュアルのこれの部分だけを素早く読むための自
動的な機能があるだろう。

もし一つのマニュアルがいくつかのプログラムを記述するなら、それぞれのプロ
グラムを記述する節を持つべきだ。


File: standards-ja.info  Node: Manual Structure Details-Footnotes, Up: Manual Structure Details

(1) 訳注: 自分でも何書いてるのか意味不明。訂正乞う。原文: Alternatively,
put a menu item in some menu whose item name fits one of the above
patterns.  This identifies the node which that item points to as the
node for this purpose, regardless of the node's actual name.



File: standards-ja.info, Node: NEWS File, Next: Change Logs, Prev: Manual Structure Details, Up: Documentation

NEWSファイル
============

マニュアルに加えて、パッケージは言及するに値するユーザに見える変更の一覧
を含む`NEWS'と名付けられたファイルを持つべきだ。新しいリリース毎に、その
ファイルの前に項目を加え、それらが属するバージョンを同定しなさい。古い項
目を捨てないように。新しい項目の後へ、そのファイルの中に残しておきなさい。
こうして、以前のどのバージョンからアップグレードするユーザでも何が新しい
のかを見ることができる。

もし`NEWS'ファイルが非常に長くなれば、古い項目をいくらか`ONEWS'という名
前のファイルに移し、ユーザがそのファイルを参照するために最後に覚え書きを
書いておきなさい。



File: standards-ja.info, Node: Change Logs, Next: Man Pages, Prev: NEWS File, Up: Documentation

変更履歴
========

変更履歴にプログラムのソースファイルに行われた変更を全て記述し続けなさい。
これの目的は将来バグを発見する人々がそのバグを入れた変更が分かるようにす
ることだ。しばしば新しいバグは最近何が変わったのかを見ることで発見され得
る。さらに重要なことに、変更履歴は矛盾する概念がいかに起きそれらが誰に起
因するのかということについての履歴を与えてくれるので、プログラムの異なる
部分間での概念的な矛盾を失くすことに役立つことができるのだ。

* Menu:

* Change Log Concepts::         
* Style of Change Logs::        
* Simple Changes::              
* Conditional Changes::         



File: standards-ja.info, Node: Change Log Concepts, Next: Style of Change Logs, Prev: Change Logs, Up: Change Logs

変更履歴の概念
--------------

変更履歴を、もっと前のバージョンが現在のバージョンとどう違うかを説明する、
概念な"復元一覧表"として考えることができる。人々は現在のバージョンを見る
ことができる。彼らは何がその中にあるのかを言うのに変更履歴を必要としない。
変更履歴から欲しいものはもっと前のバージョンがどう違ったのかに関する、すっ
きりした説明だ。

変更履歴ファイルは通常`ChangeLog'と呼ばれ、ディレクトリ全体を包含する。
それぞれのディレクトリはそれ自身の変更履歴を持って良いし、あるディレクト
リはその親ディレクトリの変更履歴を使って良い。---それはあなたに任される。

他のやり方は変更履歴をRCSやCVSのようなバージョン管理システムで記録するこ
とだ。これは自動的に`ChangeLog'ファイルに変換される。

変更の目的全部やそれらが一緒にどう働くのかを記述する必要性はない。もし変
更が説明を必要とすると考えるなら、おそらくその通りだ。それを説明してくだ
さい。---しかしコードのコメントに説明を入れてください。そこは人々がその
コードを見るときはいつでも見るところだろう。例えば、関数を加えるとき、
"New function"は変更履歴には十分だ。なぜなら、それが何をするのか説明する
ために、関数定義の前にコメントがあるはずだからだ。

しかしながら、ときどき変更の組の全体の目的を記述する一行を書くのが有用だ。

`ChangeLog'に項目を加える一番簡単な方法はEmacsのコマンド、`M-x
add-change-log-entry'を使うことだ。項目はアスタリスク、変更されたファイ
ルの名前、そして変更された関数、変数、それ以外のものの名前を丸括弧の中に
含むべきだ。その後にコロンを付ける。そしてその関数や変数に行った変更を記
述しなさい。



File: standards-ja.info, Node: Style of Change Logs, Next: Simple Changes, Prev: Change Log Concepts, Up: Change Logs

変更履歴の形式
--------------

ここに変更履歴の項目の例をいくつか挙げる。

     * register.el (insert-register): Return nil.
     (jump-to-register): Likewise.

     * sort.el (sort-subr): Return nil.

     * tex-mode.el (tex-bibtex-file, tex-file, tex-region):
     Restart the tex shell if process is gone or stopped.
     (tex-shell-running): New function.

     * expr.c (store_one_arg): Round size up for move_block_to_reg.
     (expand_call): Round up when emitting USE insns.
     * stmt.c (assign_parms): Round size up for move_block_from_reg.

変更された関数や変数を略さずに名前を付けることが重要だ。関数や変数の名前
を略していけない。そして、それらをくっ付けてはいけない。その後の管理者は
しばしばある関数に属する変更履歴の項目を全部見付けるのに、関数名で検索す
るだろう。もしその名前を略していると、彼らは検索するときそれを見付けられ
ないだろう。

例えば、ある人々は`* register.el ({insert,jump-to}-register)'と書くこと
で、関数名の集まりを略する傾向がある。これは良くない考えだ。
`jump-to-register'や`insert-register'の検索はその項目を見付けないだろう
から。

無関係な変更履歴の項目を空行で分けなさい。二つの項目が一緒に働き、同じ変
更部分を表しているとき、それらの間に空行を入れてはいけない。そして、続い
ている項目が同じファイルにあるとき、そのファイル名とアスタリスクを省いて
良い。



File: standards-ja.info, Node: Simple Changes, Next: Conditional Changes, Prev: Style of Change Logs, Up: Change Logs

単純な変更
----------

ある単純な類いの変更は変更履歴にやたら詳細に記す必要はない。

単純なやり方で関数の呼び出し順序を変更し、その関数の呼び出し元を全て変更
するとき、変更した呼び出し元全てに個々の項目を作る必要はない。単に呼ばれ
る関数の項目に"All callers changed"と書きなさい。

     * keyboard.c (Fcommand_execute): New arg SPECIAL.
     All callers changed.

コメントや解説の文字列だけを変更するとき、関数に言及せずに、そのファイル
の項目を書けば十分だ。単なる"Doc fixes"だけで変更履歴には十分だ。

解説ファイルのための変更履歴の項目は作る必要はない。これは解説は直すのが
困難であるバグに影響しないからだ。解説は正確に設計されたやり方で相互作用
するに違いない部分から成り立っているわけではない。誤りを正すために、間違っ
た経過の履歴を知る必要はない。その解説が言っていることと、そのプログラム
が実際に働く方法を比較すれば十分だ。



File: standards-ja.info, Node: Conditional Changes, Prev: Simple Changes, Up: Change Logs

条件文の履歴
------------

Cのプログラムはしばしばコンパイル時の`#if'条件文を含む。たくさんの変更は
条件文だ。ときどき条件文に全体的に含まれている新しい定義を加える。変更履
歴にその変更が適用されるのがどれか条件を示すことは非常に役に立つ。

条件付きの変更を示す我々の慣習は条件の名前の周りに角括弧を使うことだ。

ここで、条件付きだが、それに付随する関数や実体の名前を持たない変更を記述
する、簡単な例を挙げる。

     * xterm.c [SOLARIS2]: Include string.h.

ここで全部条件付きである新しい定義を記述する項目を挙げる。
`FRAME_WINDOW_P'というマクロに対するこの新しい定義は`HAVE_X_WINDOWS'が定
義されているときだけ使われる。

     * frame.h [HAVE_X_WINDOWS] (FRAME_WINDOW_P): Macro defined.

ここに、全体として定義は無条件だが、変更自体は`#ifdef HAVE_LIBNCURSES'条
件に含まれる、`init_display'という関数内での変更に対する項目を挙げる。

     * dispnew.c (init_display) [HAVE_LIBNCURSES]: If X, call tgetent.

ここであるマクロが定義され*ない*ときだけ影響を持つ変更の項目を挙げる。

     (gethostname) [!HAVE_SOCKETS]: Replace with winsock version.



File: standards-ja.info, Node: Man Pages, Next: Reading other Manuals, Prev: Change Logs, Up: Documentation

manページ
=========

GNUプロジェクトでは、manページは副次的だ。あらゆるGNUプログラムがmanペー
ジを持つことは必要でないか期待されていない。しかし一部は持っている。あな
たのプログラムにmanページを含めるかどうかはあなたの選択である。

この決定をするとき、manページをサポートするにはそのプログラムが変更され
る時毎に継続的な努力が必要であることを考えなさい。そのmanページに費す時
間はもっと有用な作業から奪われる時間なのだ。

ほとんど変更しない簡単なプログラムでは、manページの更新はちょっとした作
業かもしれない。そして、もし持っていれば、manページを含めない理由はほと
んどない。

多量に変更する大きなプログラムでは、manページの更新は相当な重荷かもしれ
ない。もしユーザがmanページを寄付すると申し出たら、この贈り物は受け取る
のに高くつくと考えるかもしれない。同じ人がそれを維持する全責任を負うと合
意しなければ、そのmanページを拒否することがより良いかもしれない。---完全
にそれから手を洗えるように。もしこの有志が後にその作業をするのをやめたら、
自分でそれを取り上げなければならないと感じてはいけない。誰か他の人がその
manページを更新すると合意するまで、配布物からそれを引込めるのがより良い
かもしれない。

プログラムをほんの少ししか変更しないとき、manページは更新せずに役に立つ
状態に保たれるぐらい不一致は少ないと感じるかもしれない。そうなら、それを
維持しておらず、Texinfoマニュアルがもっと信頼できることを説明する目に付
く覚え書きをmanページの最初の方に書いておきなさい。その覚え書きはTexinfo 
文書を呼び出す方法を表すべきだ。



File: standards-ja.info, Node: Reading other Manuals, Prev: Man Pages, Up: Documentation

他のマニュアルを読む
====================

あなたが解説しているプログラムを記述する、自由でない書籍や解説ファイルが
あるかもしれない。

単に新しい代数の教科書の著者が代数に関する他の本を読むことができるように、
これらの文書を参考文献として使って構わない。どのノンフィクションの書籍の
大部分も事実から出来ていて、この場合、あるプログラムがどう動くかについて
の事実で、これらの事実はその主題で書いているすべての人にとって必ず同じで
ある。しかし、すでにある自由でない解説文から、あなたの概要の構成、言葉遣
い、表や例を複製しないように気を付けなさい。自由な解説文から複製すること
は構わないかもしれない。個々の場合についてFSFに確認してください。



File: standards-ja.info, Node: Managing Releases, Prev: Documentation, Up: Top

リリースの過程
**************

リリースを行うことは、単にあなたのソースファイルをtarファイルに束ねてFTP 
に置くだけ以上のことである。あなたのソフトウェアを様々なシステムで走るよ
うに設定できるように作り上げるべきだ。あなたのMakefileは以下で述べるGNU 
標準に従うべきだし、あなたのディレクトリ設計も以下で記述されるGNU標準に
従うべきだ。そうすることで、あなたのパッケージを全てのGNUソフトウェアの
より大きな骨組みに組み込むことが簡単になる。

* Menu:

* Configuration::               設定がいかに働くべきか
* Makefile Conventions::	Makefileの取り決め
* Releases::                    リリースを行う



File: standards-ja.info, Node: Configuration, Next: Releases, Prev: Managing Releases, Up: Managing Releases

設定がいかに働くべきか
======================

各GNU配布物は`configure'という名前のシェル・スクリプトと一緒に配られるべ
きだ。このスクリプトにはそのプログラムをコンパイルしたいマシンやシステム
の種類を表す引数を与えられる。

`configure'スクリプトはコンパイルに効果を与えられるように設定オプション
を記録しなければならない。

これを行う一つの方法は、`config.h'のような標準的な名前から、選んだシステ
ム用の適切な設定ファイルにリンクすることだ。これによって、人々はまず設定
しないとプログラムを構築できなくなるだろう。

`configure'が設定できる他の方法はMakefileを編集することだ。こうするなら、
配布物は`Makefile'と名付けらたファイルを含むべきでは*ない*。代わりに、編
集に使われる入力を含む`Makefile.in'というファイルを入れるべきだ。またも
う一度、これはまず設定をしてないとプログラムを構築できないようになるよう
にする。

もし`configure'が`Makefile'に書き込むなら、`Makefile'は、`configure'が再
び走り、最後に行ったのと同じ設定を作り上げる、`Makefile'と名付けられたター
ゲットを持つべきだ。`configure'が読むファイルは`Makefile'の依存関係とし
て列挙されているべきだ。

`configure'スクリプトからの出力であるファイルはすべて、それらが
`configure'を使って自動的に生成されたことを説明するコメントを先頭に持っ
ているべきだ。これによって、ユーザはそれらを手動で編集しようと考えなくな
るだろう。

`configure'スクリプトは、プログラムが最後に設定されたときに指定された設
定オプションを記述する、`config.status'という名前のファイルを書くべきで
ある。このファイルはもし走ると同じ設定を再生成するシェル・スクリプトであ
るべきだ。

`configure'スクリプトは、(もし現在のディレクトリでなければ)ソースが見付
かるディレクトリを指定するための`--srcdir=DIRNAME'という形式にオプション
を受け取るべきだ。こうすると、プログラムを別ディレクトリで構築することが
可能なり、実際のソース・ディレクトリは変更されないようにできる。

もしユーザが`--srcdir'を指定しなければ、`configure'はソースが見付かるか
どうか見るのに、`.'と`..'の両方を確認するべきだ。もしこれらの場所の一つ
でソースが見付かったら、そこからソースを使うべきだ。そうでなければ、ソー
スが見付けられないと報告し、ゼロでない状態で終了するべきだ。

普通`--srcdir'をサポートする簡単な方法はMakefileの`VPATH'の定義を編集す
ることによる。これを可能にするために、`configure'はMakefileに正確に指定
されたディレクトリの値を持つ`srcdir'という名前の変数を加えることができる。

`configure'スクリプトはまたそのプログラムを構築するシステムの種類を指定
する引数を受け取るべきである。この引数は次のようであるべきだ。

     CPU-COMPANY-SYSTEM

例えば、Sun 3は`m68k-sun-sunos4.1'だ。

`configure'スクリプトは、マシンを表す方法として、全てのもっともらしい他
の方法を解読できる必要がある。だから、`sun3-sunos4.1'は正しい別名だろう。
多くのプログラムでは、`vax-dec-ultrix'は`vax-dec-bsd'の別名だろう。単に
UltrixとBSDの違いはほとんど気付かない程度だからだが、少数のプログラムは
それらを区別する必要があるかもしれない。

サブルーチンとして使える、システムの種類を有効にし別名を正規化する、
`config.sub'と呼ばれるシェル・スクリプトがある。

他のオプションで、そのマシンにあるソフトウェアやハードウェアをもっと詳細
に指定して良いし、パッケージの付加的な部分を入れたり、外したりして良い。

`--enable-FEATURE[=PARAMETER]'
     FEATUREと呼ばれる付加的なユーザ水準の機能を構築しインストールするよ
     う、パッケージを設定する。これで、ユーザはどの付加的な機能を入れる
     か選択することができる。付加的なPARAMETERに`no'を与えれば、もしデフォ
     ルトでは構築されるなら、FEATUREを除くべきだ。

     どの`--enable'オプションも*決して*ある機能を他と置き換えるべきでは
     ない。どの`--enable'オプションも決してある有用な挙動を他の有用な挙
     動の代わりにするべきではない。`--enable'の唯一の適切な使用はそのプ
     ログラムの一部を構築するか除くかの質問に対してだけだ。

`--with-PACKAGE'
     パッケージPACKAGEがインストールされるだろうから、このパッケージが
     PACKAGEと一緒に働くように設定する。


     PACKAGEの可能な値には、`gnu-as'(あるいは`gas')、`gnu-ld'、
     `gnu-libc'、`gdb'、`x'、そして、`x-toolkit'がある。

     `--with'オプションをあるファイルを見付けるためにファイル名を指定す
     るのに使ってはいけない。こういう使い方は`--with'オプションの目的か
     ら外れている。

`--nfp'
     ターゲット・マシンは浮動小数点プロセッサを持っていない。

`--gas'
     ターゲット・マシンのアセンブラはGAS、つまり、GNUアセンブラである。
     これはもはや使われていない。ユーザは代わりに`--with-gnu-as'を使うべ
     きだ。

`--x'
     ターゲット・マシンはX Window Systemをインストールしている。これはも
     はや使われていない。ユーザは代わりに`--with-x'を使うべきだ。

全ての`configure'スクリプトはこれらの"詳細な"オプションをすべて受け入れ
るべきだ。それらが手もとの特定のパッケージに違いを作るかどうかにかかわら
ず。特に、それらは`--with-'や`--enable-'で始まるどんなオプションでも受け
入れるべきだ。これはユーザがオプション一組で一度にGNUソース・ツリー全体
を設定できるするためだ。

`--with-'や`--enable-'の部類が狭いことに気付くだろう。それらはあなたが考
えるようなオプションの類いに役目を果たさ*ない*。このことは計画的なのだ。
我々はGNUソフトウェアで可能な設定オプションを制限したいのだ。我々はGNUプ
ログラムに特異な設定オプションを持たせたくない。

コンパイルの過程の一部を行うパッケージはクロス・コンパイルをサポートする
かもしれない。そういう場合、そのプログラムのホストとターゲットのマシンは
異なるかもしれない。`configure'スクリプトは通常指定されたシステムの種類
がホストとターゲットの両方だとして扱うべきだ。こうして、それが走るのと同
じ種類のマシンで動くプログラムを作り出す。

クロス・コンパイラ、クロス・アセンブラ、あるいはあなたが持つどんなもので
も、構築する方法は、`configure'を走らせるときに`--host=HOSTTYPE'というオ
プションを指定する。これはターゲット・システムの種類を変えないでホスト・
システムを指定する。HOSTTYPE の文法は上で述べたのと同じである (1) (*Note
Configuration-Footnotes::)。

クロス・コンパイラを開始するには、それが走るホスト以外のマシンでコンパイ
ルすることが必要である。コンパイルされるパッケージは、あなたがそれらをコ
ンパイルするシステムがホストとは異なる場合、設定を指定するために、
`--build=HOSTTYPE'という設定オプションを受け取る (2) (*Note
Configuration-Footnotes::)。

クロス作業は意味がないプログラムは、`--host'オプションを受け取る必要はな
い。なぜなら、クロス作業のためにオペレーティング・システム全体を設定する
ことは意味のあることではないからだ。

プログラムの中には自動的に自分自身を設定する方法を持っているものがある。
あなたのプログラムがこうするように作られていると、あなたの`configure'ス
クリプトはその引数のほとんどを無視して良い。



File: standards-ja.info  Node: Configuration-Footnotes, Up: Configuration

(1) 訳注: 嘘八百。この場合、`--target=HOSTTYPE'を指定する。逆
にホストの方を変えるとターゲットも変わる。詳しくはAutoconfのマニュアルを
見よ。

(2) 訳注: 原文のitはいまいち何を意味しているのか分からないが、内容から推
測するに多分クロス・コンパイルされるパッケージかと思う。



File: standards-ja.info, Node: Makefile Conventions

Makefileの取り決め
==================

この節では、GNUプログラムのMakefileを執筆するための慣例について記述する。

* Menu:

* Makefile Basics::		Makefileの一般的な慣例
* Utilities in Makefiles::	Makefileのユーティリティ
* Command Variables::		コマンド指定の変数
* Directory Variables::		インストール命令の変数
* Standard Targets::		ユーザ用の標準的なターゲット
* Install Command Categories::  `インストール'規則のコマンドの三つの部類:
                                  normal、pre-install、そしてpost-install。



File: standards-ja.info, Node: Makefile Basics

Makefileの一般的な慣例
----------------------

あらゆるMakefileは次の行を含むべきだ。

     SHELL = /bin/sh

`SHELL'変数が環境から受け継がれるようなシステム上での問題を避けるために。
(これはGNU `make'では問題には決してならない。)

異なる`make'プログラムは互換性のない接尾辞のリストと暗黙の規則を持ち、こ
れはときどき混乱やおかしな挙動を生み出す。だから特定のMakefileで必要とす
る接尾辞だけを使用するのに、明示的に接尾辞のリストを設定するのは良い考え
だ。

     .SUFFIXES:
     .SUFFIXES: .c .o

最初の行は接尾辞のリストを処分し、二番目はこのMakefileで暗黙の規則の対象
になるかもしれない接尾辞すべてを導入する。

`.'がコマンド実行のパスに入っていると仮定してはいけない。makeの間にあな
たのパッケージの一部であるプログラムを走らせる必要があるとき、そのプログ
ラムがmakeの一部として構築されるなら`./'を使い、もしファイルがソース・コー
ドの変更されない部分なら、`$(srcdir)/'を使うようにしてください。これらの
接頭辞の一つを使わないと、現在の検索パスが使われる。

`./'("構築ディレクトリ")と`$(srcdir)/'("ソース・ディレクトリ")の区別は、
ユーザは`configure'に`--srcdir'オプションを使って別のディレクトリで構築
することができるので、重要である。次の書式の規則は構築ディレクトリがソー
ス・ディレクトリではないとき失敗する。`foo.man'と`sedscript'はソース・ディ
レクトリの中にあるからだ。

     foo.1 : foo.man sedscript
             sed -e sedscript foo.man > foo.1

@noindent

GNU `make'を使うとき、ソースファイルを見付けるのに`VPATH'を頼りにするこ
とは、単一の依存関係ファイルがある場合には上手く行くだろう。`make'の自動
変数`$<'は、ソースファイルがどこにあっても、それを表すから。(`make'のた
くさんのバージョンは暗黙的規則でだけ`$<' を設定する。)

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c bar.c -o foo.o

このようなMakefileのターゲットは代わりに次のように書かれるべきだ。

     foo.o : bar.c
             $(CC) -I. -I$(srcdir) $(CFLAGS) -c $< -o $@

`VPATH'が正しく働くようにするために。ターゲットが複数の依存関係を持つと
き、明示的な`$(srcdir)'を使うことがその規則を上手く働かせる一番簡単な方
法だ。例えば、`foo.1'に対するターゲットは次のように書かれてるのが一番良
い。

     foo.1 : foo.man sedscript
             sed -e $(srcdir)/sedscript $(srcdir)/foo.man > $@

GNUの配布物は普通ソースファイルではない、いくつかのファイルを含む。---例
えば、InfoファイルやAutoconf、Automake、BisonやFlexからの出力だ。これら
のファイルは通常ソース・ディレクトリに現れるので、それらは構築ディレクト
リではなく、常にソース・ディレクトリに現れるべきだ。だからそれらを更新す
るMakefileの規則はソース・ディレクトリに更新されたファイルを置くべきだ。

しかしながら、もしファイルが配布物に現れないなら、Makefileはソース・ディ
レクトリにそれを置くべきではない。なぜなら、普通の環境でプログラムを構築
することで、どんな方法でもソース・ディレクトリを変更するべきではないから
だ。

構築とインストールのターゲットを少なくとも(そしてそれらのサブターゲット
全てが)並列`make'で正しく働くように試みなさい。



File: standards-ja.info, Node: Utilities in Makefiles

Makefileのユーティリティ
------------------------

Makefileのコマンド(そして`configure'のようなシェル・スクリプト)を、`csh'
ではなく、`sh'で走るように書きなさい。`ksh'や`bash'の特別な機能を一切使っ
てはいけない。

`configure'スクリプトと構築とインストールのためのMakefileの規則は次のも
のを除いて、どんなユーティリティも直接使うべきではない。


     cat cmp cp diff echo egrep expr false grep install-info
     ln ls mkdir mv pwd rm rmdir sed sleep sort tar test touch true

圧縮プログラムの`gzip'は`dist'規則で使って良い。

これらのプログラムに対して、一般的にサポートされているオプションを守りな
さい。例えば、あったら便利な、`mkdir -p'はほとんどのシステムでサポートし
ていないので使ってはいけない。

少数のシステムではサポートしていないので、makefileではシンボリック・リン
クを作らないようにするのは良い考えだ。

構築とインストールのためのMakefileの規則はまたコンパイラや関連したプログ
ラムを使っていいが、ユーザが代わりのものと換えられるように`make'変数を通
して使うべきだ。我々が言っているプログラムをここでいくつか挙げる。

     ar bison cc flex install ld ldconfig lex
     make makeinfo ranlib texi2dvi yacc

これらのプログラムを走らせるのに次の`make'変数を使いなさい。

     $(AR) $(BISON) $(CC) $(FLEX) $(INSTALL) $(LD) $(LDCONFIG) $(LEX)
     $(MAKE) $(MAKEINFO) $(RANLIB) $(TEXI2DVI) $(YACC)

`ranlib'や`ldconfig'を使うとき、システムが当のプログラムを持っていなくて
も悪いことが何も起きないようにするべきだ。そのコマンドからのエラーを無視
するように調整し、そのコマンドの前にユーザにこのコマンドの失敗が問題では
ないことを伝えるメッセージを出力しなさい。(Autoconfの`AC_PROG_RANLIB'マ
クロはこれを助けることができる。)

もしシンボリック・リンクを使うなら、シンボリック・リンクを持たないシステ
ム用に別手段を実装するべきだ。

Make変数を通して使って良い別のユーティリティには次のものがある。

     chgrp chmod chown mknod

他のユーティリティを使うことは、あなたがそれらのユーティリティが存在する
と知っている特定のシステムのためだけに、Makefileの一部(やスクリプト)が意
図されているなら使って良い。



File: standards-ja.info, Node: Command Variables

コマンド指定の変数
------------------

Makefileはあるコマンドやオプションなどを上書きするために変数を提供するべ
きだ。

とりわけ、ほとんどのユーティリティ・プログラムを変数を通して走らせるべき
だ。だから、もしBisonを使うなら、`BISON'と名付けられた、そのデフォルトの
値が`BISON = bison'と設定されている変数を持ち、Bisonを使う必要があるとき
にはいつでも`$(BISON)'を使ってそれを参照しなさい。

`ln'、`rm'、`mv'などなどのようなファイル管理ユーティリティはこのやり方の
変数を通した参照をする必要はない。ユーザはそれらを他のプログラムと置き換
える必要がないので。

それぞれのプログラム名変数は、プログラムにオプションを与えるのに使われる
オプション変数と一緒に使われるべきだ。オプション変数の名前を得るのにプロ
グラム名変数の名前に`FLAGS'を付け加えなさい。---例えば、`BISONFLAGS'のよ
うに。(Cコンパイラに対する`CFLAGS'、yaccに対する`YFLAGS'、lexに対する
`LFLAGS'の名前はこの規則には例外的だが、我々はそれらは標準的なのでそうし
ておく。) プリプロセッサを走らせるどのコンパイルのコマンドでも`CPPFLAGS'
を使い、`ld'の直接的な使用だけではなく、リンクを行うどのコンパイルのコマ
ンドでも`LDFLAGS'を使いなさい。

もしあるファイルの適切なコンパイルに使われ*なければならない*Cコンパイラ
のオプションがあれば、`CFLAGS'にそれらを入れてはいけない。ユーザは
`CFLAGS'を自分で自由に指定できると期待する。代わりに、`CFLAGS'とは独立に
必要なオプションをCコンパイラに渡すように調整しなさい。次のように、それ
らを明示的にコンパイルのコマンドに書くか、暗黙の規則を定義することによっ
て。

     CFLAGS = -g
     ALL_CFLAGS = -I. $(CFLAGS)
     .c.o:
             $(CC) -c $(CPPFLAGS) $(ALL_CFLAGS) $<

`-g'オプションを`CFLAGS'に入れなさい。なぜなら、それは適切なコンパイルに
は*必要*ではないからだ。それを単に推奨されるデフォルトであると考えること
ができる。もしパッケージがデフォルトでGCCでコンパイルされるように設定さ
れているなら、`CFLAGS'のデフォルトの値に`-O'も入れてもいい。

ユーザが他を上書きするのに`CFLAGS'を使うことができるので、`CFLAGS'をコン
パイルのコマンドの最後、コンパイラのオプションを含む他の変数の後に置きな
さい。

`CFLAGS'は、コンパイルを行うのとリンクを行う両方の、Cコンパイラのあらゆ
る起動で使われるべきだ。

あらゆるMakefileは`INSTALL'という変数を定義するべきで、それはファイルを
システムにインストールするための基本的なコマンドである。

あらゆるMakefileはまた`INSTALL_PROGRAM'と`INSTALL_DATA'という変数を定義
するべきだ。(これらは各々デフォルトは`$(INSTALL)'であるべきだ。) そして、
これらの変数を実際のインストールのコマンドとして、それぞれ実行ファイルと
実行ファイルでないものに対して使うべきだ。これらの変数は次のように使いな
さい。

     $(INSTALL_PROGRAM) foo $(bindir)/foo
     $(INSTALL_DATA) libfoo.a $(libdir)/libfoo.a

インストールのコマンドの二番目の引数として、ディレクトリ名ではなく、常に
ファイル名を使いなさい。インストールされるそれぞれのファイルに対して、別々
のコマンドを使いなさい。



File: standards-ja.info, Node: Directory Variables

インストール命令の変数
----------------------

インストール命令は常に変数によって名前が付けられているべきだ。だから、標
準的でない場所にインストールするのは簡単である。これらの変数の標準的な名
前は以下で述べる。それらは標準的なファイルシステムの構造に基いている。そ
れに似たものがSVR4、4.4BSD、Linux、Ultrix v4や他の現代的なオペレーティン
グ・システムで使われている。

これらの二つの変数はインストールのためのルートを設定する。他のインストー
ル命令はすべてこれら二つのうちの一つのサブディレクトリであるべきで、これ
ら二つのディレクトリへ直接インストールされるものがあるべきではない。

`prefix'
     以下で列挙する変数のデフォルトの値を作るのに使われる接頭辞。
     `prefix'のデフォルトの値は`/usr/local'であるべきだ。完全なGNU シス
     テムを構築するとき、接頭辞は空で、`/usr'は`/'へのシンボリック・リン
     クになるだろう。(もしAutoconfを使っているなら、それを`@prefix@'と書
     きなさい。)

`exec_prefix'
     以下で列挙する変数の一部のデフォルトの値を作るのに使われる接頭辞。
     `exec_prefix'のデフォルトの値は`$(prefix)'であるべきだ。(もし
     Autoconfを使っているなら、それを`@exec_prefix@'と書きなさい。)

     一般的に、`$(exec_prefix)'は(実行ファイルやサブルーチン・ライブラリ
     のような)マシンに特定のファイルを含むディレクトリに対して使われるが、
     `$(prefix)'は他のディレクトリに対して直接使われる。

実行プログラムは以下のディレクトリの一つにインストールされる。

`bindir'
     ユーザが走らせることができる実行プログラムをインストールするための
     ディレクトリ。これは普通`/usr/local/bin'であるべきだが、それを
     `$(exec_prefix)/bin'と書きなさい。(もしAutoconfを使っているなら、そ
     れを`@bindir@'と書きなさい。)

`sbindir'
     シェルから走らせることができるが、普通はシステム管理者にだけ有用な
     実行プログラムをインストールするためのディレクトリ。これは通常
     `/usr/local/sbin'であるべきだが、それを`$(exec_prefix)/sbin'と書き
     なさい。(もしAutoconfを使っているなら、それを`@sbindir@'と書きなさ
     い。)

`libexecdir'
     ユーザよりも他のプログラムに実行されるための実行プログラムをインス
     トールするためのディレクトリ。このディレクトリは通常
     `/usr/local/libexec' であるべきだが、それを`$(exec_prefix)/libexec'
     と書きなさい。(もしAutoconfを使っているなら、それを`@libexecdir@'と
     書きなさい。)

実行中にプログラムによって使われるデータ・ファイルは二つの方法の部類に分
けられる。

   * 一部のファイルは普通プログラムによって変更される。他のものは普通絶
     対に変更されない(ユーザはこれらのうち一部を編集するかもしれないけど)。

   * 一部のファイルはアーキテクチャに依存しておらず、あるサイトの全ての
     マシンに共有されうる。一部はアーキテクチャ依存で、同じ種類のマシン
     やオペレーティング・システムによってのみ共有されうる。他のものは二
     つのマシン間で決して共有できないかもしれない。

これは6つの異なる可能性をもたらす。しかしながら、我々は、オブジェクト・
ファイルやライブラリは別にして、アーキテクチャ依存のファイルの使用をやめ
させたい。他のデータ・ファイルをアーキテクチャ非依存にすることはずっとき
れいで、普通は困難ではない。

それゆえ、ここにMakefileがディレクトリを指定するのに使うべき変数を挙げる。

`datadir'
     読み込みだけのアーキテクチャに依存しないデータ・ファイルをインストー
     ルするためのディレクトリ。これは通常`/usr/local/share'であるべきだ
     が、それを`$(prefix)/share'と書きなさい。(もしAutoconfを使っている
     なら、それを`@datadir@'と書きなさい。) 特別な例外として、以下の
     `$(infodir)'と`$(includedir)'を見なさい。

`sysconfdir'
     一つのマシンに属する読み込みだけのデータ・ファイル--つまり、ホスト
     を設定するためのファイル、をインストールするためのディレクトリ。メ
     イラーやネットワークの設定ファイル、`/etc/passwd'などはここに属する。
     このディレクトリの全てのファイルは普通のASCIIテキスト・ファイルであ
     るべきだ。このディレクトリは普通`/usr/local/etc'だが、それを
     `$(prefix)/etc' と書きなさい。(もしAutoconfを使っているなら、それを
     `@sysconfdir@' と書きなさい。)

     このディレクトリに実行ファイルをインストールしてはいけない(それらお
     そらく`$(libexecdir)'か`$(sbindir)'に属する)。また、普通の方針で使っ
     ているときに変更するファイルはインストールしてはいけない(システムの
     設定を変更するための目的のプログラムは除く)。それらはおそらく
     `$(localstatedir)'に属する。

`sharedstatedir'
     アーキテクチャに依存しない、プログラムが走る間に変更するデータ・ファ
     イルをインストールするためのディレクトリ。これは普通
     `/usr/local/com'であるべきだが、それを`$(prefix)/com'と書きなさい。
     (もしAutoconfを使っているなら、それを`@sharedstatedir@'と書きなさい。)

`localstatedir'
     プログラムが走る間に変更し、特定のマシンに属しているデータ・ファイ
     ルをインストールするためのディレクトリ。ユーザは、パッケージの操作
     を設定するために、このディレクトリにあるファイルを変更する必要が決
     してあるべきではない。そのような設定情報は`$(datadir)'や
     `$(sysconfdir)'に入る別のファイルに置きなさい。`$(localstatedir)'は
     通常`/usr/local/var'であるべきだが、それを`$(prefix)/var'と書きなさ
     い。(もしAutoconfを使っているなら、それを`@localstatedir@'と書きな
     さい。)

`libdir'
     オブジェクト・ファイルやオブジェクト・コードのライブラリのためのディ
     レクトリ。ここに実行ファイルをインストールしてはいけない。それらは
     おそらく代わりに`$(libexecdir)'に入るべきだ。`libdir'の値は普通
     `/usr/local/lib'だが、それを`$(exec_prefix)/lib'と書きなさい。(もし
     Autoconfを使っているなら、それを`@libdir@'と書きなさい。)

`infodir'
     このパッケージのInfoファイルをインストールするためのディレクトリ。
     デフォルトでは、それは`/usr/local/info'であるべきだが、それは
     `$(prefix)/info'と書かれるべきだ。(もしAutoconfを使っているなら、そ
     れを`@infodir@'と書きなさい。)

`lispdir'
     このパッケージのどんなEmacs Lispファイルでもインストールためのディ
     レクトリ。デフォルトでは、それは`/usr/local/share/emacs/site-lisp'
     であるべきだが、それは`$(prefix)/share/emacs/site-lisp'と書かれるべ
     きだ。

     もしAutoconfを使っているなら、デフォルトを`@lispdir@'と書きなさい。
     `@lispdir@'が働くようにするために、`configure.in'ファイルに以下の行
     が必要である。

          lispdir='${datadir}/emacs/site-lisp'
          AC_SUBST(lispdir)

`includedir'
     Cの`#include'プリプロセッサ命令でユーザ・プログラムによってインクルー
     ドされるヘッダ・ファイルをインストールするためのディレクトリ。これ
     は通常`/usr/local/include'であるべきだが、それを`$(prefix)/include' 
     と書きなさい。(もしAutoconfを使っているなら、それを`@includedir@' 
     と書きなさい。)

     GCC以外のほとんどのコンパイラは`/usr/local/include'ディレクトリのヘッ
     ダ・ファイルを探さない。だからこの方法でヘッダ・ファイルをインストー
     ルすることはGCCにだけ役に立つ。一部のライブラリはGCCで働くことだけ
     を本当に意図しているので、これは時には問題ではない。しかし一部のラ
     イブラリは他のコンパイラと働くことを意図している。それらはヘッダ・
     ファイルを二つの場所、`includedir'に指定されるところと
     `oldincludedir'に指定されるところにインストールするべきだ。

`oldincludedir'
     GCC以外のコンパイラで使われるための`#include'ヘッダ・ファイルをイン
     ストールするためのディレクトリ。これは通常`/usr/include'であるべき
     だ。(もしAutoconfを使っているなら、それを`@oldincludedir@'と書くこ
     とができる。)

     Makefileのコマンドは`oldincludedir'の値が空かどうか確認すべきだ。も
     しそうなら、それを使おうとするべきではない。ヘッダ・ファイルの二番
     目のインストールを取りやめるべきだ。

     パッケージはこのディレクトリにすでにあるヘッダを、そのヘッダが同じ
     パッケージに由来しているのでないなら、置き換えるべきではない。だか
     ら、もしあなたのFooパッケージがヘッダ・ファイルの`foo.h'を提供する
     なら、もし、(1)`foo.h'がないか、(2)すでにある`foo.h'がFooパッケージ
     由来か、のどちらかなら、`oldincludedir'ディレクトリにそのヘッダ・ファ
     イルをインストールするべきだ。

     `foo.h'がFooパッケージ由来かどうかを見分けるために、そのファイルに
     魔法の文字列--コメントの一部--を置き、その文字列を`grep'しなさい。

Unix形式のmanページは次のうちの一つにインストールされる。

`mandir'
     このパッケージの(あれば)manページをインストールするための一番上のディ
     レクトリ。それは普通`/usr/local/man'だろう。しかしそれを
     `$(prefix)/man'と書くべきだ。(もしAutoconfを使っているなら、それを
     `@mandir@'と書きなさい。)

`man1dir'
     セクション1のmanページをインストールするためのディレクトリ。それを
     `$(mandir)/man1'と書きなさい。
`man2dir'
     セクション2のmanページをインストールするためのディレクトリ。それを
     `$(mandir)/man2'と書きなさい。
`...'

     *どんなGNUソフトウェアの主要な解説書もmanページにしてはならない。代
     わりにTexinfoでマニュアルを書きなさい。manページは単にUnix上でGNUソ
     フトウェアを走らせる人々のためだけで、それは副次的なアプリケーショ
     ンだけだ。*

`manext'
     インストールされるmanページのファイル名拡張子。これは適切な数字が続
     くピリオドを含むべきだ。それは普通`.1'であるべきだ。

`man1ext'
     セクション1にインストールされるmanページのためのファイル名拡張子。
`man2ext'
     セクション2にインストールされるmanページのためのファイル名拡張子。
`...'
     もしパッケージがマニュアルの2以上にmanページをインストールする必要
     があるなら、これらの名前を`manext'の代わりに使いなさい。

そして最後に、以下の変数を設定するべきだ。

`srcdir'
     コンパイルされるソースのディレクトリ。この変数の値は通常`configure' 
     シェル・スクリプトによって挿入される。(もしAutoconfを使っているなら、
     `srcdir = @srcdir@'を使いなさい。)

例。

     # Common prefix for installation directories.
     # NOTE: This directory must exist when you start the install.
     prefix = /usr/local
     exec_prefix = $(prefix)
     # Where to put the executable for the command `gcc'.
     bindir = $(exec_prefix)/bin
     # Where to put the directories used by the compiler.
     libexecdir = $(exec_prefix)/libexec
     # Where to put the Info files.
     infodir = $(prefix)/info

もしあなたのプログラムが標準的なユーザ指定のディレクトリに、非常にたくさ
んのファイルをインストールするなら、このプログラムに特定のサブディレクト
リにそれらをまとめると有用かもしれない。もしこうするなら、これらのサブディ
レクトリを作るための`install'規則を書くべきだ。

上に挙げたどの変数の値にも、ユーザがサブディレクトリの名前を含めると期待
してはいけない。インストール・ディレクトリのための変数名の一組を持つとい
う考えは、ユーザがいくつかの異なるGNUパッケージに正確に同じ値を指定でき
るようにすることである。これを有用なものとするために、あらゆるパッケージ
はユーザがそうするときに賢く働くように設計されなければならない。



File: standards-ja.info, Node: Standard Targets

ユーザ用の標準的なターゲット
----------------------------

全てのGNUプログラムはそれらのMakefileに以下のターゲットを持つべきだ。

`all'
     プログラム全体をコンパイルする。これはデフォルトのターゲットである
     べきだ。このターゲットはどの解説ファイルも再構築しなくて良い。Info
     ファイルは通常配布物の中に含まれるべきで、DVIファイルは明示的に要求
     されたときにのみ作られるべきだ。

     デフォルトでは、Makeの規則は`-g'付きでコンパイルしリンクするべきだ。
     こうして実行プログラムはデバッグのシンボルを持つ。無力なことを気に
     しないユーザは、彼らが望むなら、その実行ファイルを後でstripすること
     ができる。

`install'
     プログラムをコンパイルし、実行ファイル、ライブラリなどを、それらが
     実際に使われるべきファイル名に複製する。もしプログラムが適切にイン
     ストールされたことを確かめるための簡単な試験があるなら、このターゲッ
     トはその試験を走らせるべきだ。

     実行ファイルをインストールするときにstripしてはいけない。向こう見ず
     なユーザはそうするために`install-strip'ターゲットを使うことができる。

     もし可能なら、`make all'が終わっていたら、そのプログラムが構築され
     たディレクトリのどんなものも変更しないように`install'ターゲットの規
     則を書きなさい。これはあるユーザ名でプログラムを構築し、他のユーザ
     名でそれをインストールするのに便利である。

     そのコマンドはファイルがインストールされるディレクトリを、もしまだ
     なかったら、全て作成するべきである。これは必要とされるサブディレク
     トリ全てだけでなく、変数`prefix'や`exec_prefix'の値で指定されるディ
     レクトリも含む。これを行う一つの方法は以下で述べるような
     `installdirs'ターゲットを使うことによる。

     manページをインストールためのどんなコマンドの前にも、`make'がどんな
     エラーも無視するように、`-'を使いなさい。これはUnixのmanページ解説
     システムがインストールされてないシステムの場合である。

     Infoファイルをインストールする方法は、それらを`$(INSTALL_DATA)'
     (*Note Command Variables::)で`$(infodir)'に複製することで、もしあれ
     ば、`install-info'プログラムを走らせる。`install-info'は与えられた
     Infoファイルのメニュー項目を加えたり更新したりするためにInfoの`dir'
     ファイルを編集するプログラムである。それはTexinfoパッケージの一部だ。
     ここでInfoファイルをインストールする見本の規則を挙げる。

          $(infodir)/foo.info: foo.info
                  $(POST_INSTALL)
          # There may be a newer info file in . than in srcdir.
                  -if test -f foo.info; then d=.; \
                   else d=$(srcdir); fi; \
                  $(INSTALL_DATA) $$d/foo.info $@; \
          # Run install-info only if it exists.
          # Use `if' instead of just prepending `-' to the
          # line so we notice real errors from install-info.
          # We use `$(SHELL) -c' because some shells do not
          # fail gracefully when there is an unknown command.
                  if $(SHELL) -c 'install-info --version' \
                     >/dev/null 2>&1; then \
                    install-info --dir-file=$(infodir)/dir \
                                 $(infodir)/foo.info; \
                  else true; fi

     `install'ターゲットを書くとき、三つの部類に全てのコマンドを分類しな
     ければならない。普通のものと、"pre-installation"コマンドと
     "post-installation"コマンドだ。*Note Install Command Categories::。

`uninstall'
     インストールされたファイル---`install'ターゲットが作る複製--を全て
     削除する。

     この規則はコンパイルが行われたディレクトリを変更せず、ファイルがイ
     ンストールされるディレクトリだけを変更するべきだ。

     アンインストールのコマンドはインストールのコマンドと同様、三つの部
     類に分けられる。*Note Install Command Categories::。

`install-strip'
     `install'に似ているが、実行ファイルをインストールする間にそれらを
     stripする。多くの場合、このターゲットの定義は非常に単純で良い。

          install-strip:
                  $(MAKE) INSTALL_PROGRAM='$(INSTALL_PROGRAM) -s' \
                          install

     通常我々は、あなたがそのプログラムにバグがないと確信しているのでな
     いなら、実行ファイルをstripすることを推奨しない。しかしながら、バグ
     がある場合用にstripしていない実行ファイルを別のところに保存して、実
     際の実行用にstrip された実行ファイルをインストールすることは理に適っ
     ていることもあり得る。

`clean'

     現在のディレクトリから、普通プログラムを構築することによって作られ
     た全てのファイルを削除する。設定を記録するファイルは削除してはいけ
     ない。また、構築によって作ることができても、配布物から手に入るので
     普通は作らないファイルは残しておきなさい。

     もし配布物の一部でないなら、`.dvi'ファイルは削除しなさい。

`distclean'
     現在のディレクトリから、プログラムを設定したり、構築することによっ
     て作られた全てのファイルを削除する。もしソースを展開し、他のファイ
     ルを作らずにプログラムを構築しているなら、`make distclean'は配布物
     にあったファイルだけを残すべきである。

`mostlyclean'
     `clean'に似ているが、人々が通常再びコンパイルしたいとは思わない、少
     数のファイルは削除してなくて良い。例えば、GCCの`mostlyclean'ターゲッ
     トは`libgcc.a'を削除しない。なぜなら、それを再びコンパイルすること
     は滅多に必要でなく、長い時間がかかるからだ。

`maintainer-clean'
     現在のディレクトリから、このMakefileで復元され得る、ほとんど全てを
     削除する。これは典型的には`distclean'によって削除される全てのものと、
     さらに、Bisonによって生み出されたCのソース・ファイル、タグの表、
     Infoファイルなどなどを含む。

     "ほとんど全て"と言う理由は、コマンド`make maintainer-clean'を走らせ
     ることで、例え`configure'はMakefileの規則を使って再生できたとしても、
     `configure'を削除するべきでないということだ。もっと一般的に、`make
     maintainer-clean'は`configure'を走らせるために、そしてプログラムを
     構築し始めるために存在する必要があるどんなものも削除するべきではな
     い。これが唯一の例外だ。`maintainer-clean'は再構築される得る他のも
     のは全て削除するべきだ。

     `maintainer-clean'ターゲットは、普通のユーザではなく、そのパッケー
     ジの管理者によって使われることが意図されている。`make
     maintainer-clean'が削除するファイルの一部を復元するために、特別なツー
     ルを必要とするかもしれない。これらのファイルは普通配布物に含められ
     るので、それらが簡単に復元することは気にしない。もし全配布物を再び
     展開する必要があることを見出しても、我々を非難してはいけない。

     ユーザがこれに気付くのを助けるために、特別な`maintainer-clean'ター
     ゲットのためのコマンドはこれら二つで始まるべきだ。

          @echo 'This command is intended for maintainers to use; it'
          @echo 'deletes files that may need special tools to rebuild.'

`TAGS'
     このプログラムのタグ表を更新する。

`info'
     必要とされるどのInfoファイルでも生成する。規則を書く最善の方法は次
     のようだ。

          info: foo.info

          foo.info: foo.texi chap1.texi chap2.texi
                  $(MAKEINFO) $(srcdir)/foo.texi

     Makefileに`MAKEINFO'という変数を定義してなければならない。それは
     `makeinfo'プログラムを走らせるべきで、それはTexinfo配布物の一部であ
     る。

     普通、GNU配布物はInfoファイルと一緒に手に入り、このことはInfoファイ
     ルがソース・ディレクトリにあることを意味する。それゆえ、infoファイ
     ルのためのMakeの規則はソース・ディレクトリでそれを更新するべきだ。
     ユーザがそのパッケージを構築するとき、普通のMakeはInfoファイルを更
     新しないだろう。なぜなら、それらはすでに最新だろうから。

`dvi'
     Texinfo解説書全てのDVIファイルを生成する。例えば、

          dvi: foo.dvi

          foo.dvi: foo.texi chap1.texi chap2.texi
                  $(TEXI2DVI) $(srcdir)/foo.texi

     Makefileに`TEXI2DVI'という変数を定義してなければならない。それは
     `texi2dvi'というプログラムを走らせるべきで、それはTexinfo配布物の一
     部である。 (1) (*Note Standard Targets-Footnotes::) あるいは、単に
     依存関係だけを書き、GNU `make'がそのコマンドを提供できるようにしな
     さい。

`dist'
     このプログラムの配布用tarファイルを作成する。tarファイルは、そのtar
     ファイルの中のファイル名が配布されるパッケージの名前のサブディレク
     トリ名で始まるように作り上げられるべきだ。この名前はバージョン・ナ
     ンバーを含んで良い。

     例えば、GCCのバージョン1.40の配布用tarファイルは`gcc-1.40'と名付け
     られたサブディレクトリに展開する。

     これを行う一番簡単な方法は適切に名付けられたサブディレクトリを作り、
     `ln'か`cp'でそれに適当なファイルをインストールし、そのサブディレク
     トリに`tar'することである。

     そのtarファイルを`gzip'で圧縮しなさい。例えば、GCCのバージョン1.40 
     の実際の配布ファイルは`gcc-1.40.tar.gz'と名付けられている。

     配布物にあるソースではないファイル全てを配布物中で最新にしておくた
     めに、`dist'ターゲットは明示的にそれらに依存すべきだ。*Note Making
     Releases: Releases.

`check'
     (もしあれば)自己診断を行う。ユーザはその試験を走らせる前にプログラ
     ムを構築しなければならないが、そのプログラムをインストールする必要
     はない。そのプログラムが構築されているがインストールされていないと
     きに働くように自己診断を書くべきである。

以下のターゲットは、それらが有用であるプログラムに対して、慣習的な名前を
提案している。

`installcheck'
     (もしあれば)インストールの診断を行う。ユーザはその試験を走らせる前
     にそのプログラムを構築しインストールしなければならない。`$(bindir)'
     が検索パスにあると仮定するべきではない。

`installdirs'
     ファイルがインストールされるディレクトリとそれらの親ディレクトリを
     作成するために、`installdirs'という名前のターゲットを加えると役に立
     つ。このために便利である`mkinstalldirs'と名付けられたスクリプトがあ
     る。それはTexinfoパッケージの中で見付けることができる。このような規
     則を使うことができる。

          # Make sure all installation directories (e.g. $(bindir))
          # actually exist by making them if necessary.
          installdirs: mkinstalldirs
                  $(srcdir)/mkinstalldirs $(bindir) $(datadir) \
                                          $(libdir) $(infodir) \
                                          $(mandir)

     この規則はコンパイルがなされるディレクトリを変更するべきではない。
     インストール用のディレクトリを作成する以外に何もするべきではない。


File: standards-ja.info  Node: Standard Targets-Footnotes, Up: Standard Targets

(1) `texi2dvi'は整形の実際の作業を行うためにTeX を使用する。
TeXはTexinfoと一緒配布されていない。



File: standards-ja.info, Node: Install Command Categories

インストールのコマンドの部類
----------------------------

`install'ターゲットを書くとき、三つの部類にそのコマンド全てを分類しなけ
ればならない。普通のものと、"pre-installation"コマンドと、
"post-installation"コマンドに。

普通のコマンドは適切な場所にファイルを移動し、それらのモードを設定する。
それらはどんなファイルも、完全にそれらが属するパッケージから手に入るもの
を除いて、変化させないのが良い。

pre-installationとpost-installationのコマンドは他のファイルを変えても良
い。特に、それらは大域的な設定ファイルやデータベースを編集して良い。

pre-installationコマンドは典型的には普通のコマンドの前に実行され、
post-installationコマンドは典型的には普通のコマンドの後に走らされる。

post-installationコマンドの最も普通の利用は`install-info'を走らせること
である。これは普通のコマンドでは行われ得ない。それは、完全には、そしてイ
ンストールされるパッケージだけからは手に入らないファイル(Infoディレクト
リ)を変化させる。それはパッケージのInfoファイルをインストールする普通の
コマンドの後に行われる必要があるのでpost-installationコマンドである。

ほとんどのプログラムはpre-installationコマンドを必要としないが、我々はそ
れが必要とされる場合にだけその機能を持つ。

`install'規則のコマンドをこれら三つの部類に分類するために、それらの中に"
部類行"を挿入しなさい。部類行は次のコマンドの部類を指定する。

部類行はタブと特別なMake変数への参照に加えて、最後に付加的なコメントから
成る。それぞれの部類に対して一つ、使うことができる三つの変数がある。変数
名は部類を指定する。部類行は、これら三つのMake変数は普通未定義(そして、
それらをmakefileで定義する*べきではない*)ので、普通の実行では何も行わな
い。

ここで、それぞれそれが何を意味するのか説明するコメントと共に、その三つの
あり得る部類行を挙げる。

             $(PRE_INSTALL)     # Pre-install commands follow.
             $(POST_INSTALL)    # Post-install commands follow.
             $(NORMAL_INSTALL)  # Normal commands follow.

もし`install'規則の始めに部類行を使わないなら、全てのコマンドは、最初の
部類行まで普通のものと分類される。もしどの部類行も使わないなら、全てのコ
マンドは普通のものと分類される。

これらは`uninstall'のための部類行である。

             $(PRE_UNINSTALL)     # Pre-uninstall commands follow.
             $(POST_UNINSTALL)    # Post-uninstall commands follow.
             $(NORMAL_UNINSTALL)  # Normal commands follow.

典型的には、pre-uninstallコマンドはInfoディレクトリから項目を削除するた
めに使われるだろう。

もし`install'や`uninstall'ターゲットがインストールのサブルーチンとして振
る舞う依存関係を持つなら、*それぞれの*依存関係のコマンドを部類行で始める
べきで、主要なターゲットのコマンドも部類行で始めるべきだ。こうして、それ
ぞれのコマンドが、依存関係のそれが実際に走るかどうかに関係なく、正しい部
類に位置するように保証できる。

pre-installationとpost-installationのコマンドはこれら以外のプログラムを
走らせるべきではない。

     [ basename bash cat chgrp chmod chown cmp cp dd diff echo
     egrep expand expr false fgrep find getopt grep gunzip gzip
     hostname install install-info kill ldconfig ln ls md5sum
     mkdir mkfifo mknod mv printenv pwd rm rmdir sed sort tee
     test touch true uname xargs yes

この方法でコマンドを区別する理由はバイナリ・パッケージを作るためである。
典型的にはバイナリ・パッケージは全ての実行ファイルとインストールされる必
要がある他のファイルを含み、それらをインストールする、それ自身の方法を持
つ--だから、それは普通のインストールのコマンドを走らせる必要がない。しか
し、バイナリ・パッケージをインストールすることはpre-installationと
post-installationのコマンドを走らせることを必要とする。

バイナリ・パッケージを構築するためのプログラムはpre-installationと
post-installationのコマンドを抜粋することによって働く。ここで
pre-installationコマンドを抜粋する一つの方法を示す。

     make -n install -o all \
           PRE_INSTALL=pre-install \
           POST_INSTALL=post-install \
           NORMAL_INSTALL=normal-install \
       | gawk -f pre-install.awk

ここで`pre-install.awk'というファイルは次のものを含む。

     $0 ~ /^\t[ \t]*(normal_install|post_install)[ \t]*$/ {on = 0}
     on {print $0}
     $0 ~ /^\t[ \t]*pre_install[ \t]*$/ {on = 1}

pre-installationコマンドの結果生じるファイルはバイナリ・パッケージをイン
ストールすることの一部として、シェル・スクリプトとして実行される。



File: standards-ja.info, Node: Releases, Prev: Configuration, Up: Managing Releases

リリースを行う
==============

`Foo version 69.96'の配布物を`foo-69.96.tar.gz'という名前でgzipされたtar
ファイルにまとめなさい。それは`foo-69.96'という名前のサブディレクトリに
展開されるべきだ。

そのプログラムの構築やインストールは配布物に含まれるどのファイルも決して
変更するべきではない。これは、どんな方法でもプログラムの一部を作るファイ
ルは全て、"ソースファイル"と"ソースでないファイル"に分類されていなければ
ならないことを意味する。ソースファイルは人間によって書かれ、自動的には決
して変更されない。ソースでないファイルはMakefileの管理の下に、プログラム
によってソースファイルから生成される。

配布物は、パッケージの名前とそれが何をするのか一般的な記述を与える、
`README'という名前のファイルを含むべきだ。また、もしあるなら、パッケージ
の一番上にあるサブディレクトリそれぞれの目的を説明するのも良い。`README'
ファイルはパッケージのバージョン・ナンバーを記述するか、それが見付かるパッ
ケージ内の場所を参照するべきだ。

`README'ファイルは`INSTALL'というファイルを参照すべきだ。それはインストー
ルのやり方の説明を含むべきだ。

`README'ファイルはまた著作物の条件を含むファイルを参照するべきだ。もし使
われていれば、GNU GPLは`COPYING'と呼ばれるファイルにあるべきだ。もしGNU
LGPLが使われているなら、それは`COPYING.LIB'と呼ばれるファイルにあるべき
だ。

当然ソースファイルは全部配布物になければならない。ソースでないファイルを
配布物に入れても構わない。もしそれらが最新状態でマシンに依存しておらず、
配布物は通常それらを変更することがあり得ないのなら。我々は普通Bison、
`lex'、TeX、そして`makeinfo'によって生成されたソースでないファイルを含め
ている。これは、ユーザがインストールしたいパッケージではどれでもインストー
ルできるので、我々の配布物間での不必要な依存関係を避けるのに役立っている。

プログラムを構築したりインストールすることによって実際に変更されるかもし
れないソースでないファイルは、*絶対に*配布物に入れるべきではない。だから
もしソースでないファイルを配布するなら、新しい配布物を作るとき、それらを
常に最新にしておきなさい。

配布物が展開するディレクトリは(どのサブディレクトリも)全て誰でも書き込み
可能にしておきなさい(8進数モードの777)。これは、tarアーカイブのファイル
の所有者と許可を保存する、`tar'の古いバージョンがそのユーザが特権的でな
い場合でも全てのファイルを展開できるようにするためだ。

配布物の全てのファイルは誰でも読み込み可能にしておきなさい。

配布物の中にファイル名が14文字より長いものがないようにしておきなさい。同
様に、そのプログラムを構築することによって出来るファイルはどれも14文字よ
り長い名前を持たないようにするべきだ。これの理由は一部のシステムはPOSIX
標準の馬鹿げた解釈に固執し、過去にやっていたように長い名前を切り詰めるよ
りも開くことを拒んでいるからだ。

配布物それ自体にシンボリック・リンクを含めてはいけない。tarファイルがシ
ンボリック・リンクを含むなら、人々はシンボリック・リンクをサポートしない
システム上ではそれを展開することさえできない。また、異なるディレクトリで
一つのファイルに複数の名前を使ってはいけない。なぜなら、あるファイルシス
テムはこれを扱えないし、このことは配布物を展開できなくするからだ。

全てのファイル名がMS-DOS上で重ならないようにしてみなさい。MS-DOSでの名前
は8文字以下から成り立ち、付加的にピリオドと3文字以下の文字がくっつく。
MS-DOSは余分な文字をピリオドの前と後両方で切り詰めるだろう。だから、
`foobarhacker.c'と`foobarhacker.o'は曖昧でない。それらは`foobarha.c'と
`foobarha.o'に切り詰められ、それらは区別できる。

あなたの配布物に`*.texinfo'や`*.texi'ファイルの出力を試験するのに使った
`texinfo.tex'のコピーを入れなさい。

同様に、もしあなたのプログラムがregex、getopt、obstack、あるいはtermcap 
のような小さなGNUソフトウェア・パッケージを使うなら、配布物にそれらを含
めなさい。それらを省くと、その配布ファイルはちょっと小さくなるが、他のファ
イルをどうやって手に入れるか分からないユーザにいくらか不便になるという犠
牲を払うことになる。




Tag table:
Node: Top1030
Node: Preface1486
Node: Legal Issues2284
Node: Reading Non-Free Code2566
Node: Contributions3539
Node: Design Advice4688
Node: Compatibility5060
Node: Using Extensions5903
Node: ANSI C6704
Node: Source Language7607
Node: Program Behavior8421
Node: Semantics8933
Node: Libraries11322
Node: Errors11993
Node: User Interfaces12690
Node: Option Table16383
Node: Memory Usage30921
Node: Writing C31452
Node: Formatting32048
Node: Comments34346
Node: Syntactic Conventions36151
Node: Names37865
Node: System Portability38832
Node: CPU Portability40062
Node: System Functions41277
Node: Internationalization44193
Node: Mmap46191
Node: Documentation46616
Node: GNU Manuals47028
Node: Manual Structure Details48938
Node: NEWS File50037
Node: Change Logs50469
Node: Change Log Concepts50944
Node: Style of Change Logs51871
Node: Simple Changes52938
Node: Conditional Changes53549
Node: Man Pages54346
Node: Reading other Manuals55225
Node: Managing Releases55658
Node: Configuration56119
Node: Makefile Conventions60267
Node: Makefile Basics60724
Node: Utilities in Makefiles62605
Node: Command Variables63974
Node: Directory Variables65715
Node: Standard Targets72552
Node: Install Command Categories79630
Node: Releases82557

End tag table
