Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999
Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU General
Public License" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU General Public License" may be included in a translation
approved by the Free Software Foundation instead of in the original
English.





File: emacs-ja.info, Node: Major Modes, Next: Indentation, Prev: International, Up: Top

メジャーモード
**************

Emacsには、多数の選択できる"メジャーモード"（major mode）があり、各モー
ドは特定の種類のテキストを編集するためにEmacsをカスタマイズします。メジャー
モードは相互に排他的で、各バッファはいつでも1つのメジャーモードだけを持
ちます。モード行は、通常、現行のメジャーモードの名前を括弧の中に表示しま
す（*Note Mode Line::）。

もっとも特殊化されていないメジャーモードは、"基本（fundamental）モード"
と呼ばれます。このモードには、モード独自の再定義や変数設定がなく、各
Emacsコマンドはもっとも一般的なふるまいをして、各オプションはデフォルト
の状態になっています。Lispや英文のように、Emacsが知っている特定の種類の
テキストを編集するには、Lispモードや、テキスト（text）モードのような適切
なメジャーモードに切り替えるべきです。

メジャーモードを選択することは、編集対象の言語により明確に適応するように
キーの意味を多少変更することです。よく変更されるキーはTAB、DEL、`C-j'で
す。プレフィックスキー`C-c'は、モード特有のコマンドを含みます。さらに、
コメントを扱うコマンドは、モードを使ってコメントの区切り方を決定します。
多くのメジャーモードでは、バッファ内に現れる文字の構文上の属性を再定義し
ています。*Note Syntax::。

メジャーモードは3つのグループに分けられます。（いくつかの変種を有する）
Lispモード、Cモード、Fortranモード、その他のプログラム言語特有のモードの
グループがあります。テキスト（text）モード、nroffモード、TeXとアウトライ
ン（outline）モードなど英文を編集するためのものがあります。残りのメジャー
モードは、ユーザーのファイルに使うためのものではありません。Emacsが特別
の目的のために作るバッファで使われます。dired（*Note Dired::）が作るバッ
ファ向けのdiredモード（*Note Dired::）、`C-x m'で作られるバッファ向けの
メイル（mail）モード（*Note Sending Mail::）、下位のシェルプロセスとの通
信用のバッファ向けのシェル（shell）モード（*Note Interactive Shell::）な
どです。

ほとんどのプログラム言語用のメジャーモードでは、段落の区切りは空行だけで
す。これは、段落コマンドを役立つようにするためです。（*Note Paragraph
s::。）また、これらのモードでは、自動詰め込み（auto-fill）モードにおいて、
新たに作った行を字下げするようにTABを定義します。というのは、プログラム
中のほとんどの行は通常字下げされるからです。（*Note Indentation::。）

* Menu:

* Choosing Modes::     How major modes are specified or chosen.



File: emacs-ja.info, Node: Choosing Modes, Prev: Major Modes, Up: Major Modes

メジャーモードの選択方式
========================

カレントバッファに対して明示的にメジャーモードを選択することもできます。
しかし、たいていは、ファイル名やファイル内の特別のテキストに基づいて
Emacsはどのモードを使うかを決定します。

明示的に新しいメジャーモードを選択するには、`M-x'コマンドで行います。メ
ジャーモードの名前に`-mode'を付け加えると、そのモードを選ぶコマンド名に
なります。したがって、Lispモードに入るには`M-x lisp-mode'を実行します。

ファイルを訪問すると、Emacsは通常ファイル名に基づいて正しいメジャーモー
ドを選択します。たとえば、`.c'で終る名前のファイルは、Cモードで編集され
ます。ファイル名とメジャーモードとの対応は、変数`auto-mode-alist'で制御
します。その値は、要素がつぎのような形式のリストです。

     (REGEXP . MODE-FUNCTION)

または、つぎの形式です。

     (REGEXP MODE-FUNCTION FLAG)

たとえば、このリストに通常ある要素は、`("\\.c\\'". c-mode)'です。これは、
`.c'で終る名前のファイルにはCモードを選びます。（Lispの構文では、`\'を含
めるには`\\'が必要。また、`\'は、正規表現の`.'の特別な意味を抑制するため
に必要。）リストの要素が`(REGEXP MODE-FUNCTION FLAG)'の形式でFLAGが`nil'
以外ならば、FUNCTIONを呼んだあとにREGEXPに一致する接尾辞を捨てて、リスト
で他に一致するものをふたたび探します。

ファイルの空行でない最初の行の特別な種類のテキストによって、そのファイル
を編集するためにどのメジャーモードを使うかを指定できます。モード名は、そ
の行に`-*-'で囲まれて現れます。他のテキストがその行にあってもかまいませ
ん。たとえば、

     ;-*-Lisp-*-

は、EmacsにLispモードを使うように指示します。このような明示的な指定は、
ファイル名に基づいたメジャーモードに優先します。この行がLispのコメントに
なるようにセミコロンを使っていることに注意してください。

モードを指定する別の書式は、つぎのとおりです。

     -*- mode: MODENAME;-*-

これは、同様にローカル変数も指定できて、つぎのように書きます。

     -*- mode: MODENAME; VAR: VALUE; ... -*-

より詳しくは、*Note File Variables::。

ファイルの内容が`#!'で始まるときは、ファイルの1行目で指定したコマンドイ
ンタープリタを実行することで、実行可能なシェルコマンドとして働きます。ファ
イルの残りの部分は、インタープリタへの入力として使われます。

Emacsでそのようなファイルを訪問したとき、ファイルの名前がメジャーモード
を指定しないときには、Emacsはモードを選択するために1行目のインタープリタ
の名前を使います。1行目が、`perl'や`tcl'のような認識されるインタープリタ
プログラムの名前ならば、Emacsはインタープリタのプログラムにとって適切な
モードを使用します。変数`interpreter-mode-alist'は、インタープリタプログ
ラム名とメジャーモードとの対応を指定します。

1行目が`#!'で始まるときには、インタープリタを実行するときにシステムが混
乱するため、1行目では`-*-'の機能を使えません。そのため、そのようなファイ
ルでは、Emacsは1行目に加えて2行目でも`-*-'を探します。

使用するメジャーモードを指定しないファイルを訪問したとき、あるいは、`C-x
b'で新たにバッファを作るときには、変数`default-major-mode'が、使用するモー
ドを指定します。通常、その値は、基本（fundamental）モードを指定するシン
ボル`fundamental-mode'です。`default-major-mode'が`nil'なら、メジャーモー
ドはまえに選択していたバッファのモードと同じものとなります。

バッファのメジャーモードを変更しても、Emacsが自動的に選択するメジャーモー
ドに戻れます。それには、コマンド`M-x normal-mode'を使います。このコマン
ドは、メジャーモードを選択するために`find-file'が呼び出す関数と同じ関数
です。この関数は、ファイル中にローカル変数リストがあればそれも処理します。

コマンド`C-x C-w'と`set-visited-file-name'は、新しいファイル名がモードを
示すものであるなら、新しいメジャーモードに変更します（*Note Saving::）。
しかし、バッファの内容がメジャーモードを指定していて、かつ、ある『特別な』
メジャーモードがそのモードの変更を許さないなら、メジャーモードは変更され
ません。`change-major-mode-with-file-name'を`nil'に設定すると、このモー
ド変更機能をオフにできます。


File: emacs-ja.info, Node: Indentation, Next: Text, Prev: Major Modes, Up: Top

字下げ
******

本章では、字下げ（indentation）を付加／削除／調整するEmacsコマンドについ
て説明します。

`TAB'
     モードに固有の方法で、現在行を『適切に』字下げする。
``C-j''
     RETに続けてTABを実行する（`newline-and-indent'）。
`M-^'
     2つの行を連結して1つにする（`delete-indentation'）。`C-j'の効果を取
     り消す。
`C-M-o'
     ポイント位置で行を分割する。つまり、行内のポイント以降のテキストは
     新たな行になり、かつ、ポイント位置まで字下げする（`split-line'）。
`M-m'
     現在行の空白でない最初の文字までポイントを（行末か行頭へ向かって）
     移動する（`back-to-indentation'）。
`C-M-\'
     複数の行を同じ桁に字下げする（`indent-region'）。
`C-x TAB'
     複数の行の塊を（右か左に）同じ量だけきっちり移動する
     （`indent-rigidly'）。
`M-i'
     ポイント位置からあらかじめ設定したつぎのタブストップ位置まで字下げ
     する（`tab-to-tab-stop'）。
`M-x indent-relative'
     ポイント位置からまえの行の字下げ位置まで字下げする。

ほとんどのプログラム言語には、字下げの慣習があります。Lispコードでは、括
弧の入れ子の深さに従って行を字下げします。細部はかなり異なりますが、概念
的にはCコードでも同様の考え方で字下げします。

どんな言語であっても、行を字下げするにはTABコマンドを使います。各メジャー
モードでは、特定の言語に適した字下げを行うように、このコマンドを定義しま
す。Lispモードでは、TABは括弧の深さに応じて行を整列します。行のどこでTAB
を打鍵しても、その行全体を整列します。Cモードでは、TABは、Cの構文上のさ
まざまな側面を考慮した巧みで洗練された字下げスタイルを実現しています。

テキスト（text）モードでは、TABは`tab-to-tab-stop'コマンドを実行します。
これは、つぎのタブストップ位置まで字下げを行います。タブストップ位置は
`M-x edit-tab-stops'で設定できます。

* Menu:

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::             You can set arbitrary "tab stops" and then
                            indent to the next tab stop when you want to.
* Just Spaces::           You can request indentation using just spaces.



File: emacs-ja.info, Node: Indentation Commands, Next: Tab Stops, Prev: Indentation, Up: Indentation

字下げコマンドとその技巧
========================

行の字下げを飛び越えるには、`M-m'（`back-to-indentation'）を使います。行
のどこで実行しても、その行の空白でない最初の文字位置にポイントを移動しま
す。

現在行のまえに字下げした行を挿入するには、`C-a C-o TAB'を使います。現在
行のあとに字下げした行を挿入するには、`C-e C-j'を使います。

単にタブ文字を挿入するには、`C-q TAB'と打ちます。

`C-M-o'（`split-line'）は、ポイントから行末までのテキストを垂直に下ろし
ます。その結果、現在行は2つの行に分割されます。`C-M-o'は、まず、ポイント
の直後に空白やタブがある限りポイントを進めます。そして、ポイントの直後に、
改行とポイント位置の桁までに必要な字下げを挿入します。ポイント自身は挿入
した改行の直前に留まります。この点では、`C-M-o'は`C-o'に似ています。

2つの行を連結するには、コマンド`M-^'（`delete-indentation'）を使います。
このコマンドは、現在行の行頭の字下げと行区切り（改行文字）を削除して空白
1個に置き換えます。ただし、この空白1個を省いてしまう（Lispコードには便利
な）特別な場合があります。2つの行を繋げた結果、開き括弧や閉じ括弧が連続
する場合、あるいは、さらに改行が続く場合です。現在行の字下げだけを削除す
るには、行頭に移動してから`M-\'（`delete-horizontal-space'）を使います。
このコマンドは、カーソル（ポイント）の周りの空白とタブをすべて削除します。

詰め込み接頭辞がある場合、`M-^'は、削除される改行の直後に現れる詰め込み
接頭辞を削除します。*Note Fill Prefix::。

一度に複数の行の字下げを変更するコマンドもあります。`C-M-\'
（`indent-region'）は、リージョン内で始まるすべての行に作用します。この
コマンドは、行頭でTABを打鍵したかのように『普通の』方法で各行を字下げし
ます。数引数は字下げする桁位置を指定します。つまり、最初の空白でない文字
がその桁位置にくるように行全体を右か左に水平移動します。`C-x TAB'
（`indent-rigidly'）は、リージョン内のすべての行を、引数で指定した分だけ
右に移動します（引数が負であれば左に移動）。複数の行全部をきちっと揃えて
（rigidly）横に移動することから、コマンドにはこのような名前が付いていま
す。

`M-x indent-relative'は、先行する行（実際には空行でないいちばん近くの行）
に基づいてポイント位置を字下げします。ポイント位置に空白を挿入してポイン
トを進めて、ポイントが先行する行の字下げ位置の真下にくるようにします。字
下げ位置とは連続した白文字の末尾か行末のことです。ポイントが先行する行の
どの字下げ位置よりも右にある場合には、ポイントのまえの白文字を削除してか
ら、先行する行の適用可能な最初の字下げ位置まで字下げします。適用可能な字
下げ位置がない場合には、`indent-relative'は`tab-to-tab-stop'を実行します
（*Note Tab Stops::）。

字下げテキスト（indented text）モードでは、TABは`indent-relative'と定義
されます。*Note Text::。

テキストの一部を字下げする別の方法については*Note Format Indentation::。



File: emacs-ja.info, Node: Tab Stops, Next: Just Spaces, Prev: Indentation Commands, Up: Indentation

タブストップ
============

表を入力するには、テキスト（textモード）におけるTABの定義、
`tab-to-tab-stop'を利用できます。このコマンドは、ポイントがつぎのタブス
トップ位置に達するまでポイントのまえに字下げを挿入します。テキスト（text）
モードでなくても、`M-i'でこのコマンドを実行できます。

`M-i'が使用するタブストップは任意に設定できます。この設定は、昇順に並べ
た桁番号のリストとして`tab-stop-list'と呼ばれる変数に格納されます。

タブストップを設定する便利な方法は、`M-x edit-tab-stops'を使うことです。
このコマンドは、タブストップの設定を記述したバッファを作成して選択します。
このバッファを編集して今までとは異なるタブストップを指定し、`C-c C-c'と
打ってその新たな設定を有効にします。`edit-tab-stops'は、呼ばれたときのカ
レントバッファをあらかじめ記録しておくので、そのバッファに新たなタブストッ
プを設定します。通常、全バッファで同じタブストップを共有しているので、1
つのバッファでタブストップを変更すると、すべてのバッファに影響をします。
しかし、あるバッファで`tab-stop-list'をローカルにしておくと、そのバッファ
で`edit-tab-stops'を実行するとローカルな設定を編集します。

一般的に使われる8桁ごとに設定されたタブストップの場合、設定用バッファの
内容はつぎのようになります。

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

1行目は、各タブストップ位置をコロンで表します。残りの行は、タブストップ
位置を読み取りやすくためや使い方です。

`tab-to-tab-stop'を制御するタブストップと、バッファ内でのタブ文字の表示
とは、関係がないことに注意してください。詳細については*Note Display
Vars::。



File: emacs-ja.info, Node: Just Spaces, Prev: Tab Stops, Up: Indentation

タブと空白
==========

Emacsでは、通常、行の字下げにはタブと空白の両方を使用します。しかし、空
白だけを用いて字下げを行うことも可能です。そうするには、変数
`indent-tabs-mode'に`nil'を設定します。この変数はバッファごとの変数です。
変数を変更してもカレントバッファだけに影響しますが、デフォルト値を変更す
ることもできます。*Note Locals::。

空白以外のテキストの桁を保存したまま、タブを空白（あるいはその逆）に変換
するコマンドもあります。`M-x tabify'は、リージョン内の連続する空白を探し
て、字下げを変えることがなければ少なくとも連続する3個の空白をタブに変換
します。`M-x untabify'は、リージョン内のすべてのタブを適切な個数の空白に
変換します。


File: emacs-ja.info, Node: Text, Next: Programs, Prev: Indentation, Up: Top

自然言語用のコマンド
********************

コンピュータの分野では、"テキスト"（text）という用語には2つの大きな意味
があります。1つは、文字の列から成るデータのことです。この意味からすれば、
Emacsで編集するどんなファイルもテキストです。もう1つの意味はより限定され
ていて、人間が読む自然言語の（テキスト整形処理後の場合もあるが）文字の列
のことで、プログラムやプログラムに与えるコマンドと対比されます。

自然言語には、エディタコマンドで支援したり利用したりできる構文的／様式的
な約束事があります。たとえば、単語、文、段落、大文字といったものです。本
章では、これらを扱うEmacsコマンドについて述べます。また、"詰め込み"
（filling）、つまり、段落の各行がほぼ同じ長さになるように再配置し直すコ
マンドについてもふれます。単語、文、段落を横断してポイントを移動したり、
それらをキルするコマンドは、自然言語テキストの編集を意図したものですが、
プログラムの編集にも役立ちます。

Emacsには、自然言語テキストの編集用のメジャーモードがいくつかあります。
扱うテキストが純粋にテキストだけで単純なものであれば、テキスト（text）モー
ドを使いましょう。これは、自然言語テキストの構文上の約束事を扱えるように、
Emacsを少しだけカスタマイズしてあります。アウトライン（outline）モードに
は、アウトライン構造を持つテキストを操作する特別なコマンドがあります。

テキスト整形コマンドを埋め込んだテキストに対しては、特定のテキスト清書系
ごとに別のメジャーモードが用意してあります。たとえば、TeX用にはTeX モー
ドがあります。nroff用にはnroffモードがあります。

テキスト清書系を使うかわりにエンリッチ（enriched）モードを使用すれば、
WYSIWYG（what you see is what you get、『見たとおりを得る』）スタイルで
整形済みテキストを編集することもできます。つまり、Emacsの画面上で整形結
果を見ながら編集できるわけです。

* Menu:

* Words::	        Moving over and killing words.
* Sentences::	        Moving over and killing sentences.
* Paragraphs::	        Moving over paragraphs.
* Pages::	        Moving over pages.
* Filling::	        Filling or justifying text.
* Case::	        Changing the case of text.
* Text Mode::	        The major modes for editing text files.
* Outline Mode::        Editing outlines.
* TeX Mode::	        Editing input to the formatter TeX.
* Nroff Mode::	        Editing input to the formatter nroff.
* Formatted Text::      Editing formatted text directly in WYSIWYG fashion.



File: emacs-ja.info, Node: Words, Next: Sentences, Up: Text

単語
====

Emacsには、単語を横断してポイントを移動したり、単語を操作対象とするコマ
ンドがあります。慣例として、これらのコマンドのキーはメタ文字です。

`M-f'
     単語を横断してポイントを前向きに移動する（`forward-word'）。
`M-b'
     単語を横断してポイントを後向きに移動する（`backward-word'）。
`M-d'
     ポイント位置から単語の末尾までをキルする（`kill-word'）。
`M-DEL'
     ポイント位置から単語の先頭までを後向きにキルする
     （`backward-kill-word'）。
`M-@'
     つぎの単語の末尾にマークを設定する（`mark-word'）。
`M-t'
     隣接した2つの単語を入れ替える。あるいは、単語を複数の単語を飛び越し
     て移す。（`transpose-words'）。

これらのキーは、文字単位の操作コマンド、`C-f'、`C-b'、`C-d'、DEL、`C-t'
に対応していることに注目してください。`M-@'も、`C-SPC'の別名である`C-@'
に対応しています。

コマンド`M-f'（`forward-word'）と`M-b'（`backward-word'）は、単語を横断
してポイントを前向きに（末尾に向かって）あるいは後向きに（先頭に向かって）
移動します。これらのメタ文字は、文字単位でポイントを前後に移動するコント
ロール文字`C-f'や`C-b'に類似しています。この類似性は、数引数を反復回数と
して扱うことにもおよびます。負の引数を指定すると、`M-f'は後向きに移動し、
`M-b'は前向きに移動します。前向き移動では単語の最後の文字の直後に、後向
き移動では最初の文字の直前に、ポイントを移動します。 (1) (*Note
Words-Footnotes::)

`M-d'（`kill-word'）はポイントの直後の単語をキルします。正確にいえば、ポ
イント位置から`M-f'による移動位置までの全文字をキルします。ポイントが単
語の途中にあれば、ポイントよりあとの部分だけをキルします。また、ポイント
とつぎの単語のあいだに句読点があれば、単語と一緒にそれらもキルします。
（つぎの単語だけをキルしてそのまえにある句読点を残したければ、`M-f'でつ
ぎの単語の末尾に移動してから、`M-DEL'でその単語を後向きにキルする。）
`M-d'は、引数を`M-f'と同様に解釈します。

`M-DEL'（`backward-kill-word'）は、
ポイントの直前の単語をキルします。
ポイント位置から`M-b'による移動位置までの全文字をキルします。
ポイントが`FOO, BAR'の空白の直後にあるとすれば、
`FOO, 'をキルします。
（`FOO'だけをキルしてコンマと空白を残したければ、
`M-DEL'のかわりに`M-b M-d'を使う。）

`M-t'（`transpose-words'）は、
ポイントの直前にある単語あるいはポイントを含む単語と、
後続の単語とを入れ替えます。
単語のあいだにある区切り文字は動きせん。
たとえば、`FOO, BAR'を入れ替えると、
`BAR FOO,'ではなく`BAR, FOO'となります。
入れ替えや入れ替えコマンドの引数については、
*Note Transpose::。

ポイントとマークのあいだに適用される操作を後続のN個の単語に適用する方法
は、2つあります。ポイント位置にマークを設定してから、単語を横断してポイ
ントを移動します。あるいは、コマンド`M-@'（`mark-word'）を使います。この
コマンドは、ポイントを移動せずに、`M-f'による移動位置にマークを設定しま
す。`M-@'には、何単語先にマークを設定するかを数引数で指定できます。暫定
マーク（transient-mark）モードでは、このコマンドはマークを活性にします。

単語操作コマンドが理解する構文は、すべて構文テーブルで制御されます。たと
えば、任意の文字を単語の区切り文字として宣言できます。*Note Syntax::。


File: emacs-ja.info  Node: Words-Footnotes, Up: Words

(1) 【訳注】なお、移動方向に単語構成文字がない場合には、それらを飛び越え
てポイントを移動します。



File: emacs-ja.info, Node: Sentences, Next: Paragraphs, Prev: Words, Up: Text

文
==

Emacsの文／段落操作コマンドは、単語操作コマンドと同じく、ほとんどメタキー
です。

`M-a'
     文の先頭にポイントを後向きに移動する（`backward-sentence'）。
`M-e'
     文の末尾にポイントを前向きに移動する（`forward-sentence'）。
`M-k'
     ポイント位置から文末までを前向きにキルする（`kill-sentence'）。
`C-x DEL'
     ポイント位置から文頭までを後向きにキルする
     （`backward-kill-sentence'）。

コマンド`M-a'と`M-e' （`backward-sentence'と`forward-sentence'）は、それ
ぞれ、ポイントを含む文の先頭あるいは末尾にポイントを移動します。これらは、
行頭や行末にポイントを移動するコマンド`C-a'と`C-e'に類似するように選ばれ
ました。ただし、`M-a'や`M-e'を反復して使ったり数引数を指定すると、ポイン
トは連続した文を横断して移動する点が違います。

（文頭に向かって）後向きに移動するときは、文の先頭の文字の直前にポイント
を置きます。（文末に向かって）前向きに移動するときは、文を終える句読点の
直後に置きます。どちらのコマンドも、文と文の境界にある白文字にポイントを
移動することはありません。

`C-a'と`C-e'には調和したキルコマンド`C-k'があるように、`M-a'と`M-e'にも
コマンド`M-k'（`kill-sentence'）があります。これはポイントから文末までを
キルします。引数に-1を指定すると、文頭までを後向きにキルします。これより
大きな引数は反復回数になります。また、ポイント位置から文頭までを後向きに
キルするコマンドとして`C-x DEL'（`backward-kill-sentence'）もあります。
このコマンドは、文の作成途中で考えが変わったときに便利です。

文操作コマンドでは、文末に空白を2個打つという米国のタイピストの習慣を踏
襲しているものと仮定します。つまり、`.'、`?'、`!'の直後が行末であるか空
白が2個続けば、その箇所を文末とみなします。ただし、`.'、`?'、`!'の直後に
は、`)'、`]'、`''、`"'がいくつあってもかまいません。また、段落の先頭と末
尾も、それぞれ、文の先頭と末尾になります。

変数`sentence-end'で、文末の識別方法を制御します。この値は、文末の数個の
文字とそれらに続く白文字に一致する正規表現です。通常の値はつぎのとおりで
す。 (1) (*Note Sentences-Footnotes::)

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

この例は、正規表現の節で説明しました。*Note Regexps::。

文のあいだには空白を1個だけとしたければ、`sentence-end'にはつぎの値を設
定します。

     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*"

同時に、変数`sentence-end-double-space'には`nil'を設定して、詰め込みコマ
ンドにも、文末には空白が1個だけあり、また、文末には空白を1個だけ追加する
ことを指示します。ただし、このように設定すると、文末のピリオドと省略のピ
リオドとを区別できなくなることに注意してください。


File: emacs-ja.info  Node: Sentences-Footnotes, Up: Sentences

(1) 【訳注】言語環境を`Japanese'にすると、変数`sentence-end'は

     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*\\|[。？！]"
となっている。追加部分は、日本語の文末に対応する文字集合。



File: emacs-ja.info, Node: Paragraphs, Next: Pages, Prev: Sentences, Up: Text

段落
====

段落を操作するEmacsコマンドもメタキーです。

`M-{'
     まえの段落の先頭にポイントを後向きに移動する（`backward-paragraph'）。
`M-}'
     つぎの段落の末尾にポイントを前向きに移動する（`forward-paragraph'）。
`M-h'
     ポイントを含む段落かつぎの段落の周りにポイントとマークを置く
     （`mark-paragraph'）。

`M-{'は、ポイントを含む段落の先頭か、まえの段落の先頭にポイントを移動し
ます。一方、`M-}'は、ポイントを含む段落の末尾か、つぎの段落の末尾にポイ
ントを移動します。段落は、空行やテキスト整形コマンドの行で区切られますが、
それらの行自体は段落には属しません。基本（fundamental）モードでは、字下
げした行も新たな段落の始まりとみなしますが、テキスト（text）モードではそ
うしません。（段落の直前に空行があれば、これらのコマンドはそれらを段落の
先頭として扱う。）

プログラム用のメジャーモードでは、段落は空行で始まり空行で終ります。こう
しておけば、本来段落を持たないプログラムでも段落操作コマンドが役立ちます。

詰め込み接頭辞がある場合には、接頭辞で始まらない行が段落の区切りとなりま
す。*Note Filling::。

段落を対象に操作したいときには、コマンド`M-h'（`mark-paragraph'）を使っ
て段落を囲むようなリージョンを設定します。したがって、たとえば、`M-h
C-w'とすると、ポイントを含むか直後の段落を削除します。`M-h'コマンドは、
ポイントを含む段落の先頭にポイントを置き、末尾にマークを設定します。暫定
マーク（transient-mark）モードでは、このマークを活性にします。ポイントが
段落のあいだ（空行や境界）にある場合は、ポイントの直後にある段落の周りに
ポイントとマークを設定します。段落の1行目のまえに空行があれば、直前の空
行1行も`M-h'が設定するリージョンに含まれます。

正確な段落の境界は、変数`paragraph-separate'と`paragraph-start'で定義さ
れます。`paragraph-start'の値は、段落を始めたり区切ったりする行に一致す
る正規表現です。`paragraph-separate'の値も別の正規表現ですが、どの段落に
も属さない段落を分割する行（たとえば空行）だけに一致するものです。新たな
段落を始めてその段落に属す行は、`paragraph-start'だけに一致して、
`paragraph-separate'に一致してはいけません。たとえば、基本（fundamental）
モードでは、`paragraph-start'は`"[ \t\n\f]"'であり、`paragraph-separate'
は`"[ \t\f]*$"'です。

通常、ページ境界でも段落が区切られるのが望ましいです。これらの変数のデフォ
ルト値は、ページの一般的な区切り文字も認識します。



File: emacs-ja.info, Node: Pages, Next: Filling, Prev: Paragraphs, Up: Text

ページ
======

ファイルを"ページ送り"文字（ASCIIコードのコントロールL、8進コードの014）
で区切った"ページ"の集まりとして捉えることがよくあります。ファイルを印刷
すると、この文字は改ページを行います。そのため、ファイル内の各ページは別々
の用紙に印刷されます。ほとんどのEmacsコマンドは、ページを区切る文字を他
の文字と同様に扱いますから、`C-q C-l'でページ送り文字を挿入したり、DELで
削除できます。つまり、ファイルをページに区切るのも区切らないのも自由です。
しかし、ページはファイルを分割する意味ある単位なので、Emacsには、ページ
間の移動やページを対象とするコマンドがあります。

`C-x ['
     まえのページ境界にポイントを移動する（`backward-page'）。
`C-x ]'
     つぎのページ境界にポイントを移動する（`forward-page'）。
`C-x C-p'
     このページ（か別のページ）の周りに、ポイントとマークを置く
     （`mark-page'）。
`C-x l'
     このページの行数を数える（`count-lines-page'）。

`C-x ['（`backward-page'）コマンドは、まえのページ区切り文字の直後にポイ
ントを移動します。ポイントがすでにページ区切りの直後にあれば、さらにまえ
のページ区切り文字の直後に移動します。数引数は反復回数として扱われます。
`C-x ]'（`forward-page'）コマンドは、つぎのページ区切り文字の直後にポイ
ントを移動します。

`C-x C-p'コマンド（`mark-page'）は、ページの先頭にポイントを置き、末尾に
マークを設定します。末尾にあるページ区切り文字は含まれます（マークはペー
ジ区切り文字の直後にある）。先頭にあるページ区切り文字は除外されます（ポ
イントはページ区切り文字の直後にある）。`C-x C-p C-w'は、ページ全体をキ
ルして別の場所に移動するのに便利な方法です。`C-x ['や`C-x ]'で別のページ
区切り位置に移動してからキルしたページをヤンクすれば、すべてのページが適
切に区切られた状態が維持されます。`C-x C-p'が末尾のページ区切り文字だけ
を含める理由は、これを保証するためです。

`C-x C-p'への数引数は、現在のページを基準にしてポイントの移動先のページ
を指定します。0は現在のページを意味します。1はつぎのページ、-1はまえのペー
ジを意味します。

`C-x l'コマンド（`count-lines-page'）は、ページをどこで2つに分割するかを
決めるのに便利です。現在のページについて、総行数、現在行のまえにある行数
とうしろにある行数をつぎのようにエコー領域に表示します。

     Page has 96 lines (72+25)

この例で、総行数が1だけ少ないことに注意してください。ポイントが行頭にな
いとつねにこうなります。

変数`page-delimiter'はページの始まりを制御します。この変数の値は、ページ
を区切る行の先頭に一致する正規表現です。この変数の通常の値は`"^\f"'で、
行頭のページ送り文字に一致します。



File: emacs-ja.info, Node: Filling, Next: Case, Prev: Pages, Up: Text

テキストの詰め込み
==================

テキストの"詰め込み"（filling）とは、指定した幅に納まるようにテキストを
行に分割することです。Emacsには、詰め込む方法が2つあります。自動詰め込み
（auto-fill）モードでは、自己挿入文字でテキストを挿入すると同時に詰め込
みを行います。あるいは、詰め込まずにテキストを編集しているときには、陽に
詰め込みコマンドを使います。整形済みテキストを編集しているときは、テキス
トの各部分ごとに詰め込みのスタイルを指定できます（*Note Formatted Tex
t::）。

* Menu:

* Auto Fill::	        Auto Fill mode breaks long lines automatically.
* Fill Commands::       Commands to refill paragraphs and center lines.
* Fill Prefix::	        Filling paragraphs that are indented
                          or in a comment, etc.
* Adaptive Fill::       How Emacs can determine the fill prefix automatically.



File: emacs-ja.info, Node: Auto Fill, Next: Fill Commands, Up: Filling

自動詰め込みモード（auto-fillモード）
-------------------------------------

"自動詰め込み"（auto-fill）モードはマイナモードで、行が長くなりすぎると
自動的に分割します。SPCやRETを打鍵したときだけ、行を分割します。

`M-x auto-fill-mode'
     自動詰め込み（auto-fill）モードをオンにしたりオフにする。
`SPC'
`RET'
     自動詰め込み（auto-fill）モードでは、適切な場合には行を分割する。

`M-x auto-fill-mode'は、自動詰め込み（auto-fill）モードがオフならばオン
にし、オンならばオフにします。正の数引数を指定すると自動詰め込み
（auto-fill）モードをつねにオンにしますが、負の引数を指定するとつねにオ
フにします。モード行の括弧の中に`Fill'と表示されていれば、このモードはオ
ンになっています。自動詰め込み（auto-fill）モードは、各バッファごとにオ
ン／オフできるマイナモードです。*Note Minor Modes::。

自動詰め込み（auto-fill）モードでは、行が決められた幅より長くなると、自
動的に空白の位置で行を分割します。行の分割と再配置は、SPCかRETを打鍵した
ときだけ行われます。行を分割せずに空白や改行を挿入するには、`C-q SPC'や
`C-q C-j'と打鍵します（改行はまさにコントロールJであることを思い出してほ
しい）。`C-o'も行を分割せずに改行を挿入します。

自動詰め込み（auto-fill）モードは、TABで新たな行を字下げするので、プログ
ラム言語用のモードと組み合わせてもうまく動作します。コメントで終わる行が
長くなりすぎた場合には、コメント内のテキストを2つのコメント行に分割しま
す。始めの行の末尾とつぎの行の行頭に新たにコメントの区切り文字列を挿入し
て、2つの独立したコメント行にすることもできます。この付加機能は、変数
`comment-multi-line'で制御します（*Note Comments::）。

適応型詰め込み（後述）は、明示した詰め込みコマンドのみならず、自動詰め込
みに対しても有効に働きます。これは、段落の先頭行あるいは第2行目から、自
動的に詰め込み接頭辞を切り出します。

自動詰め込み（auto-fill）モードは、段落全体を詰め直すことはしません。行
を分割できても、併合はできません。そのため、段落の途中を編集すると、必ず
しも段落を正しく詰め込めません。段落をふたたび適切に詰め込まれた状態にす
るもっとも簡単な方法は、明示的に詰め込みコマンドを使用することです。
*Note Fill Commands::。

多くのユーザーは自動詰め込み（auto-fill）モードを好み、あらゆるテキスト
ファイルの編集に使用しようとします。初期化ファイルの節では、こうする方法
を説明します。*Note Init File::。



File: emacs-ja.info, Node: Fill Commands, Next: Fill Prefix, Prev: Auto Fill, Up: Filling

明示的な詰め込みコマンド
------------------------

`M-q'
     現在の段落を詰め込む（`fill-paragraph'）。
`C-x f'
     詰め込み桁を設定する（`set-fill-column'）。
`M-x fill-region'
     リージョン内の各段落を詰め込む（`fill-region'）。
`M-x fill-region-as-paragraph'
     リージョン全体を1つの段落とみなして詰め込む。
`M-s'
     行を中央に揃える。

段落を詰め直すには、コマンド`M-q'（`fill-paragraph'）を使います。ポイン
トを含む段落、あるいは、ポイントが段落のあいだにある場合には直後の段落を
操作します。改行をすべて取り除いてから、必要な箇所に新たに改行を挿入する
ことで段落を詰め直します。

いくつもの段落を詰め直すには、`M-x fill-region'を使います。これは、リー
ジョンを段落に分けてから、各段落を詰め込みます。

`M-q'と`fill-region'は、`M-h'と同じ基準で段落の境界を探します（*Note
Paragraphs::）。段落の大きさを制御するには、`M-x
fill-region-as-paragraph'を使います。これは、ポイントとマークのあいだに
あるものすべてを詰め直します。このコマンドはリージョン内の空行をすべて削
除して、分かれていたテキストの塊を1つの塊にまとめ上げます。

`M-q'に数引数を指定すると、テキストの詰め込みだけでなく、テキストの"幅揃
え"（justify）も行います。つまり、余分に空白を挿入して、行の右端が詰め込
み桁に一致するようにします。余分な空白を取り除くには、引数を指定しないで
`M-q'を使います。（`fill-region'も同様。）幅揃えを制御して別の詰め込みス
タイルを選択する別の方法は、テキスト属性`justification'を使うことです。
これに関しては、*Note Format Justification::を参照してください。

コマンド`M-s'（`center-line'）は、詰め込み桁までの範囲内で現在行を中央に
揃えます。引数Nを指定すると、現在行を含めN行をそれぞれ独立に中央に揃えて
から、揃えた行のつぎにポイントを移動します。

詰め込むときの行の最大幅は、変数`fill-column'に入っています。
`fill-column'の値を変更すると、カレントバッファにローカルな変数になりま
す。それまではデフォルト値が有効です。デフォルト値は始めは70です。*Note
Locals::。`fill-column'を設定するもっとも簡単な方法は、コマンド`C-x f'
（`set-fill-column'）を使うことです。このコマンドに数引数を指定すると、
その値を新たな詰め込み桁として使います。`C-u'だけを引数に指定すると、ポ
イントの現在の水平位置を`fill-column'に設定します。

Emacsコマンドは通常、ピリオドの直後に空白が2個あるか改行があれば文末とし
て扱います。ピリオドの直後に空白が1個だけでは、文末ではなく省略とみなし
ます。ピリオドのこれら2つの用法の違いを保存するために、ピリオドの直後に
空白が1個だけの箇所では詰め込みコマンドは行を分割しません。

変数`sentence-end-double-space'が`nil'ならば、詰め込みコマンドは、文末に
は空白が1個だけあると仮定し、かつ、文末には空白を1個だけ残します。普通、
この変数の値は`t'なので、上述のように空白が2個ある場合だけを文末として扱
います。*Note Sentences::。

`colon-double-space'が`nil'以外ならば、詰め込みコマンドはコロンのうしろ
に空白を2個置きます。



File: emacs-ja.info, Node: Fill Prefix, Next: Adaptive Fill, Prev: Fill Commands, Up: Filling

詰め込み接頭辞
--------------

各行が（段落を字下げする数個の空白などの）特別の印で始まっている段落を詰
め込むには、"詰め込み接頭辞"（fill prefix）の機能を使えます。詰め込み接
頭辞は文字列であり、Emacsはすべての行がその文字列で始まると仮定しますが、
詰め込み接頭辞自体は詰め込みの対象ではありません。明示的に詰め込み接頭辞
を指定できますが、Emacsが詰め込み接頭辞を自動的に推測することもできます
（*Note Adaptive Fill::）。

`C-x .'
     詰め込み接頭辞を設定する（`set-fill-prefix'）。
`M-q'
     現在の詰め込み接頭辞を使って、段落を詰め込む（`fill-paragraph'）。
`M-x fill-individual-paragraphs'
     字下げ幅の変化を新たな段落の始まりとみなして、リージョン内を詰め込
     む。
`M-x fill-nonuniform-paragraphs'
     段落を分割する行だけを新たな段落の始まりとみなして、リージョン内を
     詰め込む。

詰め込み接頭辞を指定するには、
目的の接頭辞で始まっている行に移動して接頭辞の直後にポイントを置いてから、
コマンド`C-x .'（`set-fill-prefix'）を実行します。
`C-x'のあとはピリオドです。
詰め込み接頭辞の使用をやめるには、空の接頭辞を設定します。
つまり、行頭にポイントを置いてから`C-x .'と打ちます。

詰め込み接頭辞が設定されている場合、詰め込みコマンドは処理に先だって各行
から詰め込み接頭辞を取り除き、詰め込みを行ったあとに各行に挿入します。自
動詰め込み（auto-fill）モードでも、新たに行を作成するときに自動的に詰め
込み接頭辞を挿入します。行頭で`C-o'コマンド（*Note Blank Lines::）を使用
すると、新たに作成する行にも詰め込み接頭辞を挿入します。逆に、コマンド
`M-^'は、削除する改行の直後に詰め込み接頭辞があると接頭辞も削除します
（*Note Indentation::）。

たとえば、`fill-column'が40で詰め込み接頭辞が`;; 'のときに、つぎのテキス
トで`M-q'を実行します。

     ;; This is an
     ;; example of a paragraph
     ;; inside a Lisp-style comment.

結果はつぎのようになります。

     ;; This is an example of a paragraph
     ;; inside a Lisp-style comment.

`M-q'および段落コマンドは、詰め込み接頭辞で始まらない行を段落の始まりと
みなします。これにより、ぶら下がり字下げ（先頭行を除いてすべての行が字下
げ）された段落も正しく詰め込みます。空行や接頭辞を取りさると字下げした行
になる行も、段落の区切りや始まりとみなします。これによって、各行にコメン
ト区切りがある複数段落のコメントを書いているときにも、望みどおりの結果を
得られます。

各段落に対して自動的に詰め込み接頭辞を設定するには、`M-x
fill-individual-paragraphs'を使います。このコマンドは、字下げ幅の変化を
新たな段落の始まりとみなして、リージョンを段落に分割したあと、各段落を詰
め込みます。つまり、1つの『段落』内の行はどれも同じ字下げ幅です。字下げ
幅が、段落に対する詰め込み接頭辞として働きます。

`M-x fill-nonuniform-paragraphs'も同様なコマンドですが、リージョンを段落
に分割する方法が異なります。このコマンドは、（変数`paragraph-separate'で
定義される）段落区切り行だけを新たな段落の始まりとみなします。つまり、各
段落の行はさまざまに字下げされているかもしれないので、その中の最少の字下
げを詰め込み接頭辞として使用するわけです。段落の最初の行の字下げが残りの
行に比べて多くても少なくても、正しい詰め込み結果を得られます。

詰め込み接頭辞は変数`fill-prefix'に格納されます。この値は文字列であるか、
詰め込み接頭辞が設定されていなければ`nil'です。この変数を変更してもカレ
ントバッファだけに影響しますが、デフォルト値を変更することもできます。
*Note Locals::。

テキスト属性`indentation'は、段落に与える字下げ幅を調整する別の方法です。
*Note Format Indentation::。



File: emacs-ja.info, Node: Adaptive Fill, Prev: Fill Prefix, Up: Filling

適応型詰め込み
--------------

詰め込みコマンド自身が、段落に対する適切な詰め込み接頭辞を推測できる状況
もあります。段落のすべての行の先頭に白文字やある種の句読点文字が使われて
いる場合です。

段落が2行以上から成る場合、段落の2行目から詰め込み接頭辞を切り出しますが、
1行目にもそれが現れるときに限ります。

段落が1行だけの場合には、その行から詰め込み接頭辞を切り出す*かもしれませ
ん* (1) (*Note Adaptive Fill-Footnotes::)。こういった状況では、つぎのよ
うな3つの合理的な挙動が考えられるので、接頭辞の決定は複雑です。

   * 最初の行の接頭辞を段落のすべての行に用いる。

   * 1行目の接頭辞に続くテキストの直下に並ぶように後続の行を白文字で字下
     げするが、1行目から接頭辞をコピーしない。

   * 2行目以降には何も特別なことは行わない。

これら3つの整形スタイルは、いずれも一般的に使用されます。そこで、詰め込
みコマンドは、現れた接頭辞とそのときのメジャーモードに基づいて、ユーザー
が望むスタイルを決定しようとします。判断基準はつぎのとおりです。

1行目でみつけた接頭辞が`adaptive-fill-first-line-regexp'に一致するか、
（メジャーモードに依存する）コメント開始文字列のようであれば、みつけた接
頭辞を段落の詰め込みに用います。ただし、その接頭辞が後続の行に対して段落
の始まりにならない場合に限ります。

さもなければ、みつけた接頭辞を相当分の空白に変換して、それらの空白を段落
の2行目以降の詰め込み接頭辞として使います。ただし、それらの空白が後続の
行に対して段落の始まりにならない場合に限ります。

テキスト（text）モード、および、空行やページ区切りだけが段落を区切るモー
ドでは、適応型詰め込みによって選ばれた接頭辞が段落の始まりになることはけっ
してありませんから、その接頭辞を段落の詰め込みに使用することができます。

変数`adaptive-fill-regexp'で、行頭のどんな文字列を詰め込み接頭辞として使
えるかを決定します。この変数の正規表現に一致する行頭の文字列を接頭辞とし
ます。変数`adaptive-fill-mode'に`nil'を設定すると、詰め込み接頭辞を自動
的には切り出しません。

変数`adaptive-fill-function'に関数を設定すると、詰め込み接頭辞を自動的に
切り出すためのより複雑な方法を指定できます。この関数は行の左端の直後にポ
イントを置いて呼び出されます。その行から類推される適切な詰め込み接頭辞を
返さなくてはいけません。その行に詰め込み接頭辞がなさそうであれば`nil'を
返します。


File: emacs-ja.info  Node: Adaptive Fill-Footnotes, Up: Adaptive Fill

(1) 【訳注】段落に1行しかなければ、詰め込み接頭辞を切り出す必要はないと
思うかもしれないが、たとえば、その行が詰め込み桁より長かったり、新たな入
力によって複数行の段落になったときのことを考えてみてほしい。



File: emacs-ja.info, Node: Case, Next: Text Mode, Prev: Filling, Up: Text

大文字小文字変換コマンド
========================

Emacsには、単語や任意の長さのテキストを大文字あるいは小文字に変換するコ
マンドがあります。

`M-l'
     後続の単語を小文字に変換する（`downcase-word'）。
`M-u'
     後続の単語を大文字に変換する（`upcase-word'）。
`M-c'
     後続の単語の1文字目だけを大文字にする（`capitalize-word'）。
`C-x C-l'
     リージョン内のテキストを小文字に変換する（`downcase-region'）。
`C-x C-u'
     リージョン内のテキストを大文字に変換する（`upcase-region'）。

単語変換コマンドはたいへん便利です。`M-l'（`downcase-word'）はポイントの
直後の単語を小文字に変換し、単語の末尾にポイントを移動します。したがって、
`M-l'を繰り返すと、連続した単語を変換できます。`M-u'（`upcase-word'）は
単語を大文字に変換し、`M-c'（`capitalize-word'）は単語の1文字目を大文字
して残りを小文字に変換します。これらのコマンドに引数を指定すると、一度に
数単語を変換できます。これらのコマンドは、大文字だけの大量のテキストを大
文字小文字が混在するように変換するときに、特に威力を発揮します。というの
は、必要に応じて`M-l'、`M-u'、`M-c'を使い分けて移動したり、`M-f'で変換せ
ずに単語を飛び越えられるからです。

負の引数を指定すると、ポイントの直前にある数個の単語を変換しますが、ポイ
ントは移動しません。これは、大文字小文字をまちがえて単語を入力した直後に
は便利です。大文字小文字変換コマンドを打ってからすぐに入力を再開できます。

単語の途中で大文字小文字変換コマンドを実行すると、ポイントのうしろにある
部分だけを変換します。これは`M-d'（`kill-word'）のふるまいと同じです。ま
た、負の引数を指定すると、ポイントよりまえの部分を変換します。

他の大文字小文字変換コマンドは、`C-x C-u'（`upcase-region'）と`C-x C-l'
（`downcase-region'）です。これらは、リージョン内のテキストを指定どおり
に変換します。ポイントもマークも移動しません。

リージョンに対する大文字小文字変換コマンドである`upcase-region'と
`downcase-region'は、通常、使用禁止になっています。つまり、これらのコマ
ンドを使おうとすると、最初に確認を求めてきます。確認するときにコマンドを
使用可にしておけば、つぎからは確認を求めてきません。*Note Disabling::。



File: emacs-ja.info, Node: Text Mode, Next: Outline Mode, Prev: Case, Up: Text

テキストモード（textモード）
============================

自然言語テキストのファイルを編集するときには、基本（fundamental）モード
ではなくテキスト（text）モードを使ったほうが便利です。テキスト（text）モー
ドに入るには`M-x text-mode'と打ちます。

テキスト（text）モードでは、空行とページ区切りだけが段落の区切りです。そ
の結果、段落を字下げできて、適応型詰め込みでは段落の詰め込みに使用する字
下げを決定できます。*Note Adaptive Fill::。

テキスト（text）モードでは、TABは`indent-relative'（*Note Indentation::）
を実行するように定義してあるので、先行する行と同じように字下げするのに便
利です。先行する行が字下げされてなければ、`indent-relative'は
`tab-to-tab-stop'を実行します。これは、ユーザーが設定したEmacsのタブストッ
プを使います（*Note Tab Stops::）。

テキスト（text）モードでは、コメントに関する機能は、陽に起動した場合を除
いてオフです。ピリオドは単語の一部ではなく、一方、アポストロフ、バックス
ペース、下線は単語の一部である、となるように構文テーブルを変更します。

段落の最初の行を字下げするのであれば、テキスト（text）モードではなく段落
字下げ型テキスト（paragraph-indent-text）モードを使うべきです。このモー
ドでは、段落のあいだに空行を設ける必要はありません。というのは、最初の行
の字下げで、段落の始まりがわかるからです。ただし、すべての行が字下げされ
ている段落は扱えません。このモードに入るには、`M-x
paragraph-indent-text-mode'を使います。

テキスト（text）モード、および、テキスト（text）モードに基づくすべてのモー
ドでは、`M-TAB'をコマンド`ispell-complete-word'として定義します。このコ
マンドは、ポイントの直前の部分的な単語を綴り辞書を用いて補完します。
*Note Spelling::。

テキスト（text）モードに入ると、フック`text-mode-hook'を実行します。テキ
スト（text）モードに関連する他のモードも、このフックに続けて各モード専用
のフックを実行します。つまり、段落字下げ型テキスト
（paragraph-indent-text）モード、nroffモード、TeXモード、アウトライン
（outline）モード、メイル（mail）モードがそうです。`text-mode-hook'に登
録されたフック関数では、`major-mode'の値を調べれば実際にどのモードに入っ
たかわかります。*Note Hooks::。

Emacsには、綺麗な印刷出力を得るためにテキスト清書系に渡すテキストを編集
するためのモードが他に2つあります。nroff入力の編集については、*Note
Nroff Mode::。TeX入力の変数については、*Note TeX Mode::。

別のモードは、アウトラインの編集に使います。このモードは、さまざまなレベ
ルの詳しさでテキストを眺めることができます。アウトラインの見出しだけを見
たり、見出しとテキストを同時に見たりできます。低いレベルの見出しの一部を
隠して、より高いレベルの構造を際だたせることもできます。*Note Outline
Mode::。



File: emacs-ja.info, Node: Outline Mode, Next: TeX Mode, Prev: Text Mode, Up: Text

アウトラインモード（outlineモード）
===================================

アウトライン（outline）モードはテキスト（text）モードにたいへんよく似た
メジャーモードですが、アウトライン構造を持つテキストの編集用です。アウト
ライン構造を把握できるようにテキストの一部を一時的に不可視にできます。カ
レントバッファのメジャーモードをアウトライン（outline）モードに切り替え
るには、`M-x outline-mode'と打ちます。

アウトライン（outline）モードで行を不可視にすると、その行は画面上に表示
されません。画面上では、不可視にした行が削除されたかのように見えますが、
それに先行する可視な行の末尾に省略記号（ピリオドが3つ...）が表示されます
（何行不可視にしていても、省略記号は1つだけ）。

`C-n'や`C-p'のような行を対象とした編集コマンドは、不可視にした行のテキス
トを、先行する可視な行の一部であるかのように扱います。改行も含めて可視な
行全体をキルすると、後続の不可視な行も一緒にキルします。

アウトラインマイナ（outline-minor）モードは、メジャーモードであるアウト
ライン（outline）モードと同じコマンドを提供しますが、他のメジャーモード
と一緒に使用できます。カレントバッファでアウトラインマイナ
（outline-minor）モードをオンにするには、`M-x outline-minor-mode'と打ち
ます。`mode: outline-minor'といった形のファイルにローカルな変数で、テキ
ストファイルにアウトラインマイナ（outline-minor）モードを指定することも
できます（*Note File Variables::）。

メジャーモードであるアウトライン（outline）モードでは、プレフィックス
`C-c'に特別なキーバインディングを設定しています。アウトラインマイナ
（outline-minor）モードでは、`C-c @'をプレフィックスとして同様のバインディ
ングがあります。これは、一緒に用いるメジャーモードの特別なコマンドとの衝
突を減らすための措置です。（変数`outline-minor-mode-prefix'で、実際に使
用するプレフィックスを制御する。）

アウトライン（outline）モードに入ると、フック`text-mode-hook'に続けてフッ
ク`outline-mode-hook'を実行します（*Note Hooks::）。

* Menu:

* Format: Outline Format.	   What the text of an outline looks like.
* Motion: Outline Motion.	   Special commands for moving through
                                     outlines. 
* Visibility: Outline Visibility.  Commands to control what is visible.
* Views: Outline Views.            Outlines and multiple views.



File: emacs-ja.info, Node: Outline Format, Next: Outline Motion, Up: Outline Mode

アウトラインの形式
------------------

アウトライン（outline）モードは、バッファの中には2種類の行、つまり、"見
出し行"（heading lines）、"本体行"（body lines）があると仮定します。見出
し行は、アウトラインのトピックを表していて、1つ以上の星印で始まります。
星印の個数は、アウトライン構造における見出しの深さを表します。つまり、星
印1つの見出し行は主要なトピックを表します。この行とつぎの星印1個の行のあ
いだにある星印2個の見出し行は、この行の下位トピックです。星印がいくつで
あってもこのような関係が成り立ちます。見出し行以外は本体行です。これらは
直前の見出し行に属します。以下に例を示します。

     * Food
     This is the body,
     which says something about the topic of food.

     ** Delicious Food
     This is the body of the second-level header.

     ** Distasteful Food
     This could have
     a body too, with
     several lines.

     *** Dormitory Food

     * Shelter
     Another first-level topic with its header line.

見出し行とそれに続く本体行をまとめて"項目"（entry）と呼びます。また、見
出し行と、それに続くさらに深いレベルの見出し行とそれらの本体行をまとめて
"部分木"（subtree）と呼びます。

変数`outline-regexp'に値を設定して、見出し行を判定する基準をカスタマイズ
できます。この正規表現に行頭が一致する行を見出し行とみなします。（左端か
らではなく）行の途中で一致するものは、無視します。一致したテキストの長さ
によって、見出しのレベルを決定します。一致したテキストが長いほどレベルが
深くなります。したがって、たとえば、清書系に章や節を分ける`@chapter'、
`@section'、`@subsection'といったコマンドがある場合、これらの行を見出し
として扱えばよいのですが、それには`outline-regexp'に
`"@chap\\|@\\(sub\\)*section"'と設定します。これには、ちょっとしたトリッ
クがあります。2つの単語、`chapter'と`section'は同じ長さですが、正規表現
では、`chap'だけに一致するように定義することで、章見出しに一致するテキス
トの長さのほうを短くできます。これによって、アウトライン（outline）モー
ドは、章（chapter）の中に節（section）が含まれるとわかるのです。他のコマ
ンドが`@chap'で始まらない限り、この設定は有効です。

変数`outline-level'を設定すると、見出し行のレベル計算方法を変更できます。
`outline-level'の値は、引数を取らない、現在の見出しのレベルを返す関数で
ある必要があります。Cモード、nroffモード、Emacs Lispモードといったメジャー
モードのいくつかでは、アウトラインマイナ（outline-minor）モードが有効に
働くように、この変数を設定します。



File: emacs-ja.info, Node: Outline Motion, Next: Outline Visibility, Prev: Outline Format, Up: Outline Mode

アウトライン上での移動コマンド
------------------------------

アウトライン（outline）モードには、前後の見出し行に移動する特別なコマン
ドがあります。

`C-c C-n'
     つぎの可視な見出し行にポイントを移動する
     （`outline-next-visible-heading'）。
`C-c C-p'
     まえの可視な見出し行にポイントを移動する
     （`outline-previous-visible-heading'）。
`C-c C-f'
     ポイント位置と同じレベルのつぎの可視な見出し行にポイントを移動する
     （`outline-forward-same-level'）。
`C-c C-b'
     ポイント位置と同じレベルのまえの可視な見出し行にポイントを移動する
     （`outline-backward-same-level'）。
`C-c C-u'
     より浅い（より多くの項目を含む）レベルで、可視な見出し行にポイント
     を移動する（`outline-up-heading'）。

`C-c C-n'（`outline-next-visible-heading'）は、つぎの見出し行にポイント
を移動します。`C-c C-p'（`outline-previous-visible-heading'）も同様です
が、逆向きにポイントを移動します。どちらのコマンドも、数引数を反復回数と
して受け取ります。コマンドの名前は、不可視な見出し行を飛び越えることを強
調していますが、これは何も特別な機能ではありません。行を探すようなすべて
の編集コマンドは、不可視な行を自動的に無視します。

もっと強力な移動コマンドは、見出しのレベル構造を把握して移動を行うもので
す。`C-c C-f'（`outline-forward-same-level'）と`C-c C-b'
（`outline-backward-same-level'）は、アウトライン構造中で同じレベルにあ
る別の見出し行にポイントを移動します。`C-c C-u'（`outline-up-heading'）
は、より浅いレベルの見出し行へ戻るようにポイントを移動します。



File: emacs-ja.info, Node: Outline Visibility, Next: Outline Views, Prev: Outline Motion, Up: Outline Mode

アウトラインの可視／不可視制御コマンド
--------------------------------------

アウトライン（outline）モードの特別なコマンドとして、行を可視／不可視に
するものもあります。これらのコマンドの名前は、すべて`hide'あるいは`show'
で始まります。これらのほとんどは、逆の機能のコマンドと対になっています。
これらのコマンドはアンドゥ可能ではありませんが、実行直後ならば戻すことは
できます。行を可視／不可視にするのは、アンドゥ機構に単純に記録するのでは
ありません。

`C-c C-t'
     バッファ中の本体行をすべて不可視にする（`hide-body'）。
`C-c C-a'
     バッファ中のすべての行を可視にする（`show-all'）。
`C-c C-d'
     ポイント位置の見出し行を除いて、その下位レベルのすべてを不可視にす
     る（`hide-subtree'）。
`C-c C-s'
     ポイント位置の見出し行、本体、下位の見出し／本体、すべてを可視にす
     る（`show-subtree'）。
`C-c C-l'
     ポイント位置の見出し行の本体と下位の見出し行のすべての本体を不可視
     にする（`hide-leaves'）。
`C-c C-k'
     ポイント位置の見出し行の下位の見出し行をすべて可視にする
     （`show-branches'）。
`C-c C-i'
     ポイント位置の見出し行の直下（1レベル深い）の下位見出しを可視にする
     （`show-children'）。
`C-c C-c'
     ポイント位置の見出し行の本体を不可視にする（`hide-entry'）。
`C-c C-e'
     ポイント位置の見出し行の本体を可視にする（`show-entry'）。
`C-c C-q'
     最上位のNレベルまでを除き、すべてを不可視にする（`hide-sublevels'）。
`C-c C-o'
     ポイント位置の見出し行や本体、および、そこから最上位レベルに至るま
     でに通過する見出し行を除き、すべて不可視にする（`hide-other'）。

`C-c C-c'（`hide-entry'）と`C-c C-e'（`show-entry'）の2つのコマンドは、
正反対の機能を持っています。これらは、見出し行にポイントがある場合 (1)
(*Note Outline Visibility-Footnotes::) に、その本体のみに作用します。下
位見出しとその本体は影響を受けません。

もっと強力で機能が正反対のコマンドは、`C-c C-d'（`hide-subtree'）と`C-c
C-s'（`show-subtree'）です。どちらも見出し行にポイントがあるとき (2)
(*Note Outline Visibility-Footnotes::) に使い、見出しの"部分木"内のすべ
ての行つまり、本体、直接／間接に関わらずあらゆる下位の見出しとその本体、
に作用します。つまり、部分木には、その見出し行に続くつぎの同レベルか上位
レベルの見出し行の直前までが含まれます。

可視な部分木と、すべて不可視な部分木の中間的な状態には、本体は不可視で下
位の見出し行はすべて可視といったものも存在します。この状態を作り出すコマ
ンドは2つあり、本体を不可視にするか、下位見出しを可視にするかです。これ
らは、`C-c C-l'（`hide-leaves'）と`C-c C-k'（`show-branches'）です。

`C-c C-i'（`show-children'）は、`show-branches'より少し弱いコマンドです。
これは、直下の、つまり1レベル深い見出し行だけを可視にします。より深いレ
ベルの見出しは不可視ならば不可視のままです。

ファイル全体に効果がおよぶ2つのコマンドがあります。`C-c C-t'
（`hide-entry'）は本体行をすべて不可視にするので、アウトライン構造だけを
眺めることができます。`C-c C-a'（`show-all'）は、すべての行を可視にしま
す。`C-c C-a'は本体行以外にも作用しますが、これらのコマンドは正反対の機
能の対と考えることができます。

コマンド`C-c C-q'（`hide-sublevels'）は、最上位レベルの見出し以外をすべ
て不可視にします。数引数Nを指定すると、最上位からNレベルまでの見出し行を
除いたすべてを不可視にします。

コマンド`C-c C-o'（`hide-other'）は、ポイント位置の見出しあるいは本体、
その親（アウトライン構造においてポイント位置から最上位レベルまで至る見出
し）を除いたすべてを不可視にします。

変数`selective-display-ellipses'に`nil'を設定すると、可視な行の末尾に現
れる省略記号を消せます。そうすると、不可視な行の存在を示すものは何もなく
なります。

インクリメンタルサーチでアウトライン（outline）モードが不可視にしている
テキストを探しだすと、バッファのその部分は可視になります。その箇所で探索
から抜けると、テキストは可視のまま (3) (*Note Outline
Visibility-Footnotes::)になります。


File: emacs-ja.info  Node: Outline Visibility-Footnotes, Up: Outline Visibility

(1) 【訳注】ポイントが本体行にあっても動作する。

(2) 【訳注】ポイントが本体行にあっても動作し、結果も同じ。

(3) 【訳注】抜けると、また不可視にもどってしまう。




File: emacs-ja.info, Node: Outline Views, Prev: Outline Visibility, Up: Outline Mode

複数の視点からアウトラインを眺める
----------------------------------

1つのアウトライン構造を同時に2つの視点から別々のウィンドウに表示して眺め
ることができます。それには、`M-x make-indirect-buffer'を使って間接バッファ
を作成する必要があります。このコマンドの最初の引数は、既存のアウトライン
用バッファの名前で、2番目の引数は新たに作成する間接バッファの名前です。
*Note Indirect Buffers::。

間接バッファがあるならば、`C-x 4 b'や他のEmacsコマンドで普通にそのバッファ
をウィンドウに表示できます。テキストの一部を可視／不可視にするアウトライ
ン（outline）モードのコマンドは、各バッファで独立に働きます。その結果、
各バッファごとに独自の視点を持たせることが可能です。同じアウトラインに対
して3つ以上の視点が必要ならば、間接バッファをさらに作成してください。



File: emacs-ja.info, Node: TeX Mode, Next: Nroff Mode, Prev: Outline Mode, Up: Text

TeXモード
=========

TeXは、Donald Knuthが作成した強力な清書系です。しかも、GNU Emacsと同じく
フリーです。LaTeXは、TeXの入力形式を単純化したもので、TeXのマクロで実現
されています。これもTeXに付属しています。SliTeXはスライドを作成するため
にLaTeXを特殊化したものです。

Emacsには、TeXの入力ファイルを編集するための特別なTeXモードがあります。
このモードには、区切りの対応を検査したり、ファイル全体やその一部に対して
TeXを起動したりする機能があります。

TeXモードには3つの変種があります。それぞれ、プレインTeX（plain-tex）モー
ド、LaTeX（latex）モード、SliTeX（slitex）モードです（これら3つはメジャー
モードですが、差異はわずか）。これらのモードは、異なる3つの入力形式を編
集するように設計されています。コマンド`M-x tex-mode'は、バッファ内の内容
を調べて、LaTeXの入力なのかSliTeXの入力なのか判断します。そのいずれかで
あれば、それに適したモードを選択します。ファイルの中身がLaTeXでもSliTeX
でもなさそうであれば、プレインTeX（plain-tex）モードを選択します。ファイ
ルの内容が判断するに十分でなければ、変数`tex-default-mode'で使用するモー
ドを制御します。

`M-x tex-mode'が適切なモードを推測できなかった場合には、コマンド`M-x
plain-tex-mode'、`M-x latex-mode'、`M-x slitex-mode'で明示的にTeXの変種
を選択できます。

* Menu:

* Editing: TeX Editing.   Special commands for editing in TeX mode.
* LaTeX: LaTeX Editing.   Additional commands for LaTeX input files.
* Printing: TeX Print.    Commands for printing part of a file with TeX.



File: emacs-ja.info, Node: TeX Editing, Next: LaTeX Editing, Up: TeX Mode

TeX編集コマンド
---------------

ここでは、TeXの入力ファイルのテキストを編集するためにTeXモードに用意して
ある特別なコマンドについて述べます。

`"'
     文脈に応じて`"'、`"'、`"'を挿入する（`tex-insert-quote'）。
`C-j'
     段落区切り（空行を2つ）を挿入し、まえの段落の中括弧やドル記号の対応
     を検査する（`tex-terminate-paragraph'）。
`M-x tex-validate-region'
     リージョン内の各段落に対して、中括弧やドル記号の対応を検査する。
`C-c {'
     `{}'を挿入して、そのあいだにポイントを移動する（`tex-insert-brace
     s'）。
`C-c }'
     対応が取れていないつぎの閉じ中括弧のあとに前向きにポイントを移動す
     る（`up-list'）。

TeXでは、文字`"'はまず使いません。引用を始めるには`"'を、終るには`"'を使
います。こういったテキスト整形上の規則の下で編集作業を楽にするために、
TeXモードでは``'と`''を対で挿入する（`tex-insert-quote'）ようにキー`"'の
意味を変えています。より正確にいえば、このコマンドは白文字や開き中括弧の
あとでは`"'を、バックスラッシュのあとでは`"'を、これ以外の文字のあとでは
`"'を挿入します。

特別な文脈で`"'文字が必要であれば、`C-q'を使って挿入します。また、`"'に
数引数を指定すると、その個数分の`"'を入力します。ローカルマップからバイ
ンディング（*Note Key Bindings::）を取り除けば、`"'を展開する機能をオフ
にできます。

TeXモードでは、`$'にはTeXの数式モードの区切りの対応を確認するための特別
な構文コードが設定されています。数式モード終了を意味する`$'を挿入すると、
それに対応した数式モード開始の`$'を1秒間ほど表示します。これは、閉じ中括
弧を挿入すると、それに対応する開き中括弧を表示する機能と同じです。しかし、
`$'が数式モードを開始するものか終了するものかを知る方法がありません。し
たがって、数式モード開始の`$'を挿入しても、たとえ実際には無関係であって
も、まえにある`$'が対応しているかのように表示されてしまいます。

TeXは、中括弧を必ず対応が取れている区切りとして使います。ユーザーの中に
は、中括弧を別々に入力するよりも、つねに対応が取れている中括弧の入力を好
む人もいます。`C-c {'（`tex-insert-braces'）と打てば中括弧の対を挿入でき
ます。さらに、ポイントがそれらのあいだに置かれるので、中括弧の内側にテキ
ストを挿入できます。そのあとに、コマンド`C-c }'（`up-list'）を使って、閉
じ中括弧のうしろに移動します。

中括弧の対応を調べるコマンドは2つあります。`C-j'
（`tex-terminate-paragraph'）は、ポイントの直前の段落を検査してから、新
たな段落を始める空行を2つ挿入します。対応していない中括弧があれば、エコー
領域にメッセージを表示します。`M-x tex-validate-region'は、リージョンの
段落を1つ1つ検査します。エラーはバッファ`*Occur*'に表示されます。このバッ
ファで`C-c C-c'や`Mouse-2'を使えば、特定の非対応箇所へ移動できます。

TeXモードでは、Emacsコマンドは中括弧だけでなく、括弧（`()'）や角括弧
（`[]'）も数えています。これは、TeXの構文を検査する目的からいえば、厳密
には正しくありません。しかし、括弧や角括弧はテキスト内で対応する区切りと
してよく使われますし、各種の移動コマンドや対応関係を自動表示するコマンド
がそれらを扱えると便利です。



File: emacs-ja.info, Node: LaTeX Editing, Next: TeX Print, Prev: TeX Editing, Up: TeX Mode

LaTeX編集コマンド
-----------------

LaTeXモードと、その変種のSliTeX モードには、プレインTeX（plain-tex）では
利用できない特別な機能がいくつかあります。

`C-c C-o'
     LaTeXのブロックを表す`\begin'と`\end'を挿入し、それらのあいだにポイ
     ントを置く（`tex-latex-block'）。
`C-c C-e'
     まだ閉じていないもっとも内側のLaTeXのブロックを閉じる
     （`tex-close-latex-block'）。

LaTeXの入力では、`\begin'と`\end'がテキストのブロックをグループ化するた
めに使われます。`\begin'と対応する`\end'を（`\begin'のつぎの新しい行に）
挿入するには、`C-c C-o'（`tex-latex-block'）を使います。それらのあいだに
は空行が挿入されてポイントもそこに置かれます。ブロックの種類を入力すると
きには、補完を使えます。標準のリストに含まれないブロック名を使う場合には、
変数`latex-block-names'に設定します。つぎの例は、`theorem'、`corollary'、
`proof'を追加するものです。

     (setq latex-block-names '("theorem" "corollary" "proof"))

LaTeXの入力では、`\begin'と`\end'は対応が取れている必要があります。`C-c
C-e'（`tex-close-latex-block'）を使うと、対応が取れていない最後の
`\begin'に対応する`\end'を自動的に挿入できます。また、対応する`\begin'と
同じ字下げを`\end'にも施します。ポイントが行頭にあったときには、`\end'の
うしろで改行します。



File: emacs-ja.info, Node: TeX Print, Prev: LaTeX Editing, Up: TeX Mode

TeX印刷コマンド
---------------

バッファ全体あるいは一部のテキストに対して、Emacsの下位プロセスとしてTeX
を起動できます。特定の章だけに対してこのようにTeXを実行するのは、ファイ
ル全体の清書に時間を費すことなく、変更部分の見え方を確認するよい方法です。

`C-c C-r'
     バッファのヘッダとともに、カレントリージョンに対してTeXを起動する
     （`tex-region'）。
`C-c C-b'
     カレントバッファ全体に対してTeXを起動する（`tex-buffer'）。
`C-c TAB'
     現在のファイルに対してBibTeXを起動する（`tex-bibtex-file'）。
`C-c C-f'
     現在のファイルに対してTeXを起動する（`tex-file'）。
`C-c C-l'
     下位プロセスであるTeXの出力を表示したウィンドウをスクロールして、出
     力行の最後が見えるようにする（`tex-recenter-output-buffer'）。
`C-c C-k'
     TeXのサブプロセスを終了させる（`tex-kill-job'）。
`C-c C-p'
     最後に実行した`C-c C-r'、`C-c C-b'、`C-c C-f'の出力を印刷する。
     （`tex-print'）。
`C-c C-v'
     最後に実行した`C-c C-r'、`C-c C-b'、`C-c C-f'の出力をプレビューする
     （`tex-view'）。
`C-c C-q'
     プリンタキューを表示する（`tex-show-print-queue'）。

`C-c C-b'（`tex-buffer'）を使えば、カレントバッファの内容を下位のTeXに渡
すことができます。清書結果は一時ファイルに出力されます。それを印刷するに
は、`C-c C-p'（`tex-print'）と打ちます。そのあとで、印刷の進捗状況を確認
するには`C-c C-q'（`tex-show-print-queue'）を利用できます。TeXの出力ファ
イルを表示する機能を持った端末があれば、`C-c C-v'（`tex-view'）でプレビュー
できます。

TeXが実行時に使うディレクトリを指定するには、変数`tex-directory'に設定し
ます。デフォルトの値は`"."'です。環境変数`TEXINPUTS'に相対的なディレクト
リ名が入っていたり、TeXの`\input'コマンドに相対的なファイル名を指定して
ある場合には、`tex-directory'は`"."'である*必要*があります。さもないと、
誤った結果になるでしょう。そういった状況でなければ、`"/tmp"'のような、他
のディレクトリを設定しても安全です。

下位のTeXを起動するために使うコマンドを指定したければ、変数
`tex-run-command'、`latex-run-command'、`slitex-run-command'、
`tex-dvi-print-command'、`tex-dvi-view-command'、
`tex-show-queue-command'にそれぞれ値を設定します。`tex-dvi-view-command'
にはデフォルト値がないので、使用する端末にあわせた値を設定する*必要*があ
ります。これ以外の変数には、使用するシステムに適切と思われる（そうでない
かもしれないが）デフォルト値が設定されています。

通常は、これらのコマンドに与えるファイル名はコマンド文字列の最後にきます。
たとえば、`latex FILENAME'です。しかし、ときにはコマンドの途中にファイル
名を埋め込む必要があります。たとえば、パイプを介して出力を他のコマンドに
渡すようなコマンドの引数にファイル名を指定する場合です。ファイル名を置く
箇所は、コマンド文字列中の`*'で指定できます。たとえば、以下のように設定
します。

     (setq tex-dvi-print-command "dvips -f * | lpr")

エラーメッセージを含めたTeXからの端末出力は、`*tex-shell*'と呼ばれるバッ
ファにすべて現れます。TeXがエラーを報告した場合には、このバッファに切り
替えれば適切な入力を与えることができます（これはシェル（shell）モードと
同様に動作する。*Note Interactive Shell::）。このバッファに切り替えなく
ても`C-c C-l'と打てば、バッファの最後の行が表示されるようにスクロールで
きます。

TeXの出力が不要となったら、TeXプロセスを終了させるために`C-c C-k'
（`tex-kill-job'）と打ちます。`C-c C-b'や`C-c C-r'を使っても、動作中の
TeXプロセスを終了できます。

`C-c C-r'（`tex-region'）と打てば、任意のリージョンを下位のTeXに渡せます。
しかし、これには少々巧妙な手口を必要とします。というのは、たいていの場合、
TeXの入力ファイルの先頭部分にはパラメータの設定やマクロ定義があり、それ
らがないと残りの部分を正しく清書できないからです。この問題を解決するため
に、`C-c C-r'ではファイルの中で必須の整形コマンドを含んでいる部分を指定
できます。リージョンのまえにその部分を加えてTeXへの入力とします。ファイ
ル中の必須であると指定された部分を"ヘッダ"と呼びます。

プレインTeX（plain-tex）モードでヘッダの境界を示すには、ファイルに2つの
特別な文字列を挿入します。ヘッダの直前に`%**start of header'を、ヘッダの
直後に`%**end of header'を挿入します。どちらの文字列も2行にまたがっては
いけませんが、前後に別のテキストがあってもかまいません。これらの文字列を
持つ行もヘッダに含まれます。バッファの先頭から100行以内に`%**start of
header'が現れなければ、`C-c C-r'はヘッダがないと仮定します。

LaTeXモードでは、`\documentstyle'で始まり`\begin{document}'で終わる部分
がヘッダです。これらは、いかなる場合でもLaTeXが要求するコマンドなので、
ヘッダを認識するために特別なことをする必要はありません。

コマンド`tex-buffer'と`tex-region'は、一時的なディレクトリ上ですべての作
業を行うので、相互参照のためにTeXが必要とする補助ファイルを使用できませ
ん。一般に、これらのコマンドは、相互参照がすべて正しい必要がある最終的な
原稿の作成には適していません。

相互参照のための補助ファイルを必要とする場合には、カレントバッファのファ
イルを入力として、そのファイルを置いたディレクトリでTeXを実行する`C-c
C-f'（`tex-file'）を使います。TeXを実行するまえに、変更したすべてのバッ
ファを保存するか尋ねてきます。一般には、正しい相互参照を得るためには、
`tex-file'を2度実行する必要があります。

変数`tex-start-options-string'の値は、TeXの実行のオプションを指定します。
デフォルト値は、TeXをバッチモードで実行します。TeXを対話的に実行するには、
変数に`""'を設定します。

巨大なTeX文書は、複数のファイル、つまり、1つのメインファイルとサブファイ
ルとに分割されることがよくあります。サブファイルに対してTeXを実行しても、
うまくいくことはまずありません。メインファイルに対してTeXを実行する必要
があります。サブファイルを編集する場合でも`tex-file'を使えるように、メイ
ンファイルの名前を変数`tex-main-file'に設定できます。そうすると
`tex-file'はそのファイルに対してTeXを実行します。

`tex-main-file'のもっとも便利な使い方は、各サブファイルのローカル変数リ
ストで指定することです。*Note File Variables::。

LaTeX用ファイルであれば、カレントバッファのファイルに対する補助ファイル
を処理するためにBibTeXを使えます。BibTeXは、参考文献をデータベースで調べ
て、参考文献の節のための文献リストを準備します。コマンド`C-c TAB'
（`tex-bibtex-file'）は、カレントバッファのファイルに対する`.bbl'ファイ
ルを生成するためのシェルコマンド（`tex-bibtex-command'）を実行します。通
常は、まず`.aux'ファイルを作るために`C-c C-f'（`tex-file'）を一度実行し
てから、つぎに`C-c TAB'（`tex-bibtex-file'）を実行し、正しい相互参照を得
るために`C-c C-f'（`tex-file'）をさらに2回実行します。

どのTeXモードに入っても、フック`text-mode-hook'と`tex-mode-hook'を実行し
ます。そのあとで、`plain-tex-mode-hook'か`latex-mode-hook'の適切なフック
を実行します。SliTeXファイルに対しては、`slitex-mode-hook'を呼びます。
TeX用のシェルの開始時には、フック`tex-shell-hook'を実行します。*Note
Hooks::。



File: emacs-ja.info, Node: Nroff Mode, Next: Formatted Text, Prev: TeX Mode, Up: Text

nroffモード
===========

nroffモードはテキスト（text）モードに似ていますが、テキスト中のnroffコマ
ンドを扱えるように変更してあります。このモードに入るには、`M-x
nroff-mode'を実行します。テキスト（text）モードとは、2、3の点で異なるだ
けです。nroffコマンドを含んだ行は、すべて段落区切りとみなすので、詰め込
みによってnroffコマンドが本文に混ざってしまうことはありません。ページは
`.bp'コマンドで分割されます。コメントは`.\"'で始まります。また、テキスト
（text）モードにはない、つぎの3つの特別なコマンドがあります。

`M-n'
     nroffコマンドではないつぎの行の先頭にポイントを移動する
     （`forward-text-line'）。引数は反復回数。
`M-p'
     `M-n'と同様だが、まえの行に移動する（`backward-text-line'）。
`M-?'
     リージョン中のテキスト（nroffコマンド以外）の行数をエコー領域に表示
     する（`count-text-lines'）。

nroffモードの他の機能としては、エレクトリックnroff（electric-nroff）モー
ドがあります。これは`M-x electric-nroff-mode'でオン／オフできるマイナモー
ドです（*Note Minor Modes::）。このモードがオンのとき、グループを始める
nroffコマンドを含む行を終えるためにRET (1) (*Note Nroff
Mode-Footnotes::)を打つたびに、そのグループを終える対応したnroffコマンド
を自動的につぎの行に挿入します。たとえば、行頭で`. ( b RET' と打つと、ポ
イントのうしろに新たな行として対応するnroffコマンド`.)b'を挿入します。

nroffモードと一緒にアウトラインマイナ（outline-minor）モード（*Note
Outline Mode::）を使用すると、見出し行は`.H'のあとに（見出しのレベルにあ
たる）数字が続く形になります。

nroffモードに入ると、フック`text-mode-hook'に続いてフック
`nroff-mode-hook'が実行されます（*Note Hooks::）。


File: emacs-ja.info  Node: Nroff Mode-Footnotes, Up: Nroff Mode

(1) 【訳注】実際には`C-j'。



File: emacs-ja.info, Node: Formatted Text, Prev: Nroff Mode, Up: Text

整形済みテキストの編集
======================

"エンリッチ（enriched）モード"は、ワープロのようにWYSIWYG方式で、整形済
みテキストを含むファイルの編集を行うためのマイナモードです。現在のところ、
エンリッチ（enriched）モードの整形済みテキストには、フォント、表示色、下
線、左右端、詰め込みと幅揃えの種類を指定できます。将来的には、その他の整
形機能も実装しようと計画しています。

エンリッチ（enriched）モードはマイナモードです（*Note Minor Modes::）。
通常は、テキスト（text）モードと一緒に使います（*Note Text Mode::）。し
かしながら、アウトライン（outline）モードや段落字下げ型テキスト
（paragraph-indent-text）モードのような他のメジャーモードと一緒に使うこ
とも可能です。

Emacsは能力的には整形済みテキストのファイルをさまざまなファイル形式で格
納することができす。現在のところは、1種類の形式のみ、つまり、MIMEプロト
コルで定義された"text/enriched"形式のみを実装してあります。Emacsがどのよ
うにファイルの形式を識別し変換するかの詳細に関しては*Note ファイル書式変
換: (elisp)Format Conversion。

Emacsの配布の中には、実例として整形済みテキストファイル
`etc/enriched.doc'があります。このファイルには、本節で説明するすべての機
能の実例が盛り込まれています。また、将来の拡張に関するアイデアも述べてあ
ります。

* Menu:

* Requesting Formatted Text::   Entering and exiting Enriched mode.
* Hard and Soft Newlines::      There are two different kinds of newlines.
* Editing Format Info::         How to edit text properties.
* Faces: Format Faces.          Bold, italic, underline, etc.
* Color: Format Colors.         Changing the color of text.
* Indent: Format Indentation.   Changing the left and right margins.
* Justification: Format Justification.
                                Centering, setting text flush with the 
                                  left or right margin, etc.
* Other: Format Properties.     The "special" text properties submenu.
* Forcing Enriched Mode::       How to force use of Enriched mode.



File: emacs-ja.info, Node: Requesting Formatted Text, Next: Hard and Soft Newlines, Up: Formatted Text

整形済みテキストの編集
----------------------

text/enriched形式でEmacsが保存したファイルを訪れると、Emacsは自動的にファ
イル中の整形情報をEmacs自身の内部形式（テキスト属性）に変換し、エンリッ
チ（enriched）モードをオンにします。

新たに整形済みテキストファイルを作成するには、まず、存在しないファイルを
訪れてから、テキストを入力するまえに`M-x enriched-mode'と打ちます。この
コマンドはエンリッチ（enriched）モードをオンにします。入力されるテキスト
が正しく扱われることを保証するために、テキストを挿入するまえにエンリッチ
（enriched）モードをオンにしてください。

より一般的にいえば、コマンド`enriched-mode'は、エンリッチ（enriched）モー
ドがオフならオン、オンならオフにします。数引数を指定すると、それが正であ
ればエンリッチ（enriched）モードをオンにし、それ以外ではオフにします。

エンリッチ（enriched）モードがオンのときにバッファを保存すると、Emacsは
テキストをファイルに書き出すときに自動的にtext/enriched形式へ変換します。
ふたたびそのファイルを訪問すると、Emacsは自動的にその形式を認識してテキ
ストを変換し、エンリッチ（enriched）モードをオンにします。

通常、text/enriched形式のファイルを訪問すると、Emacsは各段落を指定された
右端に納まるように詰め込みます。この詰め込みをやめて時間を短縮するために、
変数`enriched-fill-after-visiting'に`nil'か`ask'を設定します。

しかし、エンリッチ（enriched）モードで保存したファイルを訪問するときには、
Emacsは右端の設定をテキストと一緒に保存しているので、テキストを再度詰め
込む必要はありません。

通常はEmacsが保存しないテキスト属性に対する注記（annotation）も保存する
ようにするには、変数`enriched-translations'に追加しておきます。
text/enriched規格では、非標準の注記には、`x-read-only'のように`x-'で始ま
る名前が必要なことに注目してください。これによって、あとから追加される標
準的な注記と名前が衝突しないことが保証されます。



File: emacs-ja.info, Node: Hard and Soft Newlines, Next: Editing Format Info, Prev: Requesting Formatted Text, Up: Formatted Text

ハード改行とソフト改行
----------------------

Emacsは整形済みテキスト中の改行を、"ハード"改行と"ソフト"改行の2種類に区
別します。

ハード改行は、段落の区切り、リスト内の項目、左右端に関係なく行分割がつね
に必要な箇所に用いられます。RETコマンド（`newline'）と`C-o'（`open-line'）
はハード改行を挿入します。

ソフト改行は、テキストを左右端のあいだに納めるために使用されます。自動詰
め込み（auto-fill）モードを含めたすべての詰め込みコマンドはソフト改行を
挿入し、ソフト改行だけを削除します。

ハード改行とソフト改行は見た目は同じですが、違いを理解することは重要です。
詰め込んだ段落の途中で行に分割するときにRETを使ってはいけません。あとの
詰め込みの妨げとなるハード改行を挿入してしまいます。かわりに、自動詰め込
み（auto-fill）モードに行分割を行わせて、テキストや左右端が変化しても
Emacsが適切に再度詰め込めるようにします。*Note Auto Fill::。

一方、表やリストのように、入力したとおりの行にしておく必要がある場合には、
RETで行を終えます。これらの行では、幅揃えのスタイルとして`unfilled'を指
定するのもよいかもしれません。*Note Format Justification::。



File: emacs-ja.info, Node: Editing Format Info, Next: Format Faces, Prev: Hard and Soft Newlines, Up: Formatted Text

整形情報の編集
--------------

整形済みテキストファイルの整形情報を変更するには、2つの方法があります。
キーボードコマンドを使うか、マウスを使います。

文書に属性を追加するもっとも簡単な方法は、Text Propertiesメニューを使用
することです。このメニューを出すには2つの方法があります。メニューバーの
Editメニューから選択するか、`C-mouse-2'（CTRLキーを押し下げたままマウス
の真中のボタンを押す）です。

Text Propertiesメニューのほとんどの項目には、別のサブメニューがついてい
ます。これらについては後述します。コマンドを直接実行する項目もあります。

`Remove Properties'
     Text Propertiesメニューで扱えるすべてのテキスト属性をリージョンから
     取り除く（`facemenu-remove-props'）。

`Remove All'
     *すべて*のテキスト属性をリージョンから取り除く
     （`facemenu-remove-all'）。

`List Properties'
     ポイント直後の文字のすべてのテキスト属性を表示する
     （`list-text-properties-at'）。

`Display Faces'
     定義済みフェイス一覧を表示する。

`Display Colors'
     定義済み表示色一覧を表示する。
            


File: emacs-ja.info, Node: Format Faces, Next: Format Colors, Prev: Editing Format Info, Up: Formatted Text

整形済みテキストのフェイス
--------------------------

Facesサブメニューには、`bold'、`italic'、`underline'といったEmacsで使用
できる各種フェイスが並んでいます。その中から1つを選ぶと、リージョンにフェ
イスを追加します。*Note Faces::。以下のキーボードコマンドでフェイスを指
定することもできます。

`M-g d'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`default'にする
     （`facemenu-set-default'）。
`M-g b'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`bold'にする
     （`facemenu-set-bold'）。
`M-g i'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`italic'にする
     （`facemenu-set-italic'）。
`M-g l'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`bold-italic'に
     する（`facemenu-set-bold-italic'）。
`M-g u'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`underline'にす
     る（`facemenu-set-underline'）。
`M-g o FACE RET'
     リージョン、あるいは、つぎに挿入する文字のフェイスをFACEにする
     （`facemenu-set-face'）。

前置引数を指定してこれらのコマンドを使ったり、暫定マーク（transient-mark）
モードでリージョンが選択されていなければ、これらのコマンドはつぎに入力す
る自己挿入文字だけに使うフェイスを指定します。*Note Transient Mark::。こ
れはキーボードコマンドとメニューコマンドの両方に通用します。

エンリッチ（enriched）モードには、`excerpt'と`fixed'の2つの追加フェイス
が定義されています。これらのフェイスは、text/enrichedファイル形式で使用
されるコードに対応しています。

`excerpt'フェイスは引用を表すためのものです。カスタマイズしてなければ
`italic'と同じです（*Note Face Customization::）。

`fixed'フェイスは、『この部分のテキストには固定幅フォントを使用する』と
いう意味です。現在、Emacsは固定幅フォントにだけ対応しています。したがっ
て、`fixed'の注記は今のところ必要ありません。しかしながら、将来のEmacsで
は可変幅フォントに対応したり、固定幅フォントをデフォルトとしない
text/enriched形式を表示可能な他のシステムを計画しています。ですから、固
定幅フォントをどうしても使いたい箇所には、その部分のテキストに`fixed'を
指定するべきです。

通常、`fixed'フェイスには、デフォルトと異なるフォントを使うように定義さ
れています。ところが、システムごとにさまざまなフォントがありますから、こ
の定義をカスタマイズする必要があるかもしれません。

異なるフェイスを表示できない端末ではそれらの違いを目にすることはできませ
んが、それでも、さまざまなフェイスを含む文書の編集は行えます。文書にフェ
イスや表示色を追加することもできます。それらを表示可能な端末で見たときに
フェイスや色を目にすることができます。



File: emacs-ja.info, Node: Format Colors, Next: Format Indentation, Prev: Format Faces, Up: Formatted Text

整形済みテキストの表示色
------------------------

テキストの部分ごとに前景色と背景色を指定できます。前景色を指定するメニュー
と背景色を指定するメニューがあります。これらのメニューには、そのEmacsセッ
ションのエンリッチ（enriched）モードで使っている表示色一覧が表示されます。

前置引数とともに表示色を指定したり、暫定マーク（transient-mark）モードで
リージョンが選択されていなければ、つぎに入力する自己挿入文字だけに作用し
ます。*Note Transient Mark::。そうでなければ、コマンドはリージョンに作用
します。

それぞれの表示色メニューにはもう1つ`Other'という項目があります。この項目
は、メニューに表示されていない表示色を指定するために使います。これは、ミ
ニバッファで表示色名称を読み取ります。利用可能な表示色と名前の一覧を表示
するには、Text Propertiesメニューの`Display Colors'項目を使います（*Note
Editing Format Info::）。

このようにして指定した表示色や、読み込んだ整形済みテキスト内で使われてい
る表示色は、そのEmacsセッション中は、両方の表示色メニューに追加されます。

表示色を指定するためのキーバインディングはありませんが、拡張コマンド`M-x
facemenu-set-foreground'や`M-x facemenu-set-background'を使えばできます。
どちらのコマンドもミニバッファで表示色名称を読み取ります。



