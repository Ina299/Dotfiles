Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999
Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU General
Public License" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU General Public License" may be included in a translation
approved by the Free Software Foundation instead of in the original
English.





File: emacs-ja.info, Node: Regexp Search, Next: Regexps, Prev: Word Search, Up: Search

正規表現探索
============

"正規表現"（regular expression、"regexp"と略す）とは、一致する可能性があ
る一連の（無限個でもよい）文字列を表現するパターンです。GNU Emacsでは、
インクリメンタルサーチでも一括型探索でも、正規表現を用いてつぎの一致箇所
を探索できます。

正規表現によるインクリメンタルサーチを実行するには、`C-M-s'
（`isearch-forward-regexp'）と打ちます。このコマンドは、`C-s'と同様に、
探索文字列を逐次読み取ります。ただし、探索文字列をバッファのテキストに対
して正確に照合するためのものとみなすのではなく、正規表現として扱います。
探索文字列にテキストを追加するごとに、正規表現は長くなり、新たな正規表現
を探索します。（値は関係ない）前置引数を指定して`C-s'を起動しても、前向
きに正規表現の探索を始められます。後向きに正規表現を探索するには、
`C-M-r'（`isearch-backward-regexp'）を使うか、前置引数を指定して`C-r'を
使います。

通常のインクリメンタルサーチにおいて特別な機能を持つコントロール文字は、
正規表現のインクリメンタルサーチでも同じ機能を持ちます。探索の開始直後に
`C-s'や`C-r'を打つと、最後のインクリメンタルサーチに用いた正規表現を再度
使います。つまり、正規表現を用いる探索とそうでない探索とには、それぞれ独
立のデフォルトがあるのです。`M-p'と`M-n'で参照できる探索リングもそれぞれ
別々です。

正規表現のインクリメンタルサーチでSPCを打つと、改行を含めた任意個の白文
字に一致します。ちょうど1個の空白に一致させたいのであれば、`C-q SPC'と打
ちます。

正規表現のインクリメンタルサーチ中に正規表現に文字を加えると、カーソルを
もとに戻して探索し直すことがあります。たとえば、`foo'を探索し終えたとき
に`\|bar'を追加したとします。最初の`bar'が最初の`foo'に先行する場合には、
カーソルはまえに戻ります。

正規表現の一括型探索は、関数`re-search-forward'と`re-search-backward'で
行われます。これらは、`M-x'で呼び出したり、キーに割り当てたり、あるいは、
`C-M-s RET'や`C-M-r RET'として正規表現のインクリメンタルサーチの方法で起
動したりできます。

正規表現のインクリメンタルサーチコマンドに前置引数を指定すると、
`isearch-forward'や`isearch-backward'のように、普通の文字列探索を行いま
す。*Note Incremental Search::。



File: emacs-ja.info, Node: Regexps, Next: Search Case, Prev: Regexp Search, Up: Search

正規表現の構文
==============

正規表現には、特別な使い方をする少数の文字とその他の"普通の"文字から成る
構文があります。普通の文字は、同じ文字だけに一致してそれ以外には一致しな
い単純な正規表現です。特別な文字は、`$'、`^'、`.'、`*'、`+'、`?'、`['、
`]'、および、`\'です。`\'が先行する場合を除いて、正規表現に現れるこれら
以外の文字は普通の文字です。

たとえば、`f'は特別な文字ではなく、通常の文字ですから、文字列`f'に一致し
てそれ以外の文字列には一致しない正規表現です。（これは、文字列`ff'には一
致し*ない*。）同様に、`o'は、`o'だけに一致する正規表現です。（大文字小文
字を区別しない場合、これらの正規表現は`F'や`O'にも一致するが、これらは例
外というよりは、『同じ文字列』の一般化として捉える。）

任意の2つの正規表現AとBを連結できます。その結果は、Aが文字列の始めの適当
な部分に一致して、かつ、Bが文字列の残りの部分に一致する場合に、文字列に
一致するような正規表現です。

簡単な例として、正規表現`f'と`o'を連結すると、正規表現`fo'を得ますが、こ
れは文字列`fo'だけに一致します。簡単ですね。多少とも複雑なことを行うには、
特別な文字を使う必要があります。以下にその一覧をあげます。

`. （ピリオド）'
     特別な文字であり、改行以外の任意の1文字に一致する。連結を使って
     `a.b'のような正規表現を作れる。これは、`a'で始まり`b'で終る任意の3
     文字の文字列に一致する。

`*'
     単独では構成要素ではない。直前の正規表現を可能な限り反復することを
     意味する後置演算子である。すなわち、（`o'が存在しない場合も含めて）
     `o*'は任意個の`o'に一致する。

     `*'はつねに先行する*最小*の正規表現に適用される。したがって、`fo*'
     は`fo'を繰り返すのではなく、`o'を繰り返す。この正規表現は`f'、`fo'、
     `foo'などに一致する。

     `*'を用いた構成は、一致を処理するときには、ただちに得られる限りの反
     復回数に展開される。そうしてから、残りのパターンを処理する。一致に
     失敗すると、バックトラック（後戻り）が発生して、`*'を用いた構成の反
     復回数を減らして、パターンの残りの部分が一致するようにする。たとえ
     ば、文字列`caaar'に対して`ca*ar'を一致させることを考えてみる。始め
     に、`a*'を3つの`a'すべてに一致させようとする。しかし、残りのパター
     ンが`ar'なのに`r'しか残っていないため、この試みは失敗する。そこで、
     つぎは`a*'を`a'2つだけに一致させる。こうすると、残りの正規表現も正
     しく一致する。

`+'
     `*'に似た後置演算子だが、直前の正規表現に1回以上一致する必要がある。
     たとえば、`ca+r'は、文字列`car'や`caaaar'には一致するが、文字列`cr'
     には一致ない。`ca*r'の場合は、上記の3つすべてに一致する。

`?'
     `*'に似た後置演算子だが、直前の正規表現に1回だけ一致するか、あるい
     は、1回も一致しない。たとえば、`ca?r'は、`car'や`cr'に一致するが、
     他のものには一致しない。

`[ ... ]'
     `['で始まり`]'で終る"文字集合"を表す。もっとも単純な場合は、この2つ
     の中括弧のあいだにある文字の1つ1つがこの文字集合に一致する。

     したがって、`[ad]'は、`a'1文字か`d'1文字のどちらにも一致する。
     `[ad]*'は、`a'と`d'だけから成る（空の文字列を含む）任意の文字列に一
     致する。このことから、`c[ad]*r'は、`cr'、`car'、`cdr'、`caddaar'な
     どに一致することがわかる。

     文字集合には、文字範囲の指定を含めることもでき、始めの文字と終りの
     文字のあいだに`-'を書く。つまり、`[a-z]'はすべてのASCII小文字に一致
     する。範囲指定と個々の文字を自由に織り混ぜてよく、`[a-z$%.]'のよう
     に書ける。これは、任意のASCII小文字、`$'、`%'、ピリオドに一致する。

     文字集合の内側では、正規表現の通常の特別な文字を特別扱いしないこと
     に注意。文字集合の内側では、まったく別の特別な文字、`]'、`-'、およ
     び、`^'が存在する。

     文字集合に`]'を含めるには、`]'を最初の文字として指定する必要がある。
     たとえば、`[]a]'は、`]'や`a'に一致する。`-'を含めるのであれば、`-'
     を文字集合の最初の文字か最後の文字として指定して、範囲指定のあとに
     置く。したがって、`[]-]'は、`]'と`-'の両方に一致する。

     文字集合に`^'を含めるには、`^'を文字集合の2番目以降に置く。

     大文字小文字を区別する探索で文字範囲を指定するときは、範囲の両端を、
     大文字だけ、小文字だけ、あるいは、英字以外だけで書くべきである。
     `A-z'のような大文字小文字を混ぜた文字範囲の動作は、定義が明確ではな
     く、将来のEmacsでは変更するかもしれない。

`[^ ... ]'
     `[^'は"文字の補集合"の始まりを意味し、指定した文字を除く任意の文字
     に一致する。すなわち、`[^a-z0-9A-Z]'は、英文字と数字を*除く*すべて
     の文字に一致する。

     `^'は先頭になければ文字集合では特別な意味を持たない。`^'に続く文字
     は先頭にあるものとして扱われる（いいかえれば、ここでは`-'や`]'は特
     別な意味を持たない）。

     文字の補集合は、一致しない文字として改行を指定しない限り、改行にも
     一致する。この点は、`grep'のようなプログラムでの正規表現の扱い方と
     対照的。

`^'
     空の文字列に一致する特別な文字で、テキスト行の先頭のみに一致する。
     それ以外では、一致に失敗する。したがって、`^foo'は、行頭にある`foo'
     に一致する。

`$'
     `^'と似ていて、行末のみに一致する。したがって、`x+$'は、行末にある1
     文字以上の`x'から成る文字列に一致する。

`\'
     2つの機能がある。（`\'を含む）特別な文字をクォートする（意味を抑え
     る）ことと、特別な構成を導入すること。

     `\'は特別な文字をクォートするので、`\$'は文字`$'だけに一致する正規
     表現、`\['は文字`['だけに一致する正規表現、というようになる。

注意：` '従来との互換性のために、特別な文字が、それらの特別な意味をなし
えない文脈で使われた場合には、普通の文字として扱われます。たとえば、
`*foo'では、`*'の対象となる正規表現が直前にないため、`*'は普通の文字とし
て扱われます。このようなふるまいに依存することはよい習慣ではありません。
特別な文字を書く位置に関係なく特別な文字はクォートするべきです。

多くの場合、任意の文字を伴う`\'はその文字だけに一致します。しかし、いく
つか例外があって、`\'で始まる2文字列が特別な意味を持つ場合があります。2
文字目にくる文字は、単独で使った場合には普通の文字として扱われるものです。
以下に`\'の構成を列挙します。

`\|'
     選択肢を指定する。`\|'をあいだに伴った2つの正規表現AとBは、AかBのい
     ずれかに一致する文字列に一致する正規表現となる。

     したがって、`foo\|bar'は、`foo'か`bar'に一致するが、それ以外の文字
     列には一致しない。

     `\|'は、周囲にある適用しうる正規表現の中でも最大のものに適用される。
     `\|'によるグループ化を制限するのは、これを囲む`\( ... \)'によるグルー
     プ化だけ。

     何度`\|'を使っても処理できるだけの十分なバックトラック能力がある。

`\( ... \)'
     以下の3つの目的を果たすグループ化のための構成。

       1. 他の操作に使うために一連の選択肢`\|'を括る。したがって、
          `\(foo\|bar\)x'は、`foox'か`barx'のいずれかに一致する。

       2. 後置演算子、`*'、`+'、`?'を適用できるように、複雑な正規表現を
          括る。したがって、`ba\(na\)*'は、`bananana'のように、（0個以上
          の）任意個の文字列`na'に一致する。

       3. あとで参照できるように、一致した部分文字列を記録する。

     最後の使い方は、括弧によるグループ化という考え方から派生したもので
     はない。同一の`\( ... \)'構成に与えた2つめの別の機能である。実用上、
     これら2つの意味が混同されることはない。

`\D'
     D番目に現れた`\( ... \)'に一致したテキストと同じテキストに一致する。

     一致を処理するときには、`\( ... \)'構成の末尾に達すると、この構成に
     一致したテキストの始めと終りを記録する。そして、正規表現のそれより
     うしろでは、『D番目に現れた`\( ... \)'に一致したテキスト』という意
     味で`\'に続けて数字Dを使える。

     1つの正規表現内に現れる最初の9個の`\( ... \)'に一致する文字列には、
     正規表現中で開き括弧が現れた順に、1から9までの番号を割りふる。その
     ため、`\1'から`\9'で、対応する`\( ... \)'に一致したテキストを参照で
     きる。

     たとえば、`\(.*\)\1'は、改行を含まない文字列で、かつ、前半と後半が
     同一である文字列に一致する。`\(.*\)'は前半部分に一致し、それはどの
     ようなものでもかまわない。一方、それに続く`\1'は、前半部分とまった
     く同じテキストに一致しなければならない。

     ある`\( ... \)'が、（直後に`*'がある場合などに簡単に起こりえる）複
     数回一致する場合には、最後に一致したものだけを記録する。

`\`'
     空の文字列に一致するが、一致対象であるバッファや文字列の先頭に限る。

`\''
     空の文字列に一致するが、一致対象であるバッファや文字列の末尾に限る。

`\='
     空の文字列に一致するが、ポイント位置に限る。

`\b'
     同じく空の文字列に一致するが、単語の先頭や末尾に限る。したがって、
     `\bfoo\b'は、単語として独立して現れる`foo'に一致する。`\bballs?\b'
     は、単語として独立して現れる`ball'や`balls'に一致する。

     `\b'は、バッファの先頭や末尾にあるテキストとは無関係に、バッファの
     先頭や末尾にも一致する。

`\B'
     空の文字列に一致するが、単語の先頭や末尾*以外*に限る。

`\<'
     空の文字列に一致するが、単語の先頭に限る。`\<'は、単語構成文字が続
     く場合に限って、バッファの先頭にも一致する。

`\>'
     空の文字列に一致するが、単語の末尾に限る。`\>'は、単語構成文字で終
     了している場合に限って、バッファの末尾にも一致する。

`\w'
     任意の単語構成文字に一致する。エディタの構文テーブルによってこの文
     字が決まる。*Note Syntax::。

`\W'
     単語構成文字以外の文字に一致する。

`\sC'
     構文がCである文字だけに一致する。ここで、Cは構文コードを表す文字。
     たとえば、`w'は単語構成要素を、`-'は白文字を、`('は開き括弧を表すと
     いった具合。（改行を含む）白文字は、`-'や空白で表す。

`\SC'
     構文がCでない任意の文字に一致する。

単語や構文に関連する構成要素は、構文テーブル（*Note Syntax::）の設定で制
御されます。

複雑な正規表現を以下に示します。これは、任意個の白文字がうしろに続く文末
を認識するためにEmacsが使うものです。空白とタブ文字を区別できるように、
Lispの構文で示してあります。Lisp構文では、文字列定数はダブルクォートで始
まり、ダブルクォートで終ります。`\"'は正規表現の一部としてのダブルクォー
トを表し、`\\'は正規表現の一部としてのバックスラッシュを表します。`\t'は
タブ文字、`\n'は改行文字を表します。

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

この正規表現は4つの部分が繋がってできています。ピリオド、`?'、`!'のいず
れかに一致する文字集合。閉じ中括、2種類の引用符、括弧に一致する文字集合
の任意回数の繰り返し。バックスラッシュ付きの括弧で括った、行末、タブ、空
白2つのいずれかに一致する選択肢。白文字に一致する文字集合の任意回数の繰
り返し。

これと同じ正規表現を対話的に入力するときには、タブを入力するにはTABを打
ち、改行を入力するには`C-j'を打ちます。また、Lisp構文上ではバックスラッ
シュを2つ続けてますが、対話的に入力するには、1つのバックスラッシュだけを
打ちます。



File: emacs-ja.info, Node: Search Case, Next: Replace, Prev: Regexps, Up: Search

探索と大文字小文字の区別
========================

Emacsのインクリメンタルサーチでは、小文字だけで探索文字列を指定すると、
探索対象のテキストの大文字小文字の違いを通常無視します。したがって、
`foo'を探索するように指定すると、`Foo'にも`foo'にも一致します。正規表現、
特に文字集合の場合でも同様です。`[ab]'は、`a'、`A'、`b'、`B'のいずれにも
一致します。

インクリメンタルサーチする探索文字列のどこかに大文字があると、大文字小文
字を区別して探索します。したがって、`Foo'の探索では、`foo'や`FOO'をみつ
けだせません。このことは、文字列の探索だけでなく正規表現の探索にもあては
まります。探索文字列から大文字を消去すれば、この効果はなくなります。

変数`case-fold-search'に`nil'を設定すれば、大文字小文字の違いを含めて、
すべての文字はそのとおりに一致するようになります。これは、バッファごとの
変数です。変数を変更してもカレントバッファだけに影響しますが、変更可能な
デフォルトの値があります。*Note Locals::。この変数は、置換コマンド
（*Note Replace::）やミニバッファの履歴探索コマンド（*Note Minibuffer
History::）が行う探索を含む、一括型探索にも適用されます。



File: emacs-ja.info, Node: Replace, Next: Other Repeating Search, Prev: Search Case, Up: Search

置換コマンド
============

大域的な探索置換操作は、他のエディタ (1) (*Note Replace-Footnotes::) で
必要なほどEmacsでは必要はありませんが、Emacsでも使えます。多くのエディタ
にあるような単純なコマンド`M-x replace-string'の他にも、パターンの各出現
ごとに置換するかどうか尋ねてくる`M-x query-replace'コマンドがあります。

置換コマンドは、通常、ポイントからバッファの末尾までのテキストを操作しま
す。しかし、暫定マーク（transient-mark）モードでは、マークが活性である場
合にはリージョンを操作します。置換コマンドはどれも、1つの文字列（や正規
表現）を1つの置換文字列に置き換えます。コマンド`expand-region-abbrevs'
（*Note Expanding Abbrevs::）を使って、いくつかの置き換えを並行に行うこ
とができます。

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.


File: emacs-ja.info  Node: Replace-Footnotes, Up: Replace

(1) エディタの中には、テキストに1か所の修正を加える場合でさえ、探索置換
操作が唯一の手段であるものもある。



File: emacs-ja.info, Node: Unconditional Replace, Next: Regexp Replace, Prev: Replace, Up: Replace

無条件置換
----------

`M-x replace-string RET STRING RET NEWSTRING RET'
     STRINGのすべての出現をNEWSTRINGで置換する。
`M-x replace-regexp RET REGEXP RET NEWSTRING RET'
     正規表現REGEXPに一致するものすべてをNEWSTRINGで置換する。

ポイント以降にある`foo'のすべての出現を`bar'で置き換えるには、2つの引数
`foo'と`bar'を指定したコマンド`M-x replace-string'を使います。置換はポイ
ント以降でのみ実施されますから、バッファ全体に対して置換を行いたいときに
は、まずバッファの先頭に移動しておく必要があります。バッファの末尾までに
現れるすべての出現を置換します。バッファの一部に置換を限定したいときには、
置換を実行するまえに、バッファの当該部分にナロイングしておきます（*Note
Narrowing::）。暫定マーク（transient-mark）モードにおいては、リージョン
が活性のときには、置換はリージョン内に限定されます。

`replace-string'を終了すると、ポイントは最後に置換した出現箇所に置かれま
す。マークは（`replace-string'コマンドを起動したとき）以前のポイント位置
に設定されます。その位置に戻るには`C-u C-SPC'を使います。

数引数を指定すると、単語区切りで囲まれた出現だけを置換対象とします。引数
の値は関係ありません。



File: emacs-ja.info, Node: Regexp Replace, Next: Replacement and Case, Prev: Unconditional Replace, Up: Replace

正規表現による置換
------------------

`M-x replace-string'コマンドは、1つの文字列に正確に一致するものだけを置
き換えます。これに類似したコマンド`M-x replace-regexp'は、指定したパター
ンに一致する任意のものを置き換えます。

`replace-regexp'では、NEWSTRINGが定数である必要はありません。REGEXPに一
致したものの全体あるいはその一部を参照できます。NEWSTRINGの中の`\&'は、
置換対象の文字列全体（つまり、REGEXPに一致したものの全体）を表します。
NEWSTRINGの中の`\D'（Dは数字）は、REGEXPの中のD番目の括弧のグループ化部
分に一致した部分を表します。置き換えるテキスト内に`\'を含めるには、`\\'
と入力する必要があります。

     M-x replace-regexp RET c[ad]+r RET \&-safe RET

たとえばこの例は、`cadr'を`cadr-safe'で、`cddr'を`cddr-safe'で置換します。

     M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET

この例は、逆の置換を行います。



File: emacs-ja.info, Node: Replacement and Case, Next: Query Replace, Prev: Regexp Replace, Up: Replace

置換コマンドと大文字小文字の区別
--------------------------------

置換コマンドの第1引数がすべて小文字である場合、`case-fold-search'が`nil'
以外であるときには、大文字小文字を区別せずに置換対象を探索します。
`case-fold-search'が`nil'であるときには、すべての探索において大文字小文
字を区別します。

さらに、引数NEWSTRINGが、すべて小文字、あるいは、一部が小文字のときには、
置換コマンドは、各置換対象の大文字小文字のパターンを保存しようとします。
つまり、コマンド

     M-x replace-string RET foo RET bar RET

は、小文字の`foo'を小文字の`bar'に、すべて大文字の`FOO'を`BAR'に、大文字
で始まる`Foo'を`Bar'に置換します。（`replace-string'が区別できるのは、こ
れら3つの選択肢、つまり、小文字のみ、すべて大文字、大文字で始まるだけ。）

置換文字列に大文字を使ったときには、これを挿入するときは大文字は大文字の
ままです。第1引数に大文字を使ったときには、第2引数では大文字小文字を変換
せずにつねに指定どおりに置き換えます。同様に、`case-replace'や
`case-fold-search'に`nil'を設定すると、大文字小文字を変換せずに置換しま
す。



File: emacs-ja.info, Node: Query Replace, Prev: Replacement and Case, Up: Replace

問い合わせ型置換
----------------

`M-% STRING RET NEWSTRING RET'
`M-x query-replace RET STRING RET NEWSTRING RET'
     STRINGのいくつかの出現をNEWSTRINGで置換する。
`C-M-% REGEXP RET NEWSTRING RET'
`M-x query-replace-regexp RET REGEXP RET NEWSTRING RET'
     正規表現REGEXPに一致するもののいくつかをNEWSTRINGで置換する。

`foo'のすべての出現ではなく、そのうちのいくつかだけを`bar'に変更したいと
きには、通常の`replace-string'を使うことはできません。かわりに、`M-%'
（`query-replace'）を使います。このコマンドは`foo'の出現をみつけるたびに、
その出現を表示し、置換するかどうか聞いてきます。`query-replace'に数引数
を指定すると、単語区切り文字で区切られた出現だけを対象とします。通常どお
り`case-replace'が`nil'以外であれば、`replace-string'と同じく、このコマ
ンドも大文字小文字の違いを保存します。

問い合わせることを除けば、`query-replace'は`replace-string'と同様に動作
し、`query-replace-regexp'は`replace-regexp'と同様に動作します。このコマ
ンドは、`C-M-%'で実行できます。

STRINGの出現やREGEXPに一致したものが表示されたときに打てる文字はつぎのと
おりです。


`SPC'
     出現をNEWSTRINGで置換する。

`DEL'
     この出現を置換せずにつぎの出現箇所に進む。

`, （カンマ）'
     この出現を置換し、結果を表示する。そして、つぎに何をするか指示する
     文字を聞いてくる。置換自体はすでに完了しているので、この状況ではDEL
     とSPCは等価であり、つぎの出現箇所へ移動するという意味。

     この時点では、`C-r'（下記参照）を打って、置換したテキストを変更でき
     る。また、`C-x u'と打って、置換をアンドゥする（もとに戻す）こともで
     きるが、そうすると、`query-replace'を終了してしまう。さらに先の置換
     を行いたいときには、`C-x ESC ESC RET'を使って再開する必要がある
     （*Note Repetition::）。

`RET'
     これ以上何も置換しないで終了する。

`. （ピリオド）'
     この出現を置換してから、これ以上探索せずに終了する。

`!'
     これ以降、問い合わせずに残りの出現すべてを置換する。

`^'
     誤って変更してしまった場合などに、1つまえの出現箇所（あるいは置換し
     てしまった出現箇所）に戻る。これは、マークリングから位置を取り出し
     て動作する。`query-replace'は直前の1つの置換位置だけを記録するため、
     `^'を続けて入力しても意味はない。

`C-r'
     単にNEWSTRINGで置換するだけでなく、この出現を編集する必要がある場合
     などに、再帰編集レベルに入る。編集し終えて`C-M-c'で再帰編集を抜ける
     と、つぎの出現箇所に移動する。*Note Recursive Edit::。

`C-w'
     出現を削除してから、`C-r'と同様に再帰編集レベルに入る。再帰編集を使っ
     て、削除したSTRINGの出現を置き換えるテキストを挿入する。編集し終え
     て`C-M-c'で再帰編集を抜けると、つぎの出現箇所に移動する。

`C-l'
     画面を再表示する。そうしたら、この出現に対して何を行うかを指示する
     別の文字を打つ必要がある。

`C-h'
     これらのオプションの要約メッセージを表示する。そうしたら、この出現
     に対して何を行うかを指示する別の文字を打つ必要がある。

上記のコマンドの別名である文字が他にもいくつかあります。`y'、`n'、`q'は、
それぞれ、SPC、DEL、RETに等価です。

これ以外の文字は`query-replace'を終了し、その文字はキー列の一部になりま
す。したがって、`C-k'と打つと、`query-replace'を終了してから、行末までを
キルします。

一度抜けた`query-replace'を再開するには、`C-x ESC ESC'を使います。このコ
マンドは`query-replace'を繰り返します。というのは、`query-replace'はミニ
バッファで引数を読み取るからです。*Note C-x ESC ESC: Repetition。

ファイル名に対して正規表現に一致する部分を置換することで、ファイルの改名、
コピー、リンクを行うdiredコマンドについては、*Note Transforming File
Names::も参照してください。



File: emacs-ja.info, Node: Other Repeating Search, Prev: Replace, Up: Search

他の探索繰り返しコマンド
========================

正規表現に一致するものをみつけるコマンドは、他にもいくつかあります。それ
らは、ポイント位置からバッファの末尾までを操作対象とします。さらに、パター
ンに大文字が含まれていないときや、`case-fold-search'が`nil'以外であると
きには、大文字小文字の違いを無視して一致を探します。


`M-x occur RET REGEXP RET'
     REGEXPに一致するものを含むバッファ内の各行の一覧を表示する。数引数
     で、一致した各行の前後何行を表示するか指定する。デフォルトは0行。バッ
     ファの一部に探索を制限するには、その部分にナロイングする（*Note
     Narrowing::）。

     出力を表示したバッファ`*Occur*'は、もとの文脈での出現位置を探すため
     のメニューとして機能する。`*Occur*'に表示された出現を`Mouse-2'でク
     リックするか、あるいは、ポイントをそこに置いてRETを打つ。この操作に
     より、探索を行ったバッファに切り替え、選択した出現のもとの位置にポ
     イントを移動する。

`M-x list-matching-lines'
     `M-x occur'と同じ。

`M-x count-matches RET REGEXP RET'
     ポイント以降でREGEXPに一致するものの個数を表示する。

`M-x flush-lines RET REGEXP RET'
     ポイント以降にあってREGEXPに一致するものを含む各行を削除する。

`M-x keep-lines RET REGEXP RET'
     ポイント以降にあってREGEXPに一致するものを含ま*ない*各行を削除する。

さらに、Emacsから`grep'を使って、一連のファイルに対して正規表現に一致す
るものを探して、一致するものを含むファイルを順番に、あるいは、任意の順に
訪問できます。*Note Grep Searching::。


File: emacs-ja.info, Node: Fixit, Next: Files, Prev: Search, Up: Top

打ちまちがい訂正用コマンド
**************************

本章では、入力直後にテキストのまちがいに気づいたとき、あるいは、テキスト
を作成中に気が変わったときに特に便利なコマンドを説明します。

まちがった編集を訂正するもっとも基本的なコマンドは、アンドゥコマンド、
`C-x u'や`C-_'です。このコマンドは、（通常）1つのコマンド、コマンドの一
部分（`query-replace'の場合）、いくつかの連続した自己挿入文字をアンドゥ
します。`C-_'や`C-x u'を連続して繰り返すと、アンドゥ情報がある限り、次々
と以前の変更をアンドゥします。より詳しくは、*Note Undo::。

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.



File: emacs-ja.info, Node: Kill Errors, Next: Transpose, Up: Fixit

誤りの訂正
==========

`DEL'
     ポイントの直前の文字を削除する（`delete-backward-char'）。
`M-DEL'
     ポイントの直前の単語をキルする（`backward-kill-word'）。
`C-x DEL'
     ポイントから文の先頭までをキルする（`backward-kill-sentence'）。

DEL文字（`delete-backward-char'）はもっとも重要な訂正コマンドです。ポイ
ントの直前にある文字を削除します。自己挿入文字のコマンドに続けてDELを打
つと、そのコマンドを取り消すと考えることができます。しかし、コマンドを取
り消す一般的な方法はDELであるなどと誤解しないでください。

まちがいが数文字よりも長いときには、`M-DEL'や`C-x DEL'を使うほうが便利で
しょう。`M-DEL'は直前の単語の先頭までをキルし、`C-x DEL'は直前の文の先頭
までをキルします。文を書いている途中で気が変わったときには、`C-x DEL'が
特に便利です。`M-DEL'と`C-x DEL'は、キルしたテキストを`C-y'や`M-y'で戻せ
るように保存します。*Note Yanking::。

何を打とうとしているのか混乱したりわからなくなったりしたときには、打ちま
ちがいがたとえ数文字であっても`M-DEL'はとても便利です。このような場合、
画面を見ながらでないとDELでは訂正できません。`M-DEL'ならば、ほとんど何も
考えずに単語全体をキルして、入力を再開できます。



File: emacs-ja.info, Node: Transpose, Next: Fixing Case, Prev: Kill Errors, Up: Fixit

テキストの入れ替え
==================

`C-t'
     2つの文字を入れ替える（`transpose-chars'）。
`M-t'
     2つの単語を入れ替える（`transpose-words'）。
`C-M-t'
     釣り合っている2つの式を入れ替える（`transpose-sexps'）。
`C-x C-t'
     2つの行を入れ替える（`transpose-lines'）。

2つの文字を入れ替えてしまうというよくあるまちがいは、それらが隣接してい
るならば、`C-t'コマンド（`transpose-chars'）で直せます。通常、`C-t'は、
ポイントの両側にある文字を入れ替えます。行末では、行末の文字と改行文字を
入れ替えるという役に立たないことではなくて、`C-t'はその行の最後の2文字を
入れ替えます。よって、入れ替えまちがいにすぐに気づいたなら、`C-t'だけで
訂正できます。まちがいにすぐに気づかなかったときには、2つの入れ替わって
いる文字のあいだにカーソルを移動する必要があります。空白とそのまえの単語
の最後の文字とを入れ替えてしまったときには、単語移動コマンドでその場所へ
戻るのがよいでしょう。それ以外の場合には、後向き探索（`C-r'）が最良であ
ることがままあります。*Note Search::。


`M-t'（`transpose-words'）は、
ポイントの直前の単語とポイントの直後の単語を入れ替えます。
ポイントは単語を1つ前向きに横断し、
ポイントの直前の単語かポイントを含む単語を前向きに引きずっていきます。
単語のあいだにある句読点文字は動きません。
たとえば、`FOO, BAR'は`BAR FOO,'ではなくて、
`BAR, FOO'と入れ替わります。

`C-M-t'（`transpose-sexps'）は、2つの式（*Note Lists::）を入れ替えるコマ
ンドです。また、`C-x C-t'（`transpose-lines'）は、行を入れ替えます。これ
らのコマンドは`M-t'に似た動作をしますが、テキストを構文単位に分ける点が
異なります。

入れ替えコマンドに数引数を指定すると、反復回数になります。ポイントの直前
やポイントを含む文字（単語、S式、行）をいくつ先の文字（単語、S式、行）へ
移動するか指定します。たとえば、`C-u 3 C-t'は、ポイントの直前の文字を3文
字先の文字へ移動します。つまり、`f-!-oobar'を`oobf-!-ar'にします。これは 
`C-t'を3回繰り返したのと同じことです。`C-u - 4 M-t'は、ポイントの直前の
単語を4つまえの単語へ移動します。`C-u - C-M-t'は、引数を指定しない
`C-M-t'の効果を打ち消します。

数引数0には特別な意味があります（さもないと、コマンドを0回繰り返しても何
もしない）。ポイントの直後の文字（単語、S式、行）とマークの直後の文字
（単語、S式、行）を入れ替えます。



File: emacs-ja.info, Node: Fixing Case, Next: Spelling, Prev: Transpose, Up: Fixit

大文字小文字変換
================

`M-- M-l'
     ポイントの直前の単語を小文字に変換する。`Meta--'はメタ・マイナス。
`M-- M-u'
     ポイントの直前の単語をすべて大文字に変換する。
`M-- M-c'
     ポイントの直前の単語を最初の文字だけ大文字にして残りを小文字にする。

とてもよくあるまちがいは、単語を打つときに大文字小文字をまちがうことです。
このため、単語の大文字小文字を変換するコマンド、`M-l'、`M-u'、`M-c'に負
の引数を指定すると、カーソル（ポイント）を移動しないという特別な機能があ
ります。単語を打ちまちがえたとすぐに気づいたときには、単に大文字小文字を
変換して、入力を続けられます。*Note Case::。



File: emacs-ja.info, Node: Spelling, Prev: Fixing Case, Up: Fixit

綴りの検査と訂正
================

本節では、1つの単語やバッファのある部分の綴りを検査するコマンドを説明し
ます。これらのコマンドは、Emacsの一部ではない綴り検査プログラム（スペル
チェッカ）ispellを使って動作します。*Note Ispell: (ispell.info)Top。

`M-x flyspell-mode'
     フライスペル（flyspell）モードをオンにする。綴り誤りのあるすべての
     単語を強調表示する。
`M-$'
     ポイント位置にある単語の綴りを検査し訂正する（`ispell-word'）。
`M-TAB'
     綴り辞書に基づいてポイントの直前の単語を補完する
     （`ispell-complete-word'）。
`M-x ispell-buffer'
     バッファ内の各単語の綴りを検査し訂正する。
`M-x ispell-region'
     リージョン内の各単語の綴りを検査し訂正する。
`M-x ispell-message'
     引用部分を除いて、メイルメッセージの草稿の各単語の綴りを検査し訂正
     する。
`M-x ispell-change-dictionary RET DICT RET'
     辞書としてDICTを使ってispellプロセスを再起動する。
`M-x ispell-kill-ispell'
     ispellプロセスを終了させる。

フライスペル（flyspell）モードは、Emacsで編集しているときに全自動で綴り
検査をする方法です。単語を変更したり挿入したりするたびにその単語を検査し
ます。認識できない単語をみつけると、その単語を強調表示します。これはユー
ザーの編集には干渉しませんが、ある単語が強調表示されたら、その単語へ移動
して訂正できます。カレントバッファでこのモードをオン／オフするには、`M-x
flyspell-mode'と打ちます。

フライスペル（flyspell）モードがある単語を綴りまちがいであると強調表示し
たときには、その単語を`Mouse-2'でクリックできます。すると、訂正候補やど
んな操作を行えるか表示されます。単語を手動で編集して好きなように訂正して
もかまいません。

Emacsの他の綴り検査機能は、明示的にコマンドを実行したときに単語の検査を
行います。バッファ全体やその一部分の綴りを検査する機能は、Emacsセッショ
ン以外で作成した綴り誤りを含むかもしれないテキストには有益です。

ポイントの周りかポイントのつぎにある単語の綴りを検査し、場合によっては訂
正するには、`M-$'（`ispell-word'）コマンドを使います。単語が正しくないと
きには、その単語についてどうするかのさまざまな選択肢を提示します。

カレントバッファ全体を検査するには、`M-x ispell-buffer'を使います。カレ
ントリージョンだけを検査するには、`M-x ispell-region'を使います。書きか
けの電子メイルメッセージの綴りを検査するには、`M-x ispell-message'を使い
ます。これは、バッファ全体を検査しますが、字下げしてある部分や他のメッセー
ジからの引用と思われる部分は検査しません。

これらのコマンドは、正しくない単語に出会うたびに、どうするか聞いてきます。
通常、検査した単語に似ている『近い』単語をいくつか含めた選択肢一覧を表示
します。そうしたら、文字を打たなくてはなりません。以下に有効な返答をあげ
ます。

`SPC'
     この単語をスキップする。この単語は正しくないとしておくが、ここでは
     変更しない。

`r NEW RET'
     （今回だけは）NEWで置き換える。

`R NEW RET'
     単語をNEWで置き換える。さらに、バッファの他の箇所でも置き換えられる
     ように`query-replace'を実行する。

`DIGIT'
     （今回だけは）この単語を『近い』単語の1つで置き換える。『近い』単語
     にはそれぞれ数字が付いているので、その数字を打つ。

`a'
     正しくない単語を容認する。この編集セッションに限って、正しいかのよ
     うに扱う。

`A'
     正しくない単語を容認する。この編集セッションのこのバッファに限って、
     正しいかのように扱う。

`i'
     この単語を個人辞書ファイルに入れ、ispellは今後のセッションを含めて
     これ以降この単語を正しいものとして扱う。

`u'
     この単語を小文字に変換して個人辞書ファイルに入れる。

`m'
     `i'と同様だが、辞書の補完情報も記録できる。

`l WORD RET'
     WORDに一致する単語を辞書から探す。みつかった単語は、新たな『近い』
     単語一覧となり、数字を打って置き換える単語を選べる。WORDには、ワイ
     ルドカード`*'を使うこともできる。

`C-g'
     対話的な綴り検査を終了する。`C-u M-$'で、あとで再開できる。

`X'
     `C-g'と同じ。

`x'
     対話的な綴り検査を終了し、綴り検査を始めた箇所へポイントを戻す。

`q'
     対話的な綴り検査を終了し、ispellプロセスを終了させる。

`C-l'
     画面を再描画する。

`C-z'
     このキーは普通のコマンドの意味（Emacsを休止する、あるいは、このフレー
     ムをアイコン化する）。

テキスト（text）モードやその関連したモードでは`M-TAB'キーにバインドして
あるコマンド`ispell-complete-word'は、綴り訂正に基づいた補完一覧を提示し
ます。単語の始めの部分を挿入してから`M-TAB'と打つと、補完一覧ウィンドウ
を表示します。補完一覧から1つを選ぶには、候補のうえで`Mouse-2'をクリック
するか、カーソルを補完ウィンドウの単語の箇所に移動してからRETと打ちます。
*Note Text Mode::。


一度綴り検査を行うと、ispellプロセスは（何かすることを待って）動き続けま
す。ですから、つぎに綴り検査コマンドを使うと、より早く実行を完了します。
ispellプロセスを取り除きたいときには、`M-x ispell-kill-ispell'を使います。
ispellプロセスは綴り訂正をしているとき以外には何もしないので、通常はこの
コマンドを使う必要はありません。

ispellは2つの辞書を使います。標準辞書と個人辞書です。変数
`ispell-dictionary'は、使用すべき標準辞書のファイル名を指定します。この
値が`nil'ならば、デフォルトの辞書を使います。`M-x
ispell-change-dictionary'コマンドはこの変数を設定して、設定した辞書を使
うようにispellサブプロセスを再起動します。



File: emacs-ja.info, Node: Files, Next: Buffers, Prev: Fixit, Up: Top

ファイルの扱い方
****************

オペレーティングシステムは、データを指定した"ファイル"（file）に恒久的に
保存します。ですから、Emacsで編集するテキストの多くはファイルから取り込
み、最終的にはファイルに格納されます。

ファイルを編集するには、Emacsに対してファイルを読むように指示して、ファ
イルの内容のコピーを入れたバッファを用意させる必要があります。これを、ファ
イルを"訪問する／訪れる"（visiting）といいます。編集コマンドはバッファ内
のテキストに直接作用します。つまり、Emacs内にあるコピーを操作します。バッ
ファをファイルに"保存"（save）した場合に限り、変更はファイルそのものに反
映されます。

ファイルを訪問したり保存したりすることに加えて、Emacsは、ファイルを、削
除したり、コピーしたり、名前を変更したり、別のファイルへ追加したり、複数
の版を保持したり、ファイルディレクトリを操作したりできます。

* Menu:

* File Names::          How to type and edit file-name arguments.
* Visiting::            Visiting a file prepares Emacs to edit the file.
* Saving::              Saving makes your changes permanent.
* Reverting::           Reverting cancels all the changes not saved.
* Auto Save::           Auto Save periodically protects against loss of data.
* File Aliases::        Handling multiple names for one file.
* Version Control::     Version control systems (RCS, CVS and SCCS).
* Directories::         Creating, deleting, and listing file directories.
* Comparing Files::     Finding where two files differ.
* Misc File Ops::       Other things you can do on files.
* Compressed Files::    Accessing compressed files.
* Remote Files::        Accessing files on other sites.
* Quoted File Names::   Quoting special characters in file names.



File: emacs-ja.info, Node: File Names, Next: Visiting, Up: Files

ファイル名
==========

ファイルを操作するほとんどのEmacsコマンドには、ファイル名を指定する必要
があります。（保存と復元の操作を除く。バッファはこれらの操作に対して使う
ファイル名を記録している。）ファイル名は、ミニバッファを使って入力します
（*Note Minibuffer::）。長いファイル名の指定を簡単にする補完も使えます。
*Note Completion::。

多くの操作には、"デフォルトファイル名"があり、RETだけを打って空の引数を
指定した場合に使われます。通常、デフォルトファイル名は、カレントバッファ
で訪問したファイルの名前です。こうすることで、Emacsのファイルコマンドで
当該ファイルを操作するのが簡単になります。

各バッファにはデフォルトディレクトリがあります。通常は、そのバッファの訪
問先のファイルのディレクトリと同じです。ディレクトリを指定しないでファイ
ル名を入力すると、デフォルトディレクトリを使います。スラッシュ（`/'）で
始まらない相対的なディレクトリを指定すると、デフォルトディレクトリ相対に
解釈します。デフォルトディレクトリは変数`default-directory'に保持されて
いて、バッファごとに別々の値を持ちます。

たとえば、デフォルトファイル名が`/u/rms/gnu/gnu.tasks'ならば、デフォルト
ディレクトリは`/u/rms/gnu/'です。ディレクトリを指定しないで`foo'とだけ打
つと、`/u/rms/gnu/foo'を意味します。`../.login'は、`/u/rms/.login'を意味
します。`new/foo'は、ファイル名`/u/rms/gnu/new/foo'を意味します。

コマンド`M-x pwd'は、カレントバッファのデフォルトディレクトリを表示し、
コマンド`M-x cd'は、それを（ミニバッファで読んだ値に）設定します。バッファ
のデフォルトディレクトリは、`cd'コマンドを使ったときだけ変更されます。ファ
イルを訪問しているバッファのデフォルトディレクトリは、訪問したファイルの
ディレクトリに初期化されます。`C-x b'で作ったバッファのデフォルトディレ
クトリは、その時点のカレントバッファのデフォルトディレクトリと同じです。

デフォルトディレクトリは、ミニバッファでファイル名を読むときに、実際にミ
ニバッファに表示されます。これには2つの目的があります。デフォルトが何で
あるかを*示す*ことで、相対ファイル名を打ち込めるようにし、しかも、その意
味を確実に知ることができるようにします。もう1つは、デフォルトディレクト
リを*編集*して、別のディレクトリを指定できるようにします。変数
`insert-default-directory'を`nil'に設定すると、デフォルトディレクトリを
挿入しません。

ミニバッファで入力するとき、テキストの一部として入っているデフォルトディ
レクトリを無視して、絶対ファイル名を打っても何の問題もありません。最終的
なミニバッファの内容は不正なように見えても、そうではありません。たとえば、
ミニバッファには`/usr/tmp/'が入っていて`/x1/rms/foo'を追加すると、
`/usr/tmp//x1/rms/foo'となります。Emacsは連続した2個のスラッシュの始めの
スラッシュまでをすべて無視するので、結果として`/x1/rms/foo'となります。
*Note Minibuffer File::。

ファイル名の中の`$'は環境変数で置き換えられます。たとえば、シェルコマン
ド`export FOO=rms/hacks'で、環境変数`FOO'を設定してあるとします。そうす
ると、`/u/rms/hacks/test.c'の略称として`/u/$FOO/test.c'や
`/u/${FOO}/test.c'を使えます。環境変数の名前は、`$'のうしろにある英数字
全部です。あるいは、`$'のうしろにある括弧で囲まれたものです。シェルコマ
ンドで設定した環境変数がEmacsに影響を及ぼすのは、Emacsを起動するまえに設
定したものに限ります。

名前の中に`$'があるファイルを参照するには、`$$'と打ちます。1個の`$'に対
して変数の置き換えを行うときに、この2個の`$'は1個の`$'に変換されます。あ
るいは、ファイル名全体を`/:'でクォートします（*Note Quoted File Names::）。

（変数の）置き換えを行うLisp関数は`substitute-in-file-name'です。置き換
えは、ミニバッファで読んだファイル名だけに適用されます。

変数`file-name-coding-system'に`nil'以外を設定すると、ファイル名に非
ASCIIを含めることができます。*Note Specify Coding::。



File: emacs-ja.info, Node: Visiting, Next: Saving, Prev: File Names, Up: Files

ファイルを訪問する
==================

`C-x C-f'
     ファイルを訪問する（`find-file'）。
`C-x C-r'
     ファイルを眺めるために訪問し、変更を許さない（`find-file-read-onl
     y'）。
`C-x C-v'
     最後に訪問したファイルのかわりに、別のファイルを訪問する
     （`find-alternate-file'）。
`C-x 4 f'
     別のウィンドウでファイルを訪問する（`find-file-other-window'）。選
     択されているウィンドウに表示されている内容は変化しない。
`C-x 5 f'
     新たなフレームでファイルを訪問する（`find-file-other-frame'）。選択
     されているフレームに表示されている内容は変化しない。
`M-x find-file-literally'
     ファイルの内容をいっさい変換せずに訪問する。

ファイルを"訪問する／訪れる"とは、ファイルの内容のコピーを編集できるよう
にEmacsバッファに入れることです。Emacsは、訪問する各ファイルごとに新たに
バッファを作ります。バッファ名は、ディレクトリ部分を取りさったファイル名
から作ります。たとえば、ファイル名`/usr/rms/emacs.tex'のバッファ名は
`emacs.tex'となります。その名前のバッファがすでに存在するならば、まだ使
われていない名前になるようなもっとも小さい数を使って、`<2>', `<3>'などを
付加して唯一の名前を作ります。

各ウィンドウのモード行にはウィンドウ内に表示しているバッファ名が示されて
いるので、編集しているバッファが何かいつでもわかります。

編集コマンドによる変更は、Emacsバッファに対して行われます。バッファを"保
存"するまでは、変更は、訪問先のファイルや他のどんな恒久的なものにも影響
しません。バッファを保存するとは、バッファの現在の内容をそのバッファの訪
問先のファイルに書き出すことです。*Note Saving::。

バッファに未保存の変更がある場合、バッファは"変更されている"といいます。
バッファを保存しないと変更内容が失われてしまうので、これは重要なことです。
モード行の左端近くに2個の星印を表示して、バッファが変更されていることを
示します。

ファイルを訪問するには、コマンド`C-x C-f'（`find-file'）を使います。この
コマンドに、訪問したいファイル名を続けてRETで終えます。

ファイル名はミニバッファ（*Note Minibuffer::）で読まれ、このときデフォル
トや標準的な方法の補完を使えます（*Note File Names::）。ミニバッファ内で
`C-g'と打てば、`C-x C-f'をアボートできます。

`C-x C-f'が正しく完了したことは、画面上に新たに現れるテキストとモード行
に現れる新たなバッファ名で確認できます。指定したファイルが存在せず作成も
できない場合や読めない場合には、エコー領域にエラーメッセージが表示されま
す。

すでに訪問しているファイルを再度訪問すると、`C-x C-f'は別のコピーを作ら
ずに、そのファイルを入れた既存のバッファを選択します。しかし、そうするま
えに、訪問してから、あるいは、保存してから以降にファイルが変更されたかど
うか検査します。ファイルが変更されていると警告メッセージを表示します。
*Note Interlocking::。

新たにファイルを作りたいときにはどうするのでしょう？` ' 単に訪問すればよ
いのです。Emacsはエコー領域に`(New File)'と表示しますが、それ以外に関し
ては、あたかも空のファイルが存在するかのようにふるまいます。変更してから
保存すれば、ファイルを作成できます。

Emacsはファイルの内容から、行区切りの方法、すなわち、（GNU/LinuxやUNIXで
使われる）改行、（Microsoftシステムで使われる）復帰改行、（Machintoshで
使われる）復帰のみを認識します。さらに、Emacsの通常の方法、つまり、改行
文字で行を区切るように内容を自動的に変換します。これは、コーディングシス
テム変換（*Note Coding Systems::）の一般的な機能の一部であり、さまざまの
異なるオペレーティングシステムから持ってきたファイルを同一の方法で編集で
きるようにします。テキストを変更してファイルに保存すると、Emacsは逆変換
を行い、必要ならば、改行を復帰改行や復帰のみに戻します。

指定したファイルが実際にはディレクトリならば、`C-x C-f'はEmacsのディレク
トリブラウザであるdiredを起動するので、ディレクトリの内容を『編集』でき
ます（*Note Dired::）。diredは、ディレクトリ内のファイルを、消去したり、
眺めたり、操作するのに便利です。しかし、変数 `find-file-run-dired'が
`nil'ならば、ディレクトリを訪問しようとするとエラーになります。

指定したファイル名にワイルドカード文字が含まれていると、Emacsは一致する
すべてのファイルを訪問します。ワイルドカード文字そのものを含む名前のファ
イルを訪問するには、*Note Quoted File Names::。

オペレーティングシステムが変更を許さないファイルを訪問すると、Emacsはバッ
ファを読み出し専用に設定するので、修正できなかったり、修正できてもあとで
保存に手間取ります。`C-x C-q'（`vc-toggle-read-only'）で、バッファを書き
込み可能にできます。*Note Misc Buffer::。

ときには、自分でまちがって変更しないように、ファイルを読み出し専用で訪問
したい場合があります。そういう場合には、コマンド`C-x C-r'
（`find-file-read-only'）でファイルを訪問します。

（ファイル名をまちがって打ったりして）存在しないファイルを意図せずに訪問
してしまったときには、`C-x C-v'コマンド（`find-alternate-file'）を使って
本当の目的のファイルを訪問します。`C-x C-v'は`C-x C-f'と同様ですが、（バッ
ファが変更されていればまず保存するかどうか聞いてから）カレントバッファを
消去します。訪問するファイル名を読むときには、ミニバッファにデフォルトファ
イル名全体を挿入し、ディレクトリ部分の直後にポイントを置きます。これは、
ファイル名をほんの少しまちがって入力したときに便利です。

存在するのに読めないファイルを訪問すると、`C-x C-f'はエラーを通知します。

`C-x 4 f'（`find-file-other-window'）は、別のウィンドウで、指定したファ
イルを入れたバッファを選択することを除けば、`C-x C-f'と同じです。`C-x 4
f'を実行するまえに選択されていたウィンドウは、同じバッファを表示したまま
です。ウィンドウを1つだけ表示しているときにこのコマンドを使うと、そのウィ
ンドウを2つに分けて、一方のウィンドウにはまえと同様に同じバッファを表示
しますが、もう一方には新たに指示したファイルを表示します。*Note
Windows::。

`C-x 5 f'（`find-file-other-frame'）も同様ですが、新たなフレームを開くか、
捜しているファイルを表示している既存のフレームを見えるようにします。ウィ
ンドウシステムを使っているときだけ、この機能を利用できます。*Note
Frames::。

特別な符号化や変換をせずにファイルを文字の列として編集したいときには、
`M-x find-file-literally'コマンドを使います。このコマンドは、`C-x C-f'の
ようにファイルを訪問しますが、形式変換（*Note Formatted Text::）、文字コー
ド変換（*Note Coding Systems::）、（圧縮を）自動展開（*Note Compressed
Files::）といったことをしません。（そのままの文字の列としてではなく）普
通の方法で同じファイルをすでに訪問している場合には、このコマンドは、その
ままの文字の列として訪問するかどうか聞いてきます。

2つの特別なフック変数で、ファイルを訪問する操作を修正して拡張できます。
存在しないファイルを訪問すると、`find-file-not-found-hooks'のリスト内の
関数群を実行します。この変数は関数のリストを保持していて、呼び出した関数
の中のどれかが`nil'以外を返すまで1つ1つ順に呼び出します。ファイルが存在
するかどうかに関わらず、どんなファイルを訪問するときでも
`find-file-hooks'には関数のリストが入っていると仮定され、それらの1つ1つ
を順にすべて呼び出します。いずれの場合でも、関数は引数を受け取りません。
2つの変数のうち、先に`find-file-not-found-hooks'を使います。これらの変数
はノーマルフックではありま*せん*。これらの名前が`-hook'ではなくて
`-hooks'で終っていることで、その事実を表しています。*Note Hooks::。

編集するファイルに対して自動的にメジャーモード（*Note Choosing Modes::）
を設定し、そのファイルに対して特別なローカル変数（*Note File Variables::）
を定義する方法がいくつかあります。



File: emacs-ja.info, Node: Saving, Next: Reverting, Prev: Visiting, Up: Files

ファイルを保存する
==================

Emacsにおいてバッファを"保存"するとは、バッファの内容をそのバッファの訪
問先のファイルへ書き戻すことです。

`C-x C-s'
     カレントバッファを訪問先のファイルに保存する（`save-buffer'）。
`C-x s'
     任意のバッファかすべてのバッファをそれぞれの訪問先のファイルに保存
     する（`save-some-buffers'）。
`M-~'
     カレントバッファを変更していないことにする（`not-modified'）。
`C-x C-w'
     カレントバッファを指定したファイルに保存する（`write-file'）。
`M-x set-visited-file-name'
     カレントバッファを保存するファイルの名前を変更する。

ファイルを保存して変更を恒久的なものとするには、`C-x C-s'（`save-buffer'）
と打ちます。保存を完了すると`C-x C-s'はつぎのようなメッセージを表示しま
す。

     Wrote /u/rms/gnu/gnu.tasks

選択されているバッファが変更されていなければ（バッファを作って以降、ある
いは、最後に保存して以降に、変更されていない）、保存しても何もならないの
で実際には保存しません。かわりに、`C-x C-s'はつぎのようなメッセージをエ
コー領域に表示します。

     (No changes need to be saved)

コマンド`C-x s'（`save-some-buffers'）は、変更された任意のバッファやすべ
てのバッファを保存できるようにします。各バッファについて、何をするか聞い
てきます。このとき選べる返答は、`query-replace'に対するものに似ています。

`y'
     このバッファを保存し、残りのバッファについても質問する。
`n'
     このバッファを保存しないが、残りのバッファについては質問する。
`!'
     このバッファを保存し、残りのすべてのバッファについても質問せずに保
     存する。
`RET'
     何も保存せずに`save-some-buffers'を終了する。
`.'
     このバッファを保存し、他のバッファについては何も聞かずに
     `save-some-buffers'を終える。
`C-r'
     質問対象のバッファを閲覧する。閲覧（view）モードから抜けると、
     `save-some-buffers'に戻りふたたび質問する。
`C-h'
     これらのオプションについてのヘルプメッセージを表示する。

Emacsから抜けるキー列`C-x C-c'は、`save-some-buffers'を起動するので、同
じ質問をしてきます。

バッファを変更したけれども変更を保存したくないならば、それを避けるための
処置をすべきでしょう。そうしないと、`C-x s'や`C-x C-c'を使うたびに、まち
がってバッファを保存してしまいがちです。1つの方法は、`M-~'
（`not-modified'）と打つことです。これは、バッファが変更されていることを
示すフラグを消します。こうしておくと、保存コマンドはバッファを保存する必
要がないと結論します。（`~'は「否定」（not）を意味する数学記号としてしば
しば使われる。よって`M-~'は、メタ付き「否定」。）`set-visited-file-name'
（下記参照）を使って、別のファイルを訪問しているバッファである旨の印を付
けることもできます。このときファイル名には、重要でない使っていないものを
指定します。あるいは、ファイルからテキストを再度読み直して、ファイルを訪
問したり保存したりした以降のすべての変更を取り消します。これを"復元"
（reverting）といいます。*Note Reverting::。すべての変更がもとに戻るまで
アンドゥコマンド`C-x u'を繰り返し使って、変更しなかったことにもできます。
しかし、復元のほうが簡単です。

`M-x set-visited-file-name'は、カレントバッファで訪問しているファイルの
名前を変更します。このコマンドは、ミニバッファで新たなファイル名を読み取
ります。そして、訪問先ファイル名を設定し直し、それに従って（新しい名前が
使われていなければ）バッファ名も変更します。`set-visited-file-name'は、
新たに指定した訪問先のファイルへはバッファを保存しません。あとで保存する
場合に備えて、Emacs内部の記録を変更するだけです。また、バッファには『変
更された』旨の印を付け、`C-x C-s'がそのバッファを保存*しようとする*よう
にします。

別のファイルを訪問しているという旨の印をバッファに付けて、ただちに保存し
たい場合には、`C-x C-w'（`write-file'）を使います。このコマンドは、
`set-visited-file-name'に続けて`C-x C-s'を実行するのと等価です。ファイル
を訪問していないバッファに対して`C-x C-s'を使うことは、`C-x C-w'と同じ効
果があります。つまり、ファイル名を読み取り、バッファにはそのファイルを訪
問しているという印を付け、バッファをそのファイルに保存します。ファイルを
訪問していないバッファのデフォルトのファイル名は、バッファのデフォルトディ
レクトリとバッファ名を組み合わせて作ります。

新しいファイル名がメジャーモードを示唆するものであれば、`C-x C-w'は、多
くの場合、そのメジャーモードに切り替えます。コマンド
`set-visited-file-name'もそのようにします。*Note Choosing Modes::。

Emacsがファイルを保存しようとするときに、ディスク上の最新版の日付がEmacs
が最後に読み書きしたものと合わなかったら、Emacsはそのことを通知します。
というのは、同時に編集したために引き起こされた問題である可能性があるので、
ユーザーにただちに知らせる必要があるからです。*Note Interlocking::。

変数`require-final-newline'が`nil'以外だと、Emacsはファイルを保存するた
びに、ファイルの末尾に改行がなければ改行を挿入します。デフォルトは`nil'
です。

* Menu:

* Backup::              How Emacs saves the old version of your file.
* Interlocking::        How Emacs protects against simultaneous editing
                          of one file by two users.



File: emacs-ja.info, Node: Backup, Next: Interlocking, Up: Saving

バックアップファイル
--------------------

多くのオペレーティングシステムでは、ファイルを書き換えるとファイルに入っ
ていたそれまでの記録は自動的に破棄されます。したがって、Emacsでファイル
を保存すると、ファイルの古い内容は捨てられます。しかし、実際に保存するま
えに、古い内容を"バックアップ"ファイルと呼ばれる別のファイルにEmacsが注
意深くコピーすれば、古い内容は破棄されません。

ほとんどのファイルでは、バックアップファイルを作るかどうかは変数
`make-backup-files'で決まります。多くのオペレーティングシステムでは、こ
の変数のデフォルト値は`t'であり、Emacsはバックアップファイルを作ります。

版管理システム（*Note Version Control::）が管理するファイルに対しては、
バックアップファイルを作るかどうかは変数`vc-make-backup-files'で決まりま
す。デフォルトは`nil'です。というのは、すべての古い版を版管理システムに
保管してあるので、バックアップファイルは冗長だからです。*Note VC
Workfile Handling::。

変数`backup-enable-predicate'のデフォルト値は、`/tmp'にあるファイルのバッ
クアップファイルを作らないようにします。

Emacsでは、単一のバックアップファイルを保持することも、編集した各ファイ
ルごとに一連の番号付きバックアップファイルを保持することもできます。

Emacsがファイルのバックアップファイルを作るのは、バッファからそのファイ
ルへ最初に保存したときだけです。たとえ何度ファイルを保存したとしても、そ
のバックアップファイルは、ファイルを訪問する以前の内容を保持し続けます。
通常これは、今の編集セッションを始める以前の内容をバックアップファイルが
保持していることを意味します。しかしながら、バッファを消去してから再度ファ
イルを訪問すると、それ以降に保存するときには新たにバックアップファイルを
作ります。

少なくとも一度は保存したとしても、バッファからもう1つバックアップファイ
ルを作るように明示的に指示することもできます。`C-u C-x C-s'でバッファを
保存すると、このとき保存した版は、バッファを再度保存するときにはバックアッ
プファイルになります。`C-u C-u C-x C-s'もバッファを保存しますが、まずファ
イルの古い内容をバックアップファイルにします。`C-u C-u C-u C-x C-s' はそ
の両方を行います。ファイルの以前の内容からバックアップファイルを作り、さ
らに、バッファを再度保存するとこのとき保存した版からもう1つバックアップ
ファイルを作るように準備します。

* Menu:

* Names: Backup Names.		How backup files are named;
				  choosing single or numbered backup files.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.



File: emacs-ja.info, Node: Backup Names, Next: Backup Deletion, Up: Backup

単一バックアップファイルと番号付きバックアップファイル
......................................................

単一バックアップファイルを作ることを選択すると（デフォルト）、バックアッ
プファイルの名前は、編集しているファイルの名前に`~'を付加したものになり
ます。したがって、`eval.c'のバックアップファイルは`eval.c~'となります。

番号付きの一連のバックアップファイルを作ることを選択すると、バックアップ
ファイルの名前は、もとのファイル名に`.~'と数字ともう1つ`~'を付加したもの
になります。したがって、`eval.c'のバックアップファイルは、`eval.c.~1~'、
`eval.c.~2~'、…、`eval.c.~259~'というようにどこまでも続きます。

保護機構のために普通の名前でバックアップファイルを書けなくなると、ユーザー
のホームディレクトリの`%backup%~'にバックアップファイルを書きます。その
ファイルはたった1つしか存在できないので、最新のバックアップにしか利用で
きません。

単一バックアップか番号付きバックアップかの選択は、変数`version-control'
で制御されます。この変数に設定できる値はつぎのとおりです。

`t'
     番号付きバックアップを作る。
`nil'
     ファイルに対して番号付きバックアップファイルがすでにあるならば番号
     付きバックアップを作る。さもなければ、単一バックアップを作る。
`never'
     どんな場合にも番号付きバックアップを作らない。つねに単一バックアッ
     プを作る。

各バッファではローカルに`version-control'を設定できるので、そのバッファ
のファイルに対するバックアップの作成方法を制御できます。たとえば、rmail
モードでは、rmailファイルのバックアップを1個だけに限定するために、
`version-control'にはローカルに`never'を設定します。*Note Locals::。

環境変数`VERSION_CONTROL'を設定すると、さまざまなGNUユーティリティにどの
ようにバックアップファイルを扱うか指示できます。Emacsも環境変数に従って
動作し、開始時にそれに一致するようにLisp変数`version-control'を設定しま
す。環境変数の値が`t'か`numbered'なら、`version-control'は`t'になります。
環境変数の値が`nil'か`existing'なら、`version-control'は`nil'になります。
環境変数の値が`never'か`simple'なら、`version-control'は`never'になりま
す。



File: emacs-ja.info, Node: Backup Deletion, Next: Backup Copying, Prev: Backup Names, Up: Backup

バックアップの自動削除
......................

ディスク容量を無限に浪費することを避けるために、Emacsは番号付きバックアッ
プの版を自動的に削除できます。一般には、Emacsは始めの数個と最新の数個の
バックアップを残して、そのあいだのものをすべて削除します。これは、新たに
バックアップを作るごとに行われます。

2つの変数`kept-old-versions'と`kept-new-versions'は、このような削除を制
御します。それらの値は、それぞれ、新たにバックアップを作るときに、保持す
べき最古（番号が最小）のバックアップの個数、保持すべき最新（番号が最大）
のバックアップの個数です。それらの値は、バックアップの新版を作った直後に
使われることに注意してください。新たに作ったバックアップも、
`kept-new-versions'の数に含まれます。デフォルトでは、どちらの変数も2です。

`delete-old-versions'が`nil'以外ならば、何もいわずに余分な中間の版を削除
します。デフォルト値である`nil'ならば、余分な中間の版を削除するかどうか
を聞いてきます。

diredの`.'（ピリオド）コマンドも古い版を削除するために使えます。*Note
Dired Deletion::。



File: emacs-ja.info, Node: Backup Copying, Prev: Backup Deletion, Up: Backup

コピーと改名
............

バックアップファイルは、古いファイルをコピーする、あるいは、それを改名す
ることで作ります。古いファイルに複数の名前があると、これには違いが出てき
ます。古いファイルを改名してバックアップファイルにすると、（古いファイル
の）別の名前もバックアップファイルを指します。古いファイルをコピーした場
合には、（古いファイルの）別の名前は編集しているファイルを指し続け、その
名前で参照される内容も新しい内容になります。

バックアップファイルを作る方法は、元ファイルの所有者とグループにも影響し
ます。コピーするならば、何も変更されません。改名すると、ファイルの所有者
はあなたになり、ファイルのグループはデフォルトになります（オペレーティン
グシステムごとにグループのデフォルトは異なる）。

所有者を変更することは、多くの場合、よいことです。というのは、所有者がつ
ねに最後にファイルを編集した人を表すからです。同様に、バックアップの所有
者はその版を作った人を表します。ときには、ファイルの所有者を変更すべきで
ないファイルがあります。そのようなファイルについては、
`backup-by-copying-when-mismatch'をローカルに設定するローカル変数リスト
をファイルに入れておくのがよいです。

改名するかコピーするかは、3つの変数で制御されます。デフォルトは、改名で
す。変数`backup-by-copying'が`nil'以外ならばコピーします。`nil'のときに
は、変数`backup-by-copying-when-linked'が`nil'以外ならば、複数の名前を持
つファイルではコピーし、編集中のファイルには名前が1つだけなら改名します。
変数`backup-by-copying-when-mismatch'が`nil'以外のときには、改名するとファ
イルの所有者やグループが変更されるときにはコピーします。スーパーユーザー
でEmacsを起動すると、`backup-by-copying-when-mismatch'のデフォルトは`t'
です。

ファイルを版管理システム（*Note Version Control::）で管理している場合に
は、通常Emacsはそのファイルのバックアップを通常の方法では作りません。チェッ
クインとチェックアウトは、ある意味でバックアップを作ることに似ています。
残念なことに、これらの操作は典型的にはハードリンクを切るという類似性があ
ります。つまり、あるファイルの別の名前を使っていたとするとそのファイル名
がなくなるのです。Emacsにできることはありません。版管理システムが処理し
ます。



File: emacs-ja.info, Node: Interlocking, Prev: Backup, Up: Saving

同時編集に対する保護
--------------------

2人のユーザーが同じファイルを訪問し、両者がそれを編集し、両者がそれを保
存すると、同時編集が発生します。こういったことが起きていることを誰も知ら
せなければ、最初に保存したユーザーは、あとになって自分の変更が失われてい
ることを知るでしょう。

ある種のシステムでは、2人目のユーザーがファイルを変更し始めたことをEmacs
がただちに検知して警告を発します。すべてのシステムでは、ファイルを保存す
るときにEmacsが検査して、他人の変更を上書きしようとしているならば警告し
ます。ファイルを保存するかわりに適切な修正操作を行えば、他人の作業結果を
失うことを避けられます。

ファイルを訪問しているEmacsバッファで初めて修正を行うと、Emacsはそのユー
ザーがファイルを"ロック"したと記録します。（同じディレクトリ内に異なる名
前のシンボリックリンクを作ることで実現する。）変更を保存するとEmacsはロッ
クを消します。つまり、ファイルを訪問しているEmacsバッファに未保存の変更
があるときにはファイルをロックしておくのです。

他人がロックしているファイルを訪問先とするバッファを修正し始めると"衝突"
が起こります。Emacsが衝突を検知すると、Lisp関数`ask-user-about-lock'を呼
び出して、どうするかを聞いてきます。この関数をカスタマイズのために再定義
することもできます。この関数の標準の定義では、ユーザーに質問をし、3つの
返答を受理します。

`s'
     ロックを横取りする。ファイルをすでに変更していた人はロックを失い、
     あなたがロックを得る。
`p'
     続行する。誰かがファイルをロックしたままであるにもかかわらず、ファ
     イルを編集する。
`q'
     放棄する。これはエラー（`file-locked'）を引き起こし、バッファ内で修
     正しようとしたことは、実際には行われない。

ロックはファイル名に基づいて動作することに注意してください。ファイルに複
数の名前があると、Emacsには2つの名前が同じファイルであることはわからない
ので、2人のユーザーが異なる名前で同じファイルを編集することは防げません。
しかし、名前に基づいたロックなので、保存しない限り実在しない新規ファイル
の編集をEmacsはインターロック (1) (*Note Interlocking-Footnotes::) でき
ます。

Emacsがロックを作れる構成になっていないシステムもあります。また、ロック
ファイルを書けない場合もあります。こういった状況では、Emacsがあらかじめ
トラブルを検知することはできませんが、他人の変更を上書きしてファイルを保
存しようとしたときには、衝突を検知できます。

Emacsやオペレーティングシステムがクラッシュすると、古いロックファイルが
残っていることあります。そのため、ときどき偽の衝突についての警告を受けと
ることがあるかもしれません。偽の衝突であると確信できれば、Emacsにとにか
く続行するように指示する`p'を使います。

Emacsは、バッファを保存するたびに、ディスク上のファイルの最終変更日時が
最後に訪問／保存したときから更新されていないことをまず検査します。変更日
時が不一致ならば、なんらかの方法でそのファイルが変更されたことを示し、
Emacsが本当に保存するとそれらの変更が失われてしまいます。これを避けるた
めに、Emacsは警告のメッセージを表示し、保存するまえに確認を求めます。ファ
イルが変更された理由を承知していて、それが問題でないことを知っていること
もあるでしょう。そうならば、`yes'と答えて続行できます。さもなければ、
`C-g'で保存を中断して、その事態を調査するべきです。

同時編集が発生したことを知らされたときにまず行うべきことは、`C-u C-x
C-d'（*Note Directories::）でディレクトリ一覧を見ることです。このコマン
ドは、ファイルの現在の所有者を表示します。その人に連絡して、編集を続けな
いように警告しましょう。そのつぎの段階は、別の名前でEmacsバッファを保存
して、`diff'で2つのファイルを比較することでしょう。


File: emacs-ja.info  Node: Interlocking-Footnotes, Up: Interlocking

(1) 【訳注】進行中の動作が完了するまでは、つぎの動作を開始させないように
すること。



File: emacs-ja.info, Node: Reverting, Next: Auto Save, Prev: Saving, Up: Files

バッファを復元する
==================

広範囲にファイルを変更したあとで気が変わったときには、そのような変更を捨
てるためにファイルのまえの版を読み込みます。これには、カレントバッファに
作用する`M-x revert-buffer'を使います。意図せずにバッファを復元すること
は、たくさんの作業結果を失うことになるので、このコマンドには`yes'で確認
を与える必要があります。

`revert-buffer'は、ファイルの先頭から同じ距離（文字数）にポイントを保ち
ます。少し編集しただけなら、復元前後のポイント位置はだいたい同じ部分にあ
ります。徹底的に変更してしまったときには、古いファイルでのポイント位置で
はまったく異なるテキスト部分に位置付けるでしょう。

復元すると、改めて変更するまでは、そのバッファには『変更なし』の印が付き
ます。

diredバッファのように、ファイル以外のデータを反映するバッファでも復元で
きる場合があります。その場合、復元とは、適切なデータに基づいて内容を計算
し直すことを意味します。`C-x b'で明示的に作ったバッファを復元することは
できません。そういった指示をすると、`revert-buffer'はエラーを報告します。

自動的にかつ頻繁に変更されるファイル、たとえば、実行中のプロセスから出力
されるログ、を編集するときには、`C-x C-f'でファイルを再訪問すると何も聞
かずにファイルを復元できると便利です。

こういったふるまいを指示するには、変数`revert-without-query'に正規表現の
リストを設定します。これらの正規表現の1つにファイル名が一致すると、
`find-file'と`revert-buffer'は、バッファが変更されていない限り、そのファ
イルが変更されていても復元します。（テキストを編集してしまったときには、
変更を捨てさるのはまちがっている。）



File: emacs-ja.info, Node: Auto Save, Next: File Aliases, Prev: Reverting, Up: Files

自動保存、不慮の事故に対する備え
================================

Emacsは（打鍵数に基づいて）定期的に、訪問しているすべてのファイルを何も
聞かずに保存します。これを"自動保存"（auot-saving）と呼びます。これは、
システムがクラッシュしたときに失ってしまう作業結果をある程度以下に制限し
ます。

自動保存を実施する時間になるとEmacsは各バッファを調べて、そのバッファに
自動保存が指定されていて、かつ、最後に自動保存した以後に変更されている場
合は、そのバッファを自動保存します。実際にファイルを自動保存すると、エコー
領域にメッセージ`Auto-saving...'を表示します。自動保存の最中に発生したエ
ラーは捕獲されるので、打ち込んだコマンドの実行に干渉することはありません。

* Menu:

* Files: Auto Save Files.       The file where auto-saved changes are
                                  actually made until you save the file.
* Control: Auto Save Control.   Controlling when and how often to auto-save.
* Recover::		        Recovering text from auto-save files.



File: emacs-ja.info, Node: Auto Save Files, Next: Auto Save Control, Up: Auto Save

自動保存ファイル
----------------

自動保存は、通常、訪問先のファイルそのものへは保存しません。というのは、
予定の半分を変更しただけでプログラムにまだ一貫性がないのに保存してしまう
のは望ましくないからです。そのかわりに"自動保存ファイル"と呼ばれる別のファ
イルに自動保存し、（`C-x C-s'などで）明示的に保存するよう指示されたとき
だけ、訪問先のファイルに保存します。

通常、自動保存ファイルの名前は、訪問先のファイルの名前の前後に`#'を付加
したものです。したがって、ファイル`foo.c'を訪問したバッファは、ファイル
`#foo.c#'に自動保存されます。ファイルを訪問していないほとんどのバッファ
は、明示的に指定したときだけ自動保存されます。それらのバッファの自動保存
ファイルの名前は、バッファ名のまえに`#%'、あとに`#'を付けたものになりま
す。たとえば、送信するメッセージを作成するバッファ`*mail*'は、
`#%*mail*#'というファイルに自動保存されます。自動保存ファイルの名前は、
Emacsの一部（関数`make-auto-save-file-name'と`auto-save-file-name-p'）を
プログラムし直さない限り、この方法で作られます。バッファの自動保存に使う
ファイル名は、そのバッファで自動保存をオンにしたときに計算されます。

大きなバッファで相当量のテキストを削除したときには、そのバッファの自動保
存を一時的にやめます。意図せずにテキストを削除してしまった場合には、自動
保存ファイルに削除してしまったテキストが残っているほうが、自動保存ファイ
ルとしてより役に立つからです。こうなったあとで自動保存をふたたびオンにす
るには、`C-x C-s'でバッファを保存するか、`C-u 1 M-x auto-save'を使います。

訪問先のファイルそのものに自動保存を行いたい場合には、変数
`auto-save-visited-file-name'に`nil'以外の値を設定します。こうすると、自
動保存と明示的な保存には、何の違いもありません。

訪問先のファイルにバッファを保存すると、バッファの自動保存ファイルは削除
されます。これを禁止するには、変数`delete-auto-save-files'に`nil'を設定
します。`C-x C-w'や`set-visited-file-name'で訪問先ファイル名を変更すると、
新たな訪問先ファイル名に合わせて自動保存ファイルも改名されます。



File: emacs-ja.info, Node: Auto Save Control, Next: Recover, Prev: Auto Save Files, Up: Auto Save

自動保存の制御
--------------

変数`auto-save-default'が`nil'以外ならば、ファイルを訪問するたびにそのファ
イルのバッファの自動保存をオンにします（ただしバッチモードを除く。*Note
Entering Emacs::）。この変数のデフォルトは`t'なので、通常、ファイルを訪
問したバッファは自動保存されます。コマンド`M-x auto-save-mode'で、既存バッ
ファの自動保存をオン／オフできます。他のマイナモードのコマンドと同じよう
に、正の引数を指定すると`M-x auto-save-mode'は自動保存をオンにし、0か負
の引数を指定すると自動保存をオフにし、引数を指定しないと自動保存のオン／
オフを切り替えます。

Emacsは、最後に自動保存してから何文字打鍵したかに基づいて定期的に自動保
存します。変数`auto-save-interval'には、自動保存の間隔を表す文字数を指定
します。デフォルトは300です。

しばらく打鍵しないでいるときにも自動保存は行われます。変数
`auto-save-timeout'は、自動保存（およびガベッジコレクション）を行うまで
にEmacsが待つべき秒数を表します。（カレントバッファが大きいと、実際の時
間間隔も長くなる。これは、大きなバッファの自動保存には時間がかかるので、
その編集中は邪魔にならないようにするため。）アイドルのときには、自動保存
はつぎの2つのことを達成します。1つは、端末からしばらく離れているときに、
すべての作業結果が保存されることを保証すること。もう1つは、実際に打鍵し
ているときの自動保存をいくぶんでも避けるようにすることです。

重大なエラーを受け取ったときにも、Emacsは自動保存を行います。これには、
`kill %emacs'のようなシェルコマンドでEmacsジョブを強制終了した場合や、電
話回線やネットワーク接続が途切れた場合を含みます。

コマンド`M-x do-auto-save'で、自動保存の実施を明示的に指示できます。



File: emacs-ja.info, Node: Recover, Prev: Auto Save Control, Up: Auto Save

自動保存ファイルからのデータ回復
--------------------------------

コマンド`M-x recover-file RET FILE RET'で、自動保存ファイルの内容から紛
失データを復旧できます。このコマンドは、FILEを訪問してから、（確認したあ
とで）その自動保存ファイル`#FILE#' から内容を回復します。そのあとに、
`C-x C-s'でFILEそのものに復旧したテキストを保存します。たとえば、`foo.c'
の自動保存のファイル`#foo.c#'から`foo.c'を復旧するにはつぎのようにします。

     M-x recover-file RET foo.c RET
     yes RET
     C-x C-s

`M-x recover-file'は確認するまえに、指定したファイルと自動保存ファイルが
置かれたディレクトリの一覧を表示するので、それらのサイズや日付を比較でき
ます。自動保存ファイルのほうが古いと、`M-x recover-file'はそのファイルを
読み込むようには聞いてきません。

Emacsやコンピュータがクラッシュしても、コマンド`M-x recover-session'を使
えば、編集中だったすべてのファイルを自動保存ファイルから復旧できます。こ
のコマンドは、まず、記録されている中断されたセッション一覧を表示します。
希望する箇所へポイントを移動し、`C-c C-c'と打ちます。

つぎに、 `recover-session'はそのセッションで編集中だった各ファイルについ
てそのファイルを復旧するか聞いてきます。`y'を答えると、`recover-file'を
呼び出し、普通のとおりに動作します。もとのファイルとその自動保存ファイル
の日付を表示し、ファイルを復旧するかどうかをもう一度聞いてきます。

`recover-session'が終了すると、復旧を選んだファイルはEmacsバッファに入っ
ています。これらのバッファを保存してください。こうすることで初めてファイ
ルに保存できます。

中断されたセッションは、あとで復旧するために`~/.saves-PID-HOSTNAME'とい
うファイルに記録されています。これらの名前の`~/.saves'の部分は、
`auto-save-list-file-prefix'の値です。この変数を個人の`.emacs'ファイルで
設定すれば、別の場所にセッション記録を置くことができます。しかし、同様に
`recover-session'も再定義して、変更した新しい場所を探すようにする必要が
あります。個人の`.emacs'ファイルで`auto-save-list-file-prefix'に`nil'を
設定すると、復旧のためのセッションを記録しません。



File: emacs-ja.info, Node: File Aliases, Next: Version Control, Prev: Auto Save, Up: Files

ファイル名の別名
================

シンボリックリンクやハードリンクを使うことで、同じファイルをいくつかの異
なるファイル名で指すことができます。ハードリンクは、ファイルを直接に指し
ている別の名前です。すべての名前は等しく有効で、それらに優劣はありません。
対照的に、シンボリックリンクは定義された別名の一種です。`foo'が`bar'への
シンボリックリンクであるとき、どちらの名前でもファイルを指せますが、
`bar'が本当の名前であり、`foo'は別名にすぎません。シンボリックリンクがディ
レクトリを指しているときには、より複雑な状況になります。

同一のファイルに対して2つの名前で訪問すると、Emacsは通常2つの別々のバッ
ファを作成しますが、その状況を警告します。

同一のファイルを異なる名前で別々のバッファに訪問することを避けたいならば、
変数`find-file-existing-other-name'に`nil'以外の値を設定します。そうすれ
ば、どのファイル名を指定しようとも、`find-file'はファイルを訪問している
既存のバッファを使います。

変数`find-file-visit-truename'が`nil'以外であれば、バッファに記録するファ
イル名は、ユーザーが指定した名前ではなくて、ファイルの（すべてのシンボリッ
クリンクをその先の名前に置き換えて得られる）"実名"になります。
`find-file-visit-truename'を設定すると、`find-file-existing-other-name'
も暗に設定されます。



File: emacs-ja.info, Node: Version Control, Next: Directories, Prev: File Aliases, Up: Files

VC（版管理、バージョンコントロール）
====================================

"版管理システム"は、ファイルの変更されていない部分を通常は一度だけ格納し
て、ソースファイルの複数の版を記録できるパッケージです。版管理システムは、
各版の作成時刻、作成者、その版の変更部分に関する記述などの履歴情報も記録
します。

Emacsの版管理パッケージはVCと呼ばれます。このコマンドは、3つの版管理シス
テム、RCS、CVS、SCCSで動作します。GNUプロジェクトでは、フリーソフトウェ
アでありFree Software Foundationから入手できるRCSとCVSを推奨します。

* Menu:

* Introduction to VC::  How version control works in general.
* VC Mode Line::     How the mode line shows version control status.
* Basic VC Editing::    How to edit a file under version control.
* Old Versions::        Examining and comparing old versions.
* Secondary VC Commands::    The commands used a little less frequently.
* Branches::            Multiple lines of development.
* Snapshots::           Sets of file versions treated as a unit.
* Miscellaneous VC::    Various other commands and features of VC.
* Customizing VC::      Variables that change VC's behavior.



File: emacs-ja.info, Node: Introduction to VC, Next: VC Mode Line, Up: Version Control

VC入門
------

VCはEmacsから版管理システムを使えるようにして、編集作業を版管理操作に滑
らかに統合します。VCは統一された版管理インターフェイスを提供するので、ど
の版管理システムを使っているかに関わらず、同じ使い方ができます。

本節では、版管理を概観するとともに、VCが扱う版管理システムの概要を説明し
ます。使用する版管理システムにすでに慣れているならば、本節は読み飛ばして
ください。

* Menu:

* Version Systems::  Supported version control back-end systems.
* VC Concepts::      Words and concepts related to version control.



File: emacs-ja.info, Node: Version Systems, Next: VC Concepts, Up: Introduction to VC

利用可能な版管理システム
........................

VCでは、現在3つの版管理システム、つまり、バックエンドで動作します。RCS、
CVS、SCCSの3つです。

RCSはフリーの版管理システムでFree Software Foundationから入手ができます。
RCSは、扱えるバックエンドの中では、たぶん、もっとも成熟したものです。VC
コマンド群は、RCSに概念的にもっとも近いものです。RCSでできるほとんどのこ
とはVCからもできます。

CVSは、RCSの上に作られてRCSの機能を拡張していて、より洗練されたリリース
管理、複数ユーザーの並行開発を許しています。CVSの下では、VCの基本的な編
集操作を使えますが、あまり一般的でない操作に関しては、コマンド行からCVS
を呼ぶ必要があります。CVSを使うには保管庫（リポジトリ、repository）を設
定しなければなりませんが、ここで扱うには複雑すぎる話題です。

SCCSはフリーではありませんが、版管理システムとしては広く使われています。
能力の観点からすれば、VCが扱える3つのうちでもっとも弱いです。SCCSに欠け
ている機能（たとえばスナップショット）はVC自身で実現して補っていますが、
複数の枝分かれのようなVCの他のいくつかの機能はSCCSでは利用できません。
RCSを使えない理由があるときに限ってSCCSを使うべきです。



File: emacs-ja.info, Node: VC Concepts, Prev: Version Systems, Up: Introduction to VC

VCの概念
........

ファイルが版管理の管理下にあるとき、そのファイルは版管理システムに"登録
され"ているといいます。各登録されたファイルには、ファイルの現状とその変
更履歴を記述した対応する"マスタファイル"が存在します。この情報は、現在の
版や以前の版を再構成するのに十分です。通常、マスタファイルには、それぞれ
の版について、その版の変更点を言葉で記述した"記録項目"も記録されています。

版管理の下で管理されているファイルを、そのマスタファイルに対応する"作業
ファイル"と呼ぶこともあります。普通のファイルと同様に、作業ファイルを編
集して変更します。（SCCSやRCSでは、ファイルを編集するまえにファイルを"ロッ
ク" (1) (*Note VC Concepts-Footnotes::) する必要がある。）一連の変更を終
えたら、ファイルを"チェックイン"、つまり、記録項目とともに変更をマスタファ
イルに記録します。

CVSでは、1つのマスタファイルに対応する作業ファイルを複数個持てます。しば
しば、各ユーザーが1個ずつ作業ファイルを持てます。RCSでもこのようにできま
すが、RCSの通常の使い方ではありません。

典型的な版管理システムには、複数のユーザーが同じファイルを使う際の調停を
行うためのなんらかの機構が必要です。1つの方法は（Emacsが同時編集の検出に
使うロックに類似だが、それとは別の）"ロック"を使うことです。別の方法は、
ファイルをチェックインする時点で、他人の変更分を併合することです。

ロックを使う版管理の場合、作業ファイルは変更できないように通常は読み出し
専用です。版管理システムに対して、書き込み可能な作業ファイルを作り、それ
をロックするように要求します。一度には1人のユーザーだけがこれをできます。
自分の変更分をチェックインすると、ファイルのロックを外し、作業ファイルを
ふたたび読み出し専用にします。これにより、他のユーザーがさらに変更するた
めにファイルをロックできるようになります。SCCSはつねにロックを使いますし、
RCSも通常はロックを使います。

RCSでは別の方法もあって、各ユーザーがいつでも作業ファイルを変更できます。
このモードではロックは必要ありませんが、使うこともできます。新版を記録す
る方法は、やはりチェックインです。

CVSでは、通常、各ユーザーはいつでも各自の作業ファイルを変更できますが、
チェックイン時に他のユーザーの変更分を併合する必要があります。しかし、
CVSでもロックを使うようにもできます（*Note Backend Options::）。


File: emacs-ja.info  Node: VC Concepts-Footnotes, Up: VC Concepts

(1) 【訳注】Emacsが同時編集を防ぐためのロックとは別のロック。



File: emacs-ja.info, Node: VC Mode Line, Next: Basic VC Editing, Prev: Introduction to VC, Up: Version Control

VCとモード行
------------

版管理の下にあるファイルを訪問すると、Emacsはそのことをモード行に示しま
す。たとえば、`RCS-1.3'は、そのファイルにはRCSが使われていて、現在の版が
1.3であることを表します。

バックエンドの名前と版番号のあいだの文字は、ファイルの版管理状態を示しま
す。`-'は、（ロックを使っているのであれば）作業ファイルがロックされてい
ないこと、あるいは、（ロックを使っていないのであれば）ファイルが変更され
ていないことを表します。`:'は他のユーザー（たとえば、`jim'）がロックして
いることを表し、`RCS:jim:1.3'のように表示されます。



File: emacs-ja.info, Node: Basic VC Editing, Next: Old Versions, Prev: VC Mode Line, Up: Version Control

VC下の基本的な編集
------------------

主要なVCコマンドは、状況に応じてロックかチェックインを行う汎用コマンドで
す。

`C-x C-q'
`C-x v v'
     このファイルに対して論理的なつぎの版管理操作を実施する。

正確にいえば、この操作を行うコマンドは`vc-next-action'であって、`C-x v
v'にバインドしてあります。しかし、`C-x C-q'の通常の意味は、読み出し専用
バッファを書き込み可能にするか、あるいは、その逆を行います。この操作を、
適切な版管理操作を実施することで版管理下で管理されているファイルに対して
も同じことを正しく行うように拡張したのです。登録されたファイルに対して
`C-x C-q'を打つと、`C-x v v'のように動作します。

このコマンドの正確な動作は、ファイルの状態と版管理システム（バックエンド）
がロックを使うかどうかに依存します。SCCSとRCSは通常はロックを使いますが、
CVSは通常はロックを使いません。

* Menu:

* VC with Locking::     RCS in its default mode, SCCS, and optionally CVS.
* Without Locking::     Without locking: default mode for CVS.
* Log Buffer::          Features available in log entry buffers.
               


File: emacs-ja.info, Node: VC with Locking, Next: Without Locking, Up: Basic VC Editing

ロック使用時の基本的な編集
..........................

（SCCSの場合とRCSのデフォルトの場合）ファイルに対してロックを使う場合、
`C-x C-q'は、ファイルをロックする、あるいは、ファイルをチェックインする
のいずれかを行います。

   * ファイルがロックされていなければ、`C-x C-q'はそれをロックし、変更で
     きるように書き込み可能にする。

   * 同じユーザーがファイルをロックしていて、かつ、変更されていれば、
     `C-x C-q'はチェックインを行う。このとき、新版に対する記録項目をまず
     読み取る。*Note Log Buffer::。

   * 同じユーザーがファイルをロックしているが、ロックしてからまったく変
     更していないときには、`C-x C-q'はロックを外してファイルをふたたび読
     み出し専用にする。

   * 他のユーザーがファイルをロックしている場合、`C-x C-q'はそのユーザー
     から『ロックを横取りする』かどうか聞いてくる。横取りするように答え
     ると、ファイルをロックし直すが、まえにロックしていたユーザーにはロッ
     クを横取りされたことを伝える。

以上の規則は、CVSでロックを使用している場合にも適用できますが、『ロック
を横取りする』ことはありません。



File: emacs-ja.info, Node: Without Locking, Next: Log Buffer, Prev: VC with Locking, Up: Basic VC Editing

ロック非使用時の基本的な編集
............................

CVSのデフォルトのように、ロックを使わないときには、作業ファイルはいつで
も書き込み可能です。ファイルを編集するまえにすべきことは何もありません。
モード行の状態表示は、ファイルが変更されていなければ`-'です。作業ファイ
ルに変更を保存するとただちに`:'に変わります。

以下は、CVSを使っているときの`C-x C-q'の動作です。

   * 他のユーザーが変更分をマスタファイルにチェックインしていると、それ
     らを自分用の作業ファイルに併合（*Note Merging::）するかどうか聞いて
     くる。自分の変更分をチェックインするまえには、これを行う必要がある。

   * マスタファイルに新たな変更がなくても、自分用の作業ファイルを変更し
     てある場合には、`C-x C-q'はその変更をチェックインする。これを行うた
     めに、新版に対する記録項目をまず読み取る。*Note Log Buffer::。

   * ファイルが変更されていなければ、`C-x C-q'は何もしない。

以上の規則は、RCSのロックを使わないモードにも適用できますが、マスタファ
イルから自動的に変更を併合する機能は実装してありません。残念なことに、あ
なたが編集を始めたあとに、他のユーザーが同じファイルに変更をチェックイン
しても何も警告されないのです。しかも、このような事態が発生すると、あなた
が自分の版をチェックインしたときに、そのユーザーの変更は実質的には取り除
かれてしまいます（とはいえ、マスタファイルの中には残っているので、完全に
なくなるわけではない）。したがって、自分の変更をチェックインするまえには、
現在の版が変更されていないことを確認する必要があります。Emacsの将来の版
では、このような危険性を取り除き、RCSでも自動併合を行えるように考えてい
ます。

また、このモードでもRCSのロックを使えますが、必須ではありません。ファイ
ルを変更していないときに`C-x C-q'を使うと、RCSの通常の（ロックを使う）モー
ドのように、ファイルをロックします。



