Info file: emacs-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs-ja.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です。

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs-ja).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998, 1999
Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled "The GNU Manifesto", "Distribution" and "GNU General
Public License" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled "The GNU Manifesto", "Distribution"
and "GNU General Public License" may be included in a translation
approved by the Free Software Foundation instead of in the original
English.





File: emacs-ja.info, Node: Date Formats, Next: Adding to Diary, Prev: Format of Diary File, Up: Diary

日付指定の形式
--------------

以下は日誌項目の例で、使用可能ないくつかの日付指定形式を示しています。こ
の例では日付をアメリカ形式（月、日、年）で指定していますが、カレンダー
（calendar）モードではオプションでヨーロッパ形式（日、月、年）も使用でき
ます。

     4/20/93  新しい計算システムへ切換
     apr. 25  年ごとの計算開始 
     4/30     4月分の処理完了〆切
     */25     月ごとのサイクル完了
     Friday   ファイルのバックアップを忘れないこと

最初の項目は1993年4月20日に一度だけ表示されます。2番目と3番目は毎年指定
した日付に表示され、4番目は月の指定にワイルドカード（アスタリスク、`*'）
を使っているため、毎月25日に表示されます。最後の項目は毎週金曜日に表示さ
れます。

日付には、`MONTH/DAY'や`MONTH/DAY/YEAR'のように数字だけを使ってもかまい
ません。この場合、あとに続く文字は数字であってはいけません。日付自体の
MONTH（月）とDAY（日）は1桁か2桁の数字です。YEAR（年）は省いてもかまいま
せんが、これも数字で、最後の2桁だけに省略してもかまいません。つまり、
`11/12/1989'と書いても`11/12/89'と書いても同じです。

日付を、`MONTHNAME DAY'や`MONTHNAME DAY, YEAR'と書くこともできます。ここ
で、MONTHNAMEは英語の月の名前で3文字の省略形（ピリオドがあってもなくても
よい）でもかまいません。大文字小文字は区別しません。

日付の指定は"総称的"であってもかまいません。つまり、特定しない部分があっ
てもかまいません。そうすると、その指定に一致するすべての日付にその項目が
適用されます。年を指定しなければ、それは総称的であり、その項目は毎年に適
用されます。あるいは、MONTH、DAY、YEARのそれぞれに`*'を指定できます。こ
れは、それぞれ、任意の月、任意の日、任意の年に一致します。したがって、
`3/*/*'という日誌項目は、任意の年の3月のどの日にも一致します。`march *'
も同じことです。

もし、月のまえに日を書くヨーロッパ形式で日付を指定したいときには、カレン
ダー中で`M-x european-calendar'と打ちます。あるいは、カレンダー／日誌コ
マンドを使う*まえ*に変数`european-calendar-style'に`t'を設定します。この
状態では、日誌の中のすべての日付指定をヨーロッパ形式で解釈します。また、
日誌の日付を表示するときもヨーロッパ形式です。（ヨーロッパ形式では、
MONTHNAMEのあとにはコンマは付けない。）（デフォルトの）アメリカ形式の日
付に戻るには、`M-x american-calendar'と打ちます。

ある曜日を指定する総称的な日付として曜日の名前を使えます。曜日の名前は英
語で綴り、3文字の省略形（ピリオドがあってもなくてもよい）でもかまいませ
ん。大文字小文字は問いません。



File: emacs-ja.info, Node: Adding to Diary, Next: Special Diary Entries, Prev: Date Formats, Up: Diary

日誌への追加コマンド
--------------------

カレンダー（calendar）モードの中には、日誌の項目を作成するコマンドがいく
つかあります。

`i d'
     選択した日に日誌項目を追加する（`insert-diary-entry'）。
`i w'
     選択した曜日に日誌項目を追加する（`insert-weekly-diary-entry'）。
`i m'
     選択した月の日に日誌項目を追加する（`insert-monthly-diary-entry'）。
`i y'
     選択した年の日に日誌項目を追加する（`insert-yearly-diary-entry'）。

カレンダーウィンドウ内で日を選択して`i d'コマンドを打てば、選択した日に
日誌項目を作成できます。このコマンドは、別のウィンドウに日誌ファイルの末
尾を表示し、日付を挿入します。そうしたら、日誌項目の残りの部分を打ち込み
ます。

特定の曜日に日誌項目を作成したい場合には、その曜日を選択して（どの場所で
もよい）`i w'と打ちます。これで、総称的な日付として曜日名が挿入されます。
そうしたら、日誌項目の残りの部分を打ち込みます。同様にして、月の特定の日
を選択してから`i m'コマンドを打って、項目の残りの部分を打ち込みます。同
じように、`i y'コマンドで、毎年の特定の日に項目を挿入できます。

これらのコマンドはすべて、デフォルトでは印付けされる項目を作成します。印
付け禁止の項目を作成するには、コマンドに数引数を指定します。たとえば、
`C-u i w'は毎週の印付け禁止項目を作ります。

日誌ファイルを修正したときには、Emacsを終了するまえにファイルを必ず保存
してください。



File: emacs-ja.info, Node: Special Diary Entries, Prev: Adding to Diary, Up: Diary

特別な日誌項目
--------------

カレンダーの日付に基づいて項目を追加する以外に、毎年の記念日などを表す"S
式項目"（sexp entries）を日誌ファイルに入れることができます。これらの項
目は、Emacsが日誌ファイルを読み込むときにLisp式（S式、sexp）を評価するこ
とに基づいています。S式項目では日付のかわりに、`%%'に続けて括弧で括った
Lisp式があります。Lisp式が項目を適用する日付を決定します。

カレンダー（calendar）モードには、よく使われるS式項目を追加するコマンド
があります。

`i a'
     指定した日付の毎年の記念日の日誌項目を追加する
     （`insert-anniversary-diary-entry'）。
`i b'
     カレントリージョンに対してブロック日誌項目を追加する
     （`insert-block-diary-entry'）。
`i c'
     指定した日から始まる定期的に巡ってくる日誌項目を追加する
     （`insert-cyclic-diary-entry'）。

ある特定の日を毎年の記念日に指定したい場合には、その日付にポイントを移動
してから`i a'コマンドを使います。このコマンドは、別のウィンドウに日誌ファ
イルの末尾を表示し、記念日を指定するS式を挿入します。そうしたら、日誌項
目の残りの部分を打ち込みます。以下はその例です。

     %%(diary-anniversary 10 31 1948) アーサーの誕生日

この項目は、1948年以降の毎年10月31日に適用されます。`10 31 1948'は日付を
指定します。（ヨーロッパ形式の日付を使っている場合には、`31'と`10'が入れ
替わる。）この式に開始年が必要なのは、日誌関数で経過年数の計算に使うから
です。

"ブロック"日誌項目は、指定した期間に適用されます。以下は、1990年6月24日
から1990年7月10日までに適用されるブロック日誌項目の例です。

     %%(diary-block 6 24 1990 7 10 1990) 休暇

`6 24 1990'は開始日付を表し、`7 10 1990'は終了日付を表します。（ヨーロッ
パ形式を使っている場合は、月と日が入れ替わる。）

ブロック項目を追加するには、ポイントとマークを期間の開始日付と終了日付に
設定してから`i b'と打ちます。このコマンドは、日誌ファイルの末尾を別のウィ
ンドウに表示して、ブロック項目指定を追加します。そうしたら、日誌項目の残
りの部分を打ち込みます。

"周期的"な日誌項目は、一定間隔で繰り返します。これを作るには、開始日を選
択して`i c'コマンドを使います。このコマンドは、間隔を聞いてきます。そう
したら、項目を挿入します。以下のようになります。

     %%(diary-cyclic 50 3 1 1990) つぎの投薬

この項目は1990年3月1日から始まり、50日ごとに適用されます。`3 1 1990'はこ
の開始日を指定しています（ヨーロッパ形式を使っている場合は、月と日が入れ
替わる。）

これら3つのコマンドはいずれも印付けされる項目を作成します。印付け禁止項
目を挿入する場合には、コマンドに数引数を指定します。たとえば、`C-u i a'
は、印付け禁止の記念日の項目を作ります。

日誌のS式項目をカレンダーに印付けするのは*非常に*時間がかかります。なぜ
なら、カレンダーのウィンドウに見えているすべての日付について1つ1つ調べる
必要があるからです。したがって、S式項目を登録する際にはできる限り（`&'を
付けて）印付け禁止の日誌項目にするのがよいでしょう。

S式項目の別の利用方法には、"流動型"日誌項目があります。これは毎年定期に
起きることがらを日数や週数や月数のオフセットで表したものです。これは
`cron'プログラムが解釈するcrontabの項目と互換性があります。以下は、毎年
11月の最終木曜日に印付け禁止の流動型日誌項目を指定する例です。

     &%%(diary-float 11 4 -1) アメリカの感謝祭

この11は11月を表し、4は木曜（日曜を0として週の4番目の日）を表します。
-1は『最後』を表します
（1は『最初』、2は『2番目『、-2は『最後の1つまえ』などなど）。月の指定は
1個の月でも月のリストでもかまいません。たとえば、上の11を`'(1 2 3)'に変
更すると、1月、2月、3月の最終木曜日に適用する項目になります。月の指定が
`t'ならば、すべての月に適用されます。

もっとも一般的には、日誌のS式項目は適用する日付を決定するために、どんな
計算でもできます。*Note S式項目と装飾日誌表示: (elisp)Sexp Diary Entries。



File: emacs-ja.info, Node: Appointments, Next: Daylight Savings, Prev: Diary, Up: Calendar/Diary

約束
====

日誌項目に約束が入っていて、Emacsが認識可能な形で時刻が指定されている場
合には、その予定の何分かまえに「約束がありますよ。」と警告を出す機能があ
ります。Emacsはモード行に約束がある旨の警告メッセージを表示します。

約束の警告表示を行わせるには、まずEmacsの時刻表示機能をオンにする必要が
あります。`M-x display-time'（*Note Mode Line::）と打ちます。さらに、関
数`appt-make-list'を以下のようにして`diary-hook'に追加する必要があります。

     (add-hook 'diary-hook 'appt-make-list)

個人の`.emacs'ファイルに以下のテキストを追加すれば、これまでのことを行え
ます。

     (display-time)
     (add-hook 'diary-hook 'appt-make-list)
     (diary 0)

このように準備しておくと、（カレンダーのウィンドウで`d'コマンドを使うか、
`M-x diary'コマンドを使うかして）日誌を表示したときに、Emacsが認識できる
時刻指定のある約束をすべて取り込み、それらのおのおのについて指定された時
刻よりも少しまえに警告を表示します。

たとえば、日誌ファイルに以下のような項目があるとします。

     Monday
       9:30am 休憩
      12:00pm 昼食

すると、毎週月曜には、日誌を表示していると午前9時20分にもうすぐ休憩だと
表示を出し、午前11時50分には昼食時間だと表示を出します。

時刻指定は、`9:00am'のようにam/pmスタイルでも（`12:00am'は夜中の12時、
`12:00pm'はお昼の12時を表す）、ヨーロッパや軍隊流の24時間制でもかまいま
せん。また、一貫している必要もなく、日誌ファイルにこれらが混在していても
かまいません。

Emacsはこれらの約束リストを夜中の12時過ぎに更新します。変数
`appt-display-diary'に`nil'を設定していない限り、日誌用バッファにつぎの
日の予定を表示します。

約束の警告表示を目覚し時計として利用することもできます。コマンド`M-x
appt-add'は、個人の日誌ファイルを変更せずに約束リストに項目を追加します。
`M-x appt-delete'は、約束リストから項目を削除します。

変数`appt-issue-message'に`nil'を設定すれば、約束の警告表示はいつでもオ
フにできます。



File: emacs-ja.info, Node: Daylight Savings, Prev: Appointments, Up: Calendar/Diary

夏時間
======

Emacsは標準時と夏時間の違いを理解していて、日出入、夏至、冬至、春分、秋
分、朔弦望の時刻ではこれを補正しています。夏時間の規則は、地域によっても、
また、歴史的にもさまざまです。補正を正しく行うには、使用する規則をEmacs
に与えておく必要があります。

オペレーティングシステムのなかには、その設置場所で適用する規則を記録して
いるものもあります。このようなシステムでは、Emacsは自動的に必要な情報を
システムから取得します。情報の一部や全部が欠けている場合には、現在マサ
チューセッツ州ケンブリッジで使われている規則でEmacsは欠落部分を補おうと
します。その結果が正しくないならば、変数
`calendar-daylight-savings-starts'と`calendar-daylight-savings-ends'を設
定し、規則をEmacsに与える必要があります。

これらの変数の値は、変数`year'を参照するLisp式である必要があり、評価する
と、グレゴリオ暦での夏時間の開始日や終了日を表す`(MONTH DAY YEAR)'という
形のリストになる必要があります。在住地方で夏時間を採用していない場合には、
これらの値は`nil'にしておきます。

Emacsはこれらの式を用いて夏時間の開始日を決定し、祝祭日一覧や太陽や月に
関する計算の時刻補正に使います。

マサチューセッツ州ケンブリッジの値は以下のとおりです。

     (calendar-nth-named-day 1 0 4 year)
     (calendar-nth-named-day -1 0 10 year)

`year'で指定される年の4月の最初の日曜日（0番目）から始まり、その年の10月
の最後の月曜まで続くことを表します。夏時間の開始日が10月1日に変更された
ならば、変数`calendar-daylight-savings-starts'には以下のように設定します。

     (list 10 1 year)

読者の地方で夏時間を採用していなかったり、すべての時刻を標準時で扱いたい
場合には、変数`calendar-daylight-savings-starts'と変数
`calendar-daylight-savings-ends'には`nil'を設定してください。

変数`calendar-daylight-time-offset'は、夏時間と標準時の差を分単位で指定
します。マサチューセッツ州ケンブリッジでは60（分）です。

2つの変数`calendar-daylight-savings-starts-time'と変数
`calendar-daylight-savings-ends-time'は、夏時間の開始／終了が地方時の真
夜中の0時から何分ずれるかを指定します。マサチューセッツ州ケンブリッジで
はどちらも120（分）です。


File: emacs-ja.info, Node: Gnus, Next: Shell, Prev: Calendar/Diary, Up: Top

gnus
====

gnusは主にネットニュースを読んだり投稿するためのEmacsパッケージです。電
子メイル、リモートディレクトリ、ダイジェストなどのネットニュース以外のメッ
セージを読んだりそれらに応答するのにも使えます。

以下ではgnusについて紹介し、いくつかの基本的な機能について説明します。詳
しくは、*Note Gnus: (gnus)Topを参照してください。

gnusを起動するには、`M-x gnus RET'と打ちます。

* Menu:

* Buffers of Gnus::	The group, summary, and article buffers.
* Gnus Startup::	What you should know about starting Gnus.
* Summary of Gnus::	A short description of the basic Gnus commands.



File: emacs-ja.info, Node: Buffers of Gnus, Next: Gnus Startup, Up: Gnus

gnusのバッファ
--------------

ふつうのEmacsのパッケージと違って、gnusは多数の異なるバッファを使って情
報を提示したりユーザーのコマンドを受け取ります。ユーザーがもっとも多くの
時間を使うことになるバッファは、"グループバッファ"、"サマリバッファ"、"
記事バッファ"の3つです。

"グループバッファ"はニュースグループの一覧です。gnusが起動すると、まずこ
のバッファが表示されます。通常はユーザーが購読していて、かつ、未読記事が
存在するグループだけが表示されます。このバッファでグループを選択します。

"サマリバッファ"は選択したグループ内の1つの記事につき1行の情報を表示しま
す。デフォルトでは、各記事の投稿者、題目、行数が表示されますが、gnusのほ
とんどの表示内容と同様にこの表示内容はカスタマイズできます。グループバッ
ファでグループを選択するとサマリバッファが作られ、グループから出ると削除
されます。サマリバッファを使って記事を選択します。

"記事バッファ"は記事を表示します。gnusの普通の使い方では、このバッファを
選択することはありません。記事を操作対象とするコマンド群はサマリバッファ
で動作します。しかし、望むなら、記事バッファに切り替えて、そこでgnusのコ
マンドを実行することも可能です。



File: emacs-ja.info, Node: Gnus Startup, Next: Summary of Gnus, Prev: Buffers of Gnus, Up: Gnus

gnusの起動時の動作
------------------

gnusが起動すると、個人のニュース初期化ファイル`.newsrc'を読み込み、ニュー
ス記事を蓄えているローカルのニュースサーバーと通信しようとします。ニュー
スサーバーは、ユーザーがログインしているマシンと同じである必要はありませ
ん。

gnusを起動してニュースサーバーと通信したあとでもグループバッファにグルー
プが1つも表示されないときは、`L'や`A k'と打ってすべてのグループを表示さ
せます。つぎに各グループの行で`u'と打って個々のグループの購読／非購読を
切り替えます。

初めてgnusを起動したときは、ごく少数の選ばれたグループのみが購読状態にあ
ります。他のグループは"非購読グループ"（killed groups）になっていて、`A
k'を使うと表示されます。最初の起動以後にニュースサーバー上に追加されたグ
ループはすべて、"ゾンビグループ"（zombie groups）になっていて、`A z'を使
うと表示されます。`u'を使えばこれらのグループを購読状態にできます。

`q'でgnusを終了すると、初期化ファイル`.newsrc'と`.newsrc.eld'にすべての
グループの購読／非購読を自動的に記録します。通常はこれらのファイルを手で
編集すべきではありませんが、やりかたがわかっているならかまいません。



File: emacs-ja.info, Node: Summary of Gnus, Prev: Gnus Startup, Up: Gnus

gnusコマンドのまとめ
--------------------

ニュースを読むにはつぎの2つの段階を踏みます。

  1. グループバッファでグループを選択する。

  2. サマリバッファで記事を選択する。記事を選択すると、サマリバッファの
     小さなウィンドウの下の大きめのウィンドウの中の記事バッファに選択し
     た記事が表示される。

gnusの各バッファにはそれぞれ独自のコマンドがあります。しかし、gnusのさま
ざまなバッファのどんなキーの意味も、等価ではないにせよ、だいたい同じです。
以下は、グループバッファとサマリバッファのコマンドです。

`q'
     グループバッファでは、初期化ファイル`.newsrc'を更新してgnusを終了す
     る。

     サマリバッファでは、カレントグループから抜け出てグループバッファに
     戻る。したがって、`q'を2回打つとgnusを終る。

`L'
     グループバッファでは、ニュースサーバーにある（非購読にしたもの以外
     の）すべてのグループを表示する。すごく長いリストになるかもしれない
     ので注意！

`l'
     グループバッファでは、購読中で未読記事があるグループのみを表示する。

`u'
     グループバッファでは、ポイントのある行のグループの購読／非購読を切
     り替える。`q'でgnusを終ると、gnusはこの状態を`.newsrc'ファイルに記
     録する。gnusは、通常、購読グループのみを表示するため、つぎにgnusを
     起動したときには非購読にしたグループは表示されない。

`C-k'
     グループバッファでは、ポイントのある行のグループを「抹消」する。す
     なわち、そのグループは以後`.newsrc'にも現れなくなる。このコマンドの
     効果は、現在のgnusセッションだけでなく将来のgnusセッションにも影響
     する。

     `q'でgnusを終了すると、gnusはファイル`.newsrc'に抹消したグループを
     除くすべてのグループの情報を書き出す。

`SPC'
     グループバッファでは、ポイントのある行に対応するグループを選択し、
     そのグループの最初の未読記事を表示する。

     サマリバッファでは、つぎのようになる。

        * 選択されている記事がなければ、ポイントのある行の記事を選択する。

        * （選択されている記事があれば）その記事のテキストを1画面分進め
          る。

        * 選択されている記事の末尾にいる場合は、つぎの未読記事を選択する。

     すなわち、繰り返しSPCを打と、すべての記事を順に見ていくことができる。

`DEL'
     グループバッファでは、ポイントを未読記事がある1つまえのグループに移
     動する。

     サマリバッファでは、記事のテキストを1画面分戻す。

`n'
     ポイントをつぎの未読グループに進めるか、または、つぎの未読記事を選
     択する。

`p'
     ポイントをまえの未読グループへ戻すか、または、まえの未読記事を選択
     する。

`C-n'
`C-p'
     既読であってもポイントを1つあと／まえの項目に移動する。ポイントがあ
     る行の記事やグループを選択することはしない。

`s'
     サマリバッファでは、記事バッファに切り替えて`C-s'を打ったかのように、
     記事バッファのテキストに対してインクリメンタルサーチを行う。

`M-s REGEXP RET'
     サマリバッファでは、REGEXPに一致する記事がみつかるまで前向きに探索
     する。





File: emacs-ja.info, Node: Shell, Next: Emacs Server, Prev: Gnus, Up: Top

Emacsからシェルコマンドを実行する
=================================

Emacsには、1つのコマンド行を下位のシェルプロセスに渡して実行させる機能が
あります。また、入出力を`*shell*'という名前のEmacsバッファに接続して対話
的にシェルを実行する機能もあります。

`M-! CMD RET'
     シェルコマンドCMDを実行し、その結果を表示する（`shell-command'）。
`M-| CMD RET'
     リージョンの内容を入力としてシェルコマンドCMDを実行する。場合によっ
     ては、リージョンをシェルコマンドの出力で置き換える。
     （`shell-command-on-region'）。
`M-x shell'
     入出力をEmacsバッファに接続してサブシェルを実行する。すると、対話的
     にコマンドを入力できる。

* Menu:

* Single Shell::           How to run one shell command and return.
* Interactive Shell::      Permanent shell taking input via Emacs.
* Shell Mode::             Special Emacs commands used with permanent shell.
* History: Shell History.  Repeating previous commands in a shell buffer.
* Options: Shell Options.  Options for customizing Shell mode.
* Remote Host::            Connecting to another computer.



File: emacs-ja.info, Node: Single Shell, Next: Interactive Shell, Up: Shell

単一のシェルコマンド
--------------------

`M-!'（`shell-command'）は、新たに作ったサブシェルにて、ミニバッファで読
み取った1行のテキストをシェルコマンドとして実行します。シェルコマンドの
標準入力はnull装置（つまり空）です。シェルコマンドの出力があれば、
`*Shell Command Output*'という名前のEmacsバッファに入れて別のウィンドウ
に表示しますが、（カレントバッファには）選択しません。`M-1 M-!'のように
数引数を指定すると、シェルコマンドの出力をカレントバッファに挿入します。
その場合、ポイントは（挿入された）出力の先頭に置かれ、マークは出力の末尾
に置かれます。

シェルコマンドの末尾が`&'になっていると、シェルコマンドは非同期に実行さ
れます。同期実行のシェルコマンドでは、Lispプログラムから呼ばれたときには、
`shell-command'はコマンドの終了状態（0は成功を意味する）を返します。

`M-|'（`shell-command-on-region'）は`M-!'と同様ですが、シェルコマンドの
標準入力は空ではなくリージョンの内容が引き渡されます。数引数を指定すると、
それまでのリージョンは削除されシェルコマンドの出力で置き換わり新たなリー
ジョンになります。このコマンドは、Lispプログラムから呼ばれたときには、コ
マンドの終了状態を返します。

`M-!'も`M-|'も、使用するシェルは`shell-file-name'で指定します。この変数
は、Emacs起動時の環境変数`SHELL'をもとに初期設定されます。ファイル名にディ
レクトリが指定されていなければ、`exec-path'に指定されているディレクトリ
群を探索します。`exec-path'の値は、Emacs起動時の環境変数`PATH'をもとに初
期設定されます。個人のファイル`.emacs'でこれらの変数の初期値を自由に変更
してかまいません。

`M-!'も`M-|'もシェルコマンドの実行完了を待ち合わせます。待つのをやめたい
場合は、`C-g'で中断できます。この場合、シェルコマンドはシグナル`SIGINT'
で終了させられます。このシグナルは、シェルを使用中に`C-c'が普通に送るシ
グナルと同じです。Emacsはシェルコマンドが実際に終了するまで待ちます。シェ
ルコマンドが（シグナル`SIGINT'を無視して）停止しない場合は、再度`C-g'を
打ちます。すると、無視できないシグナル`SIGKILL'をシェルコマンドに送りま
す。

`M-!'や`M-|'で使用するコーディングシステムを指定するには、これらのコマン
ドの直前にコマンド`C-x RET c'を使います。*Note Specify Coding::。

コマンドからのエラー出力は、通常、普通の出力と混ざり合ってしまいます。変
数`shell-command-default-error-buffer'にバッファ名の文字列を設定すると、
その名前のバッファのポイント位置のまえにエラー出力が挿入されます。



File: emacs-ja.info, Node: Interactive Shell, Next: Shell Mode, Prev: Single Shell, Up: Shell

対話的な下位のシェル
--------------------

サブシェルを対話的に実行し、その対話記録をEmacsバッファに残すには、`M-x
shell'を使います。このコマンドは、`*shell*'という名前のバッファを作成
（または再使用）し、このバッファに入出力するサブシェルを実行します。つま
り、サブシェルの『端末出力』はバッファに挿入されポイントを進め、サブシェ
ルの『端末入力』はバッファから取られます。サブシェルに入力を与えるには、
バッファの末尾へ移動して入力を打ち込み最後にRETを打ちます。

Emacsはサブシェルが何かするのを待つことはしません。シェルが待っていよう
がシェルコマンドを実行していようが、ウィンドウやバッファを切り替えて編集
できます。サブシェルからの出力は、Emacsがそれを取り込む処理を実行できる
まで待たされます。取り込み処理は、Emacsがキーボード入力を待ったり、時間
待ちに入ったときに行われます。

複数のサブシェルを使うには、バッファ`*shell*'の名前をコマンド`M-x
rename-uniquely'で別のものに変更します。そうしてから、再度`M-x shell'と
打ち込んで、新しいサブシェルを持つバッファ`*shell*'を新たに作ります。こ
のバッファの名前も同じように変えれば、さらに新しく作れます。すべてのサブ
シェルは独立かつ並行に実行されます。

サブシェルとして実行するファイル名は、変数`explicit-shell-file-name' の
値が`nil'以外ならば、この変数の値で指定します。`nil'のときは、環境変数
`ESHELL'の値が使われますが、これが存在しない場合は環境変数`SHELL'の値が
使われます。指定されたファイル名が相対名の場合は、`exec-path'に指定され
ているディレクトリ群を探索します。変数`exec-path'は、Emacs起動時の環境変
数`PATH'をもとに初期設定されます。個人のファイル`.emacs'でこれらの変数を
自由に変更してかまいません。

シェルに対するコーディングシステムを指定するには、`M-x shell'の直前にコ
マンド`C-x RET c'を使います。または、シェルを開始したあとにシェルバッファ
で`C-x RET p'を使っても指定できます。*Note Specify Coding::。

SHELLNAMEをシェルのファイル名として、ファイル`~/.emacs_SHELLNAME'が存在
すると、Emacsはサブシェルを実行開始した直後に初期設定のために、このファ
イルの内容をシェルへの入力として送り込みます。たとえば、bashを使っている
のならファイル`~/.emacs_bash'の内容が送られます。

Emacsは、シェルコマンド、`cd'、`pushd'、`popd'がシェルへの入力として送ら
れるのを監視し、バッファ`*shell*'のデフォルトディレクトリとシェルのカレ
ントディレクトリが一致するようにします。これらのシェルコマンドは、送られ
る入力行の文字列を構文的に調べて識別します。これらのシェルコマンドに別名
を付けるのなら、Emacsにもその別名について教えておくことができます。たと
えば、変数`shell-pushd-regexp'の値がシェルへの入力行の先頭に一致する場合
は、その行は`pushd'コマンドであるとみなされます。`pushd'に別名を付けたら、
この変数の値を変更します。同様に、`shell-popd-regexp'と`shell-cd-regexp'
は、`popd'と`cd'を識別するのに使われます。これらのコマンドはシェルへの入
力行の先頭部分にあるときだけ正しく認識されます。

Emacsは、`cd'、`pushd'、`popd'のシェルコマンドだと思われるものを処理中に
エラーに遭遇すると、フック`shell-set-directory-err-hook'を実行します
（*Note Hooks::）。

Emacsがサブシェルのカレントディレクトリを正しく追従できていない場合は、
コマンド`M-x dirs'を使ってシェルにカレントディレクトリを問い合わせてくだ
さい。このコマンドは一般的なコマンドの構文を持つシェルでは動作します。で
すが、とても変わったシェルでは動かないかもしれません。

`M-x dirtrack'を使うと、別のもっと積極的なやり方でカレントディレクトリの
変更に追従する（しない）ようにもできます。

Emacsは、サブシェルの環境変数`EMACS'に`t'を設定します。シェルスクリプト
でこの変数を検査すれば、Emacsのサブシェルとして動いているかどうか判定で
きます。



File: emacs-ja.info, Node: Shell Mode, Next: Shell History, Prev: Interactive Shell, Up: Shell

シェルモード（Shellモード）
---------------------------

シェルバッファではシェル（shell）モードが使われ、プレフィックスキー`C-c'
を持つ特別なキーをいくつか定義しています。これらは、まず`C-c'を打つこと
を除けば、Emacsの外でシェルを使うときの通常のコマンド行編集やジョブ制御
のキーに似せて定義してあります。以下は、シェル（shell）モードでの特別な
バインディングの一覧です。

`RET'
     バッファの末尾で打つと、1行分を入力としてシェルに送る。バッファの末
     尾以外では、現在行をバッファの末尾にコピーしてから、それを入力とし
     てシェルに送る（`comint-send-input'）。行をコピーするとき、行の先頭
     部分の文字列で変数`shell-prompt-pattern'に一致する部分はコピーしな
     い。この変数の値は、ユーザーのシェルがプロンプトとして用いる文字列
     に一致する正規表現であること。

`TAB'
     シェルバッファでポイントの直前にあるコマンド名やファイル名を補完す
     る（`comint-dynamic-complete'）。TABは、履歴参照（*Note History
     References::）や環境変数名も補完できる。

     変数`shell-completion-fignore'には、シェル（shell）モードでの補完に
     おいて無視したいファイル名の拡張子のリストを指定する。デフォルトの
     設定では、名前が、`~'、`#'、`%'で終るファイルを無視する。関連する他
     のcomintモードではかわりに変数`comint-completion-fignore'を使う。

`M-?'
     シェルバッファのポイントの直前にあるファイル名の可能な補完内容を一
     時的に表示する（`comint-dynamic-list-filename-completions'）。

`C-d'
     文字を削除するか、または、EOFを送る（`comint-delchar-or-maybe-eof'）。
     シェルバッファの末尾で`C-d'を打つとサブシェルにEOFを送る。バッファ
     のそれ以外の位置では、`C-d'を打つと通常どおり1文字削除する。

`C-c C-a'
     行の先頭に行く。ただし、プロンプトがある場合にはプロンプトの直後に
     行く（`comint-bol'）。同じ行でこのコマンドを2回繰り返すと、2回目で
     はプロセスマークへ戻る。プロセスマークとは、サブシェルへまだ送って
     いない入力の開始位置のこと。（通常、これは同じ場所であり、プロセス
     マークはその行のプロンプトの終りにある。ただし、`C-c SPC'のあとでは、
     プロセスマークはまえの行にあるかもしれない。）

`C-c SPC'
     複数の入力行を溜めておき、まとめて送る。このコマンドは、ポイントの
     まえに改行を挿入するが、少なくともまだ、その行を入力としてサブシェ
     ルへ送らない。RETを打つと、改行のまえの1行とあとの1行を（区切りの改
     行を含めて）まとめて送る。

`C-c C-u'
     バッファの末尾にある、まだシェルに送っていないテキストをすべてキル
     する（`comint-kill-input'）。

`C-c C-w'
     ポイントの直前の1語をキルする（`backward-kill-word'）。

`C-c C-c'
     シェル、または、あればサブジョブに割り込む
     （`comint-interrupt-subjob'）。また、このコマンドはシェルバッファ内
     のまだシェルに送っていないテキストもキルする。

`C-c C-z'
     シェル、または、あればサブジョブを中断する（`comint-stop-subjob'）。
     また、このコマンドはシェルバッファ内のまだシェルに送っていないテキ
     ストもキルする。

`C-c C-\'
     シェル、または、あればサブジョブにシグナルQUITを送る
     （`comint-quit-subjob'）。また、このコマンドはシェルバッファ内のま
     だシェルに送っていないテキストもキルする。

`C-c C-o'
     直前のシェルコマンドからのひとまとまりの出力をキルする
     （`comint-kill-output'）。シェルコマンドが大量の出力を出してしまっ
     たときなどに有効。

`C-c C-r'
`C-M-l'
     直前のひとまとまりの出力がウィンドウの先頭にくるようにスクロールす
     る。また、ポイントもそこへ動かす（`comint-show-output'）。

`C-c C-e'
     バッファの末尾がウィンドウの下端にくるようにスクロールする
     （`comint-show-maximum-output'）。

`C-c C-f'
     シェルコマンド1つ分だけ先へ進めるが、現在行の末尾より先へはいかない
     （`shell-forward-command'）。変数`shell-command-regexp'には、シェル
     コマンドの終りの探し方（正規表現）を指定する。

`C-c C-b'
     シェルコマンド1つ分だけ手前へ戻るが、現在行の先頭よりまえへはいかな
     い（`shell-backward-command'）。

`C-c C-l'
     バッファのシェルコマンド履歴を別のウィンドウに表示する
     （`comint-dynamic-list-input-ring'）。

`M-x dirs'
     シェルにカレントディレクトリを問い合わせ、Emacs側のものをシェルに合
     わせる。

`M-x send-invisible RET TEXT RET'
     TEXTをエコーバックせずに読み取り、入力としてシェルへ送る。パスワー
     ドを問い合わせるようなプログラムを起動するシェルコマンドで役立つ。

     かわりに、つぎのようにして、Emacsにパスワードプロンプトを認識させて
     エコーバックを抑制する方法もある。

          (add-hook 'comint-output-filter-functions
                    'comint-watch-for-password-prompt)

`M-x comint-continue-subjob'
     シェルプロセスを継続させる。これはまちがってシェルプロセスを休止さ
     せてしまった場合に役立つ。 (1) (*Note Shell Mode-Footnotes::)

`M-x comint-strip-ctrl-m'
     現在の一群のシェルの出力から復帰（コントロールM）文字を削除する。こ
     のコマンドのもっとも便利な使い方の1つは、サブシェルの出力を受け取る
     と自動的にこのコマンドが実行されるように設定しておくことである。そ
     のためには、つぎのLisp式を評価すればよい。

          (add-hook 'comint-output-filter-functions
                    'comint-strip-ctrl-m)

`M-x comint-truncate-buffer'
     このコマンドは、変数`comint-buffer-maximum-size'で指定した大きさに
     シェルバッファの行数を切り詰める。サブシェルから出力を受け取るたび
     にこれを自動的に行うにはつぎのようにする。

          (add-hook 'comint-output-filter-functions
                    'comint-truncate-buffer)

シェル（shell）モードでは段落コマンドにも修正を加えてあり、シェルプロン
プトでのみ新しい段落が始まるようになっています。つまり、シェルバッファで
は、1つの段落はシェルコマンドとその出力から成るのです。

シェル（shell）モードは、対話的なサブプロセスと通信するための汎用モード
であるcomintモードからの派生です。ここまでにあげてきたコマンドの名前から
もわかるように、シェル（shell）モードの数多くの機能は、実は、comintモー
ドからきています。シェル（shell）モードに固有な特別な機能は、正規表現に
基づくプロンプトの認識、カレントディレクトリの追跡、および、少数のユーザー
コマンドに限られます。

comintモードから派生したEmacsのほかの機能としては、GUD（*Note
Debuggers::）と`M-x run-lisp'（*Note External Lisp::）があります。

`M-x comint-run'を使うと、シェル（shell）モード固有の機能を持たない
comintモードで、任意のプログラムをサブプロセスとして実行できます。


File: emacs-ja.info  Node: Shell Mode-Footnotes, Up: Shell Mode

(1) シェルプロセスを休止すべきではない。シェルのサブジョブを休止す
るのとはまったく別のことであり、こちらは普通に行ってよい。ただし、
休止したサブジョブはシェルで再開させる必要がある。このコマンドでは
再開できない。



File: emacs-ja.info, Node: Shell History, Next: Shell Options, Prev: Shell Mode, Up: Shell

シェルコマンド履歴
------------------

シェルバッファでは、以前に使ったシェルコマンドを再実行する方法が3つあり
ます。1つめは、ミニバッファと同じキーを使う方法です。すなわち、ミニバッ
ファの場合と同様に、ポイントはつねにバッファの末尾にある状態で、以前に使っ
たシェルコマンドをバッファに挿入できます。2つめは、バッファ内で以前のシェ
ルコマンドの箇所に移動して、それをそのまま再実行するかバッファの末尾にコ
ピーします。3つめは、`!'形式の履歴参照を使うことです。

* Menu:

* Ring: Shell Ring.             Fetching commands from the history list.
* Copy: Shell History Copying.  Moving to a command and then copying it.
* History References::          Expanding `!'-style history references.



File: emacs-ja.info, Node: Shell Ring, Next: Shell History Copying, Up: Shell History

シェル履歴リング
................

`M-p'
     今のものより1つまえの古いシェルコマンドを持ってくる。

`M-n'
     今のものより1つあとの古いシェルコマンドを持ってくる。

`M-r REGEXP RET'
`M-s REGEXP RET'
     REGEXPに一致する古いシェルコマンドを後向きまたは前向きに探索する。

`C-c C-x (Shell mode)'
     履歴からつぎのコマンドを持ってくる。

シェルバッファには、それまでに入力したシェルコマンドの履歴があります。こ
の履歴からシェルコマンドを再利用するには、編集コマンド、`M-p'、`M-n'、
`M-r'、`M-s'を使います。これらはミニバッファの履歴コマンドと同様に働きま
すが、（普通はシェルに送るテキストを挿入する）シェルバッファの末尾にある
テキストに作用する点が異なります。

`M-p'は、1つまえのシェルコマンドをシェルバッファの末尾に持ってきます。
`M-p'を連続して使うと、次々にそれよりまえに実行したシェルコマンドを持っ
てきて、それまでのシェルへの入力用テキストを置き換えます。`M-n'も同様で
すが、次々にそれよりあとのシェルコマンドを持ってくる点が異なります。

履歴探索コマンド`M-r'と`M-s'は、正規表現を読み取り、それに一致するシェル
コマンドを履歴の中から探します。どのシェルコマンドを持ってくるかという点
を除けば、それらの働きは`M-p'や`M-n'と同じです。正規表現として空文字列を
入力すると、直前に使用した正規表現を再使用します。

再使用したいシェルコマンドを探したならば、RETを打ってそのシェルコマンド
を再実行するか、必要なら編集してから実行します。

以前に連続して実行した一連のシェルコマンドをまとめて再実行できると便利な
ことがあります。それには、まず、一連のシェルコマンドの最初のものを探して
再実行します。そうしてから`C-c C-x'と打ちます。これは、直前に再実行した
シェルコマンドの（履歴内で）つぎにあるシェルコマンドを持ってきます。RET
と打って再実行します。このように、`C-c C-x RET'を繰り返し打てば一連のシェ
ルコマンドを再実行できます。

これらのコマンドは過去に実行したシェルコマンドを専用の履歴リストから持っ
てくるのであって、シェルバッファからとってくるのではありません。したがっ
て、シェルバッファを編集したり、その大部分をキルしたとしても、これらのコ
マンドが参照する履歴には影響しません。

いくつかのシェルは、コマンド履歴をファイルに保管して以前のセッションの履
歴を引き継げるようになっています。Emacsは、自分の履歴リストを初期設定す
るために、ユーザーが使うシェルの履歴ファイルを読み込みます。ファイル名は、
bashであれば`~/.bash_history'、kshであれば`~/.sh_history'、その他のシェ
ルであれば`~/.history'です。



File: emacs-ja.info, Node: Shell History Copying, Next: History References, Prev: Shell Ring, Up: Shell History

シェル履歴のコピー
..................

`C-c C-p'
     ポイントを1つまえのプロンプトへ移動する（`comint-previous-prompt'）。

`C-c C-n'
     ポイントを1つあとのプロンプトへ移動する（`comint-next-prompt'）。

`C-c RET'
     ポイントがあるところの入力コマンドをバッファの末尾にコピーする
     （`comint-copy-old-input'）。このコマンドはポイントを古いシェルコマ
     ンドへ移動したときに役立つ。シェルコマンドをコピーしたら、RETでそれ
     を（シェルへ）送る。必要ならシェルコマンドを修正してから送ってもよ
     い。

ポイントをまえの入力箇所に移動してから`C-c RET'でコピーしても、`M-p'を必
要な回数使って履歴リストからまえのコマンドを持ってきたのと（バッファの内
容が同じという意味で）同じ結果になります。ただし、`C-c RET'はバッファか
らテキストをコピーするので、シェルへ送ったあとでそれをバッファ上で編集し
た場合には、履歴リストにあるものとは異なることもあります。



File: emacs-ja.info, Node: History References, Prev: Shell History Copying, Up: Shell History

シェル履歴の参照
................

cshやbashをはじめ多くのシェルは、`!'や`^'で始まる"履歴参照"の機能を提供
しています。シェル（shell）モードでもこれらの指定を理解し、履歴置換を行
えます。履歴参照を入力してTABを打つと、履歴リストから一致するシェルコマ
ンドを探し、必要なら置換を行い、履歴参照をその結果で置き換えます。たとえ
ば、`mv'で始まるいちばん最近のシェルコマンドを持ってくるには`! m v TAB'
と打ちます。必要ならシェルコマンドを編集し、RETと打ってシェルへ送ります。

履歴参照は、シェルプロンプトのあとでのみ効果を持ちます。変数
`shell-prompt-pattern'でシェルプロンプトと認識するものを指定します。
comintモード一般には、変数`comint-promt-regexp'でプロンプトの探し方を指
定します。シェル（shell）モードでは、`shell-prompt-pattern'を使って
`comint-prompt-regexp'のローカルな値を設定します。

シェル（shell）モードでは、シェルに送る際にバッファ内で履歴参照を展開す
るようにも指定できます。それには、変数`compint-input-autoexpand'に
`input'を設定します。

SPCをコマンド`comint-magic-space'にバインドすれば、SPCで履歴展開が行える
ようになります。



File: emacs-ja.info, Node: Shell Options, Next: Remote Host, Prev: Shell History, Up: Shell

シェルモードのオプション
------------------------

変数`comint-scroll-to-bottom-on-input'が`nil'以外の場合には、挿入および
ヤンクコマンドは、選択されているウィンドウを末尾までスクロールしてから挿
入します。

`comint-scroll-show-maximum-output'が`nil'以外の場合、出力に伴うスクロー
ルでは、最後の行ができるだけウィンドウのいちばん下にくるようにし、なるべ
く多くの有用なテキストが見えるようにします（これは多くの端末のスクロール
動作の真似）。デフォルトは`nil'です。

`comint-scroll-to-bottom-on-output'を設定すると、ポイントがどこにあろう
と、出力が到着するたびにバッファの末尾へポイントがジャンプするように設定
できます。この変数の値が`this'であれば、ポイントは選択されたウィンドウで
ジャンプします。値が`all'であれば、comintバッファを表示している各ウィン
ドウでポイントはジャンプします。値が`other'であれば、カレントバッファを
表示しているすべての選択されていないウィンドウでポイントはジャンプします。
デフォルトは`nil'ですから、ポイントはジャンプしません。

変数`comint-input-ignoredups'は、連続する同一の入力を履歴に格納するかど
うかを制御します。値が`nil'以外のときは、直前の入力と同じ入力は履歴に格
納しません。デフォルトは`nil'ですから、直前と同じ入力でもすべて履歴に格
納します。

3つの変数でファイル名の補完をカスタマイズします。変数
`comint-completion-addsuffix'は、ファイル名やディレクトリ名を補完すると
き、名前を完全に補完できたことを示すために末尾に空白やスラッシュを挿入す
るかどうかを指定します（`nil'以外のとき、空白やスラッシュを挿入）。
`comint-completion-recexact'は、その値が`nil'以外の場合、Emacsの通常の補
完アルゴリズムで1文字も追加できないときにはTABで可能なもっとも短い補完文
字列を挿入するようにします。`comint-completion-autolist'は、その値が
`nil'以外の場合、補完が完全でないときに可能な補完候補の一覧を表示するこ
とを指定します。

コマンド`comint-dynamic-complete-variable'は、Emacs中で設定されている環
境変数を用いて変数名の補完を行います。ファイル名の補完を制御する上述の変
数群も変数名の補完を制御します。このコマンドは、通常、メニューバーから使
えます。

コマンド補完は、通常、実行可能なファイルだけを対象とします。
`shell-command-execonly'を`nil'にすると、実行可能でないファイルも対象と
なります。

`pushd'の動作をカスタマイズできます。引数が与えられないと`cd'と同様にふ
るまう（`shell-pushd-tohome'）、数引数を指定すると`pop'ではなく巡回する
（`shell-pushd-dextract'）、ディレクトリスタックにないディレクトリだけを
ディレクトリスタックに加える（`shell-pushd-dunique'）を制御できます。こ
れらの値は当然、使っているシェルの動作と一致するように設定すべきです。



File: emacs-ja.info, Node: Remote Host, Prev: Shell Options, Up: Shell

リモートホストのシェル
----------------------

Emacsには、他のホストにログインしてEmacsバッファ経由で通信するコマンドが
2つあります。

`M-x telnet RET HOSTNAME RET'
     ホストHOSTNAMEにtelnet経由で接続する。
`M-x rlogin RET HOSTNAME RET'
     ホストHOSTNAMEにrlogin経由で接続する。

他のホストにtelnet経由で接続するには、`M-x telnet'を使います（telnetはリ
モートログイン用のInternetの標準プロトコル）。このコマンドは、接続先のホ
スト名を引数としてミニバッファで読みます。いったん接続が確立すると、他の
ホストとのやりとりはサブシェルとのやりとりと同様にして行えます。通常の
Emacsコマンドで入力を編集でき、RETで相手側に送信します。相手側からの出力
は（同じ）Telnetバッファに挿入されます。

rlogin接続を行うには、`M-x rlogin'を使います。rloginは本質的にはtelnetプ
ロトコルとよく似たリモートログイン用の通信プロトコルですが、telnetとの互
換性はなく、ある種のシステムでだけ使えます。rloginの利点は、2つのマシン
間で頻繁に通信する場合にユーザー名やパスワードを毎回打ち込まないですむよ
うに設定できることと、8ビットを透過的に使う接続が可能なことです。（Emacs
でこれを行うには、rloginを開始するまえに`rlogin-explicit-args'に`("-8")'
を設定する。）

`M-x rlogin'は、相手側とFTP経由でファイルをやりとりするためにEmacsバッファ
のデフォルトディレクトリを設定し（*Note File Names::）、シェル（shell）
モードと同様にカレントディレクトリを変更するシェルコマンドを監視します。

rloginバッファでディレクトリを追跡する方法は2つあります。リモートディレ
クトリ名`/HOST:DIR/'を使うか、ローカルファイル名を使います。（後者は『相
手側のホスト』がローカルホストとファイルシステムを共有している場合にのみ
使える）。コマンド`rlogin-directory-tracking-mode'を使って、これらの2つ
のモードを相互に切り替えられます。引数なしではリモートディレクトリ名を使
う状態にし、正の数を引数にするとローカル名を使う状態にします。負の数を引
数にするとディレクトリの追跡機能を止めます。



File: emacs-ja.info, Node: Emacs Server, Next: Hardcopy, Prev: Shell, Up: Top

Emacsをサーバーとして使う
=========================

`mail'を始めとする多くのプログラムは、送信メッセージなどのテキストを編集
するためにユーザーが指定したエディタを起動します。これらのプログラムは、
習慣として、環境変数`EDITOR'で指定されたエディタを起動します。`EDITOR'に
`emacs'を設定しておけばEmacsが起動しますが、新たに別のEmacsプロセスが開
始されるので不便です。というのは、新しいEmacsプロセスは既存のEmacsプロセ
スとバッファを共有しないからです。

EmacsクライアントとEmacsサーバーを用いて、`mail'などのプログラムが既存の
Emacsプロセスをエディタとして使うようにできます。以下のようにします。

まずは準備です。Emacsの中で関数`server-start'を呼び出します。（個人のファ
イル`.emacs'に式`(server-start)'を書いておけば、これを自動的に行える。）
つぎに、Emacsの外で環境変数`EDITOR'に`emacsclient'を設定します。（プログ
ラムによっては別の環境変数を使う。たとえば、TeXに`emacsclient'を使わせる
には、環境変数`TEXEDIT'に`emacsclient +%d %s'と設定する。）

こうすると、どのプログラムが`EDITOR'に指定されたプログラムをエディタとし
て起動しても、結果としては、訪れるべきファイルを伝えるメッセージが現在動
いているEmacsに送られます。（これが`emacsclient'の役割。）Emacsはただち
にバッファを表示し、ユーザーはすぐに編集を開始できます。

そのバッファの編集が終ったら、`C-x #'と打ちます（`server-edit'）。これに
より、ファイルが保存され、終了せよとのメッセージを`emacslient'に送り返し
ます。`EDITOR'を参照したプログラムは『エディタ』（実際には`emacsclient'）
が終了するのを待ちます。`C-x #'は複数のファイルに対する外部からの編集要
求で他に残っているものがないかどうかも検査し、もしあればつぎのファイルを
訪問します。

望むなら手でサーバーバッファに切り替えてもかまいません。必ず`C-x #'を使
わなければならないということはありません。ただし、`C-x #'はサーバーバッ
ファの編集が終ったということを告げる唯一の方法です。

変数`server-window'にウィンドウやフレームを設定してあれば、`C-x #'はサー
バーバッファをそのウィンドウやフレームに表示します。

`mail'やその他のアプリケーションが`emacsclient'の終了を待っているあいだ、
`emacsclient'は端末入力を読みません。したがって、`mail'が使っている端末
は、そのあいだ実質的にブロックされた状態にあります。サーバーとして使う
Emacsで編集をするためには、その（ブロックしている）端末を使わずに行う必
要があります。それには2つの方法があります。

   * ウィンドウシステムを使い、`mail'とEmacsとを別のウィンドウで動かす。
     `mail'が`emacsclient'を待っているあいだ、`mail'が動いてるウィンドウ
     はブロックされるが、他のウィンドウに切り替えればEmacsを使える。

   * Emacsのシェル（shell）モードを使って`mail'などのプログラムを動かす。
     こうすれば、`emacsclient'はEmacsの下で動いているサブシェルのみをブ
     ロックするので、Emacsを使ってファイルを編集するのは通常どおり行える。

プログラムによっては、エディタで編集するための作業ファイルを作成します。
ユーザーが作業ファイルを編集し終ると、プログラムはそのファイルを読み込ん
でから消去します。Emacsサーバーがあとで同じ名前のファイルを編集するよう
に告げられた場合、それはたまたまファイル名が一致しただけで、内容はまえの
ファイルと何ら関係ないものと考えなければなりません。このため、サーバーは
ファイルを編集し終ると作業ファイルのバッファを削除します。変数
`server-temp-file-regexp'を使って、どのようなファイルがここでいう意味で
の作業ファイルであるか指定します。この変数の値は、作業ファイルであるよう
なファイルの名前に一致する正規表現である必要があります。

オプション`--no-wait'を指定して`emacsclient'を起動すると、Emacs上でバッ
ファを編集し終るのを待たずにただちに終了します。



File: emacs-ja.info, Node: Hardcopy, Next: Postscript, Prev: Emacs Server, Up: Top

印刷
====

印刷用のEmacsコマンドには、バッファ全体ないしその一部を、ページヘッダ付
き／なしのどちらででも出力する機能があります。dired（*Note Misc File
Ops::）とdiary（*Note Diary Commands::）の印刷機能についても参照してくだ
さい。

`M-x print-buffer'
     カレントバッファの内容を、ファイル名とページ番号を記したページヘッ
     ダ付きで印刷する。
`M-x lpr-buffer'
     カレントバッファの内容を、ページヘッダなしで印刷する。
`M-x print-region'
     `print-buffer'と同様だが、現在のリージョンのみを印刷する。
`M-x lpr-region'
     `lpr-buffer'と同様だが、現在のリージョンのみを印刷。

（Postscriptコマンドを除く）印刷コマンドは、`lpr-switches'の値をもとに追
加オプションを`lpr'に渡します。この変数の値は文字列のリストであり、各文
字列は`-'で始まるオプションである必要があります。たとえば、Emacsから行う
印刷で1行を80文字に設定するには、`lpr-switches'をつぎのように設定します。

     (setq lpr-switches '("-w80"))

変数`printer-name'を設定すれば、使うプリンタを指定できます。

変数`lpr-command'は、実行すべきプリンタプログラムを指定します。デフォル
トの値はオペレーティングシステムに依存します。多くのシステムでは、デフォ
ルトは`"lpr"'です。変数`lpr-headers-switches'も同様に、ページヘッダを作
るための追加オプションを指定します。変数`lpr-add-switches'は、プリンタプ
ログラムに（`lpr'には適した）オプション`-T'とオプション`-J'を指定するか
どうか制御します。この変数の値が`nil'ならこれらのオプションを指定しませ
ん。プリンタプログラムが`lpr'と互換性がないなら、変数`lpr-add-switches'
は`nil'にすべきです。



File: emacs-ja.info, Node: Postscript, Next: Postscript Variables, Prev: Hardcopy, Up: Top

Postscriptの印刷
================

これらのコマンドは、バッファの内容をPostscriptに変換し、プリンタへ送るか
他のEmacsバッファに入れます。

`M-x ps-print-buffer'
     カレントバッファをPostscript形式で印刷する。
`M-x ps-print-region'
     現在のリージョンをPostscript形式で印刷する。
`M-x ps-print-buffer-with-faces'
     カレントバッファをPostscript形式で印刷するが、テキストで用いている
     フェイスをPostscriptの機能で表示する。
`M-x ps-print-region-with-faces'
     現在のリージョンをPostscript形式で印刷するが、テキストで用いている
     フェイスも表示する。
`M-x ps-spool-buffer'
     カレントバッファのテキストをPostscriptに変換する。
`M-x ps-spool-region'
     現在のリージョンをPostscriptに変換する。カレントバッファを
     Postscriptに変換するが、使われているフェイスも表示する。
`M-x ps-spool-region-with-faces'
     現在のリージョンをPostscriptに変換するが、使われているフェイスも表
     示する。

Postscriptコマンド`ps-print-buffer'および`ps-print-region'はバッファの内
容をPostscript形式で出力します。前者はバッファ全体を出力しますが、後者は
リージョンのみです。これらに対応した`-with-faces'コマンドである
`ps-print-buffer-with-faces'および`ps-print-region-with-faces'は、出力す
るテキストのテキスト属性のフェイス（フォントと表示色）をPostscriptの機能
を用いて再現します。

カラーディスプレイを使っている場合、バッファでフォントロック（font-lock）
モードを使って色付けしたプログラムコードを`ps-print-buffer-with-faces'で
（そのまま）印刷できます。

コマンド名が`print'のかわりに`spool'であるものは、変換したPostscript出力
をプリンタに送るかわりにEmacsバッファに置きます。

つぎの節では、これらのコマンドをカスタマイズする変数について説明します。



File: emacs-ja.info, Node: Postscript Variables, Next: Sorting, Prev: Postscript, Up: Top

Postscriptの印刷を制御する変数
==============================

すべてのPostscriptの印刷コマンドは、出力をどのように印刷するかを変数
`ps-lpr-command'と`ps-lpr-switches'で指定できます。`ps-lpr-command'には
印刷のため実行するシェルコマンド、`ps-lpr-switches'にはそのシェルコマン
ドに指定するオプション、`ps-printer-name'にはプリンタを指定します。始め
の2つの変数を設定しなかった場合は、`lpr-command'と`lpr-switches'に基づい
て初期値が設定されます。`ps-printer-name'が`nil'だと`printer-name'を使い
ます。

変数`ps-print-header'は、これらのコマンドが各ページにヘッダをつけるかど
うかを制御します。`nil'だとヘッダを付けません。`ps-print-color-p'を`nil'
にするとカラー処理を行いません。

変数`ps-paper-type'は、印刷用紙サイズを指定します。指定できる値は、`a4'、
`a3'、`a4small'、`b4'、`b5'、`executive'、`ledger'、`legal'、`letter'、
`letter-small'、`statement'、`tabloid'です。デフォルトは`letter'です。変
数`ps-page-dimensions-database'を変更すれば別の用紙サイズを定義できます。

変数`ps-landscape-mode'は用紙の向きを指定します。デフォルトは`nil'で、
『縦づかい』（ポートレート）です。`nil'以外の値を指定すると『横づかい』
（ランドスケープ）です。

変数`ps-number-of-columns'は段数を指定します。縦づかいでも横づかいでも有
効で、デフォルトは1です。

変数`ps-font-family'は、通常のテキストの印刷に使うフォントファミリを指定
します。指定できる値は、`Courier'、`Helvetica'、`NewCenturySchlbk'、
`Palatino'、`Times'です。変数`ps-font-size'は、通常のテキスト印刷に使う
フォントのサイズを指定します。デフォルトは8.5ポイント (1) (*Note
Postscript Variables-Footnotes::)です。

これらのコマンドには他にも多くのカスタマイズ可能な変数があり、それらは
Lispファイル`ps-print.el'で定義されています。


File: emacs-ja.info  Node: Postscript Variables-Footnotes, Up: Postscript Variables

(1) 【訳注】印刷機の長さの単位。1ポイントは約1/72インチ（0.35mm）



File: emacs-ja.info, Node: Sorting, Next: Narrowing, Prev: Postscript Variables, Up: Top

テキストのソート
================

Emacsには、バッファ中のテキストをソートするコマンドがいくつかあります。
すべてはリージョン（ポイントとマークのあいだのテキスト）に働きます。これ
らのコマンドは、リージョン中のテキストを多数の"ソートレコード"にわけ、各
レコードについて"ソートキー"を識別し、一連のレコードをソートキーによって
定まる順序に並べ替えます。レコードはキーのアルファベット（辞書）順にも、
また数値に基づく数値順にも並べられます。アルファベット順の場合は、ASCII
文字の順序に基づいてすべての大文字「A」〜「Z」は小文字「a」よりまえにき
ます。

各種のソートコマンドの違いは、テキストをソートレコードに分ける方法と、各
レコードのどの部分をソートキーに使うかです。ほとんどのコマンドは各行をソー
トレコードとして扱いますが、段落やページをソートレコードとして扱うコマン
ドもあります。ほとんどのソートコマンドは各ソートレコード全体をそれ自身の
ソートキーとして扱いますが、ソートレコードの一部分だけをソートキーとして
扱うコマンドもあります。

`M-x sort-lines'
     リージョンを行の並びとみなし、行全体のテキストを比較して（昇順に）
     ソートする。数引数を指定すると降順にソートする。

`M-x sort-paragraphs'
     リージョンを段落の並びとみなし、（先頭の空行を除く）段落全体のテキ
     ストを比較して（昇順に）ソートする。数引数を指定すると降順にソート
     する。

`M-x sort-pages'
     リージョンをページの並びとみなし、（先頭の空行を除く）ページ全体の
     テキストを比較して（昇順に）ソートする。数引数を指定すると降順にソー
     トする。

`M-x sort-fields'
     リージョンを行の並びとみなし、行の1つの欄を比較して（昇順に）ソート
     する。欄は白文字で区切られる。つまり、行の始めにある白文字でない文
     字の並びが第1欄、そのつぎの空白でない文字の並びが第2欄、というよう
     になる。

     どの欄をキーとしてソートするかは、1を指定すれば第1欄、というように
     数引数で指定する。負の値を指定したときは左からでなく右から欄を数え
     る。つまり、-1は最後の欄でソートする。複数の行において欄の値が同一
     の場合、バッファ上のもとの順序が保存される。

`M-x sort-numeric-fields'
     `M-x sort-fields'と同様だが、指定した欄を行ごとに数値に変換し、その
     数値同士を比較する。`10'はアルファベット順では`2'よりまえにくるが、
     数値として見れば`2'よりあとにくる。

`M-x sort-columns'
     `M-x sort-fields'と同様だが、行の比較に使うテキストは固定文字位置か
     らとる。以下の説明を参照のこと。

`M-x reverse-region'
     リージョン内の行の順番を逆にする。欄や文字位置でソートするコマンド
     は降順にはソートできないので、昇順にソートしたあと降順に並べ替える
     のに役立つ。

たとえば、バッファにつぎのような内容が入っていたとします。

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

バッファ全体に`M-x sort-lines'を適用すると、つぎのようになります。

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

ここで、`O'は大文字なのですべての小文字よりまえにきます。上記のかわりに
`C-u 2 M-x sort-filelds'を使ったとすると、結果はつぎのようになります。

     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

この例ではソートキーは、`Emacs'、`If'、`buffer'、`systems'、`the'だった
わけです。

`M-x sort-columns'には少々説明が必要です。文字位置の範囲を指定するには、
ポイントを文字位置の一方に、マークを他方の文字位置に置きます。このため、
ポイントやマークをソートしたい最初の行の先頭に置くことができませんから、
このコマンドでは変わった「リージョン」の定義を用います。ポイントがある行
全体はリージョンに含まれ、同様に、マークがある行全体もリージョンに含まれ、
この2つの行のあいだにある行はすべてリージョンに含まれるとみなすのです。

たとえば、ある表を10文字目から15文字目までの情報をもとにソートする場合、
表の最初の行の10文字目にマークを置き、表の最後の行の15文字目にポイントを
置き、そして`sort-column'を実行します。あるいは、マークを最初の行の15文
字目、ポイントを最後の行の10文字目に置いても同じことです。

これは、ポイントとマークで指定された矩形領域をソートするものと考えられま
す。ただし、矩形領域の右側や左側にある各行のテキストも一緒に移動します。

`sort-fold-case'が`nil'以外の場合、ソートコマンドのほとんどは比較に際し
て大文字小文字を区別しません。



File: emacs-ja.info, Node: Narrowing, Next: Two-Column, Prev: Sorting, Up: Top

ナロイング
==========

"ナロイング"（narrowing）とは、バッファのある部分だけに焦点を当て、残り
の部分を一時的に参照できなくすることです。扱える部分のことを"参照可能範
囲"と呼びます。ナロイングを取り消して、バッファ全体を参照できるように戻
すことを"ワイドニング"（widening）と呼びます。

ナロイングすると、他の部分に煩わされることなく、1つのサブルーチンや段落
などに集中できます。また、置換コマンドやキーボードマクロの適用範囲を制限
するのにも利用できます。

`C-x n n'
     ポイントとマークのあいだにナロイングする（`narrow-to-region'）。
`C-x n w'
     再度バッファ全体を参照可能にする（`widen'）。
`C-x n p'
     現在のページにナロイングする（`narrow-to-page'）。
`C-x n d'
     現在の関数定義にナロイングする（`narrow-to-defun'）。

バッファの一部分へナロイングすると、その部分だけしかないように見えます。
残りの部分は見えませんし、そこへポイントを移動することもできません（移動
コマンドは参照可能範囲から外へ出られない）し、見えない部分はどのようにし
ても変更できません。しかし、その部分がなくなったわけではないので、ファイ
ルに保存すれば参照できないテキストも保存されます。ナロイングしているあい
だは、モード行に`Narrow'と表示されます。

主要なナロイングコマンドは`C-x n n'（`narrow-to-region'）です。現在のリー
ジョンだけが参照可能で、その前後のテキストは参照できないようにカレントバッ
ファに制限を課します。ポイントとマークは変化しません。

別のやり方として、`C-x n p'（`narrow-to-page'）は現在のページだけが見え
るようにナロイングします。ページの定義については、*Note Pages::。`C-x n
d'（`narrow-to-defun'）はポイントを含む関数定義の範囲にナロイングします
（*Note Defuns::）。

ナロイングを取り消すには、`C-x n w'でワイドニングします。これによってバッ
ファ中の全テキストが再度参照可能になります。

バッファ中のどの部分にナロイングしているかは、コマンド`C-x ='で調べるこ
とができます。*Note Position Info::。

ナロイングは、それについて知らないユーザーを簡単に混乱させますので、
`narrow-to-region'は、通常、使用禁止コマンドになっています。このコマンド
を使おうとすると、Emacsは確認を求めてきて、コマンドを使えるようにするか
どうか問い合わせてきます。コマンドを利用可能にすると、それ以後は確認は必
要なくなります。*Note Disabling::。



File: emacs-ja.info, Node: Two-Column, Next: Editing Binary Files, Prev: Narrowing, Up: Top

2段組み編集
===========

2段組み（two-column）モードは、左右の段に分けたテキストを編集するのに便
利です。このモードでは、左右に並んだ2つのウィンドウを使用し、それぞれに
別のバッファを表示します。

2段組み（two-column）モードに入るには、3つの方法があります。

`F2 2' または `C-x 6 2'
     カレントバッファを左側に、カレントバッファの名前に基づいた名前のバッ
     ファを右側にして2段組み（two-column）モードに入る（`2C-two-column
     s'）。右側のバッファがまだ存在しなければ空のバッファで始まり、カレ
     ントバッファの内容は変化しない。

     このコマンドはカレントバッファが空か、または1段目の内容だけを持って
     いて、これから2段目を作成しようとするときに使う。

`F2 s' または `C-x 6 s'
     2段組みテキストを含んでいるカレントバッファの内容を2つのバッファに
     分割し、それらを左右に並べて表示する（`2C-split'）。カレントバッファ
     は左側のバッファになるが、右側の段の内容は右側のバッファに移される。
     分割位置はポイントのある文字位置で指定する。現在行からバッファの末
     尾を分割する。

     このコマンドはバッファにすでに2段組みのテキストが入っていて、一時的
     に左右の段を分けて編集したいときに用いる。

`F2 b BUFFER RET'
`C-x 6 b BUFFER RET'
     カレントバッファを左側のバッファ、BUFFERを右側のバッファとして2段組
     み（two-column）モードに入る（`2C-associate-buffer'）。

`F2 s'と`C-x 6 s'は、各行を2つの段に分ける文字列である「段区切り文字列」
を探します。段区切り文字列の文字数は、`F2 s'への数引数で指定できます。ポ
イントの直前のその文字数分の文字列が段区切り文字列になります。デフォルト
では幅は1ですから、ポイントの直前の文字が段区切り文字列になります。

各行の正しい位置に段区切り文字列があれば、`F2 s'は各行の段区切り文字列の
うしろの文字列を右側のバッファに移し、段区切り文字列を削除します。段区切
り文字列が正しい位置にない行は分割されずに左側のバッファに残り、対応する
右側のバッファの内容は空行になります。（これは、『2段組み（two-column）
モードで両側の段にまたがった行』の書き方。つまり、左側のバッファにそのよ
うな行を書き、右側のバッファは空行にしておく）。

コマンド`C-x 6 RET'や`F2 RET' （`2C-newline'）は、左右の2つのバッファの
対応する位置に改行を挿入します。バッファを分割して編集しているときに2段
組みテキストに新しい行を追加するにはこれがもっとも簡単な方法です。

左右のバッファを望むように編集し終えたら、それらを`F2 1'または`C-x 6 1'
（`2C-merge'）で再度併合します。右側バッファの内容を左側バッファに第2段
目としてコピーします。再度2段組み編集に戻るには、`F2 s'を使います。

2つのバッファ間の関連を解消するには、`F2 d'または`C-x 6 d'
（`2C-dissociate'）を使います。コマンドを入力したときにカレントバッファ
でない側のバッファが空であれば、そのバッファは削除します。



File: emacs-ja.info, Node: Editing Binary Files, Next: Saving Emacs Sessions, Prev: Two-Column, Up: Top

バイナリファイルの編集
======================

バイナリファイルを編集するための特別なメジャーモード、hexlモードがありま
す。このモードを使うには、ファイルを訪問する`C-x C-f'のかわりに`M-x
hexl-find-file'を使います。このコマンドはファイルの内容を16進数表現に変
換し、変換したものを編集するようにします。ファイルを保存すると自動的にバ
イナリに戻されます。

`M-x hexl-mode'を使えば、既存のバッファを16進数表現に変換できます。普通
にファイルを訪問してみたら、実はバイナリファイルだとわかった場合に便利で
す。

hexlモードでは通常のテキスト文字は上書きします。これはファイル中のデータ
の配置をまちがって壊してしまう危険を減らすためです。特別な挿入コマンドが
あります。以下は、hexlモードで使えるコマンドの一覧です。

`C-M-d'
     10数進で入力したコードのバイトを挿入する。

`C-M-o'
     8数進で入力したコードのバイトを挿入する。

`C-M-x'
     16数進で入力したコードのバイトを挿入する。

`C-x ['
     1kバイト単位の『ページ』の先頭へ移動する。

`C-x ]'
     1kバイト単位の『ページ』の末尾へ移動する。

`M-g'
     16進数で指定したアドレス位置へ移動する。

`M-j'
     10進数で指定したアドレス位置へ移動する。

`C-c C-c'
     hexlモードを抜け、`hexl-mode'実行前のこのバッファのメジャーモードに
     戻る。



File: emacs-ja.info, Node: Saving Emacs Sessions, Next: Recursive Edit, Prev: Editing Binary Files, Up: Top

Emacsセッションの保存
=====================

デスクトップ（desktop）ライブラリを使うと、セッションからセッションへ
Emacsの状態を保存できます。状態を保存するというのは、以前のEmacsセッショ
ンで使っていたのと同じバッファ群、メジャーモード、バッファ内の位置の状態
でEmacsが始まるという意味です。

デスクトップ機能を使うには、カスタマイズバッファ（*Note Easy
Customization::）を使って`desktop-enable'に`nil'以外の値を設定するか、個
人の`.emacs'ファイルの末尾に以下のような行を追加します。

     (desktop-load-default)
     (desktop-read)

ユーザーが最初にEmacsセッションの状態を保存するときは、`M-x
desktop-save'で陽に状態を保存する必要があります。一度これを行っておけば、
Emacsを終わるときに（現在のセッションだけでなく、それ以降のセッションで
も）自動的に状態を保存します。また、Emacsを終わらせることなく任意の時点
で状態を保存するには、`M-x desktop-save'を使います。

Emacsがまえのセッションの状態を引き継ぐためには、まえのセッションを開始
したときと同じカレントディレクトリでEmacsを起動する必要があります。これ
は、`desktop-read'が読み込むファイルをカレントディレクトリで探すからです。
つまり、異なるディレクトリごとに別のセッションを保存できることを意味しま
す。Emacsを起動するディレクトリで、保存したどのセッションを使うか制御で
きます。

変数`desktop-files-not-to-save'は、状態保存から除外するファイルを制御し
ます。この変数の値は、除外したいファイルに一致する正規表現です。デフォル
トでは、（ftpで取ってきた）リモートファイルを除外します。これはリモート
ファイルを再度取ってくるとセッションの開始が遅くなるからです。リモートファ
イルも状態保存に含めるには、`desktop-files-not-to-save'に`"^$"'と設定し
ます。*Note Remote Files::。



File: emacs-ja.info, Node: Recursive Edit, Next: Emulation, Prev: Saving Emacs Sessions, Up: Top

再帰編集レベル
==============

"再帰編集"とは、あるEmacsコマンドの実行途中で任意のEmacsコマンドを使って
編集を行う状況をいいます。たとえば、`query-replace'の途中で`C-r'を打つと、
再帰編集に入りカレントバッファを自由に変更できます。再帰編集から抜けると、
`query-replace'の続きに戻ります。

再帰編集から"脱出"するとは、実行途中のコマンドに戻ってその続きを行うこと
を意味します。脱出のためのコマンドは`C-M-c'（`exit-recursive-edit'）です。

再帰編集を"アボート"することもできます。これは脱出と似ていますが、実行途
中だったコマンドも一緒に中断します。アボートするには、`C-]'
（`abort-recursive-edit'）を使います。*Note Quitting::。

再帰編集中は、モード行のメジャー／マイナモード名を囲む丸括弧の外側に中括
弧`[...]'が表示されます。各ウィンドウのモード行すべてにこのように表示さ
れます。というのは、特定のウィンドウやバッファではなくEmacs全体が再帰編
集に入っているからです。

再帰編集中にさらに再帰編集に入ることもできます。たとえば、
`query-replace'の途中で`C-r'を打ってからデバッガを起動するコマンドを打っ
たとします。すると、`C-r'による再帰編集の中でさらにデバッガのための再帰
編集に入ることになります。モード行には、現在の再帰編集レベルの数だけ中括
弧の対が表示されます。

内側の再帰編集を（たとえばデバッガのコマンド`c'で）脱出すると、1つ上のレ
ベルでのコマンドが再開されます。そのコマンドが終わったところで`C-M-c'を
使うとそのレベルの再帰編集を脱出する、というようにして再帰編集を終わらせ
ていくことができます。脱出はつねにもっとも内側のレベルに対して起こります。
また、アボートも1つのレベルの再帰編集から脱出し、1つまえの再帰編集のコマ
ンドレベルに戻ります。必要ならそこでつぎの再帰編集レベルをアボートする、
というように続けることができます。

あるいは、コマンド`M-x top-level'ですべてのレベルの再帰編集をアボートし、
ただちにトップレベルのコマンド入力に戻ることができます。

再帰編集の中で編集しているテキストはトップレベルで編集しているテキストと
同じであるとは限りません。再帰編集の目的によって変わってきます。再帰編集
を起動するコマンドがまず別のバッファに切り替えるものなら、そのバッファを
再帰的に編集することになるでしょう。いずれにせよ、再帰編集の内側でも（バッ
ファを切り替えるキーが再定義されていない限り）通常どおりバッファを切り替
えることができます。残りの編集作業をすべて再帰編集の内側でやってしまい、
別のファイルを訪問したりもできます。しかしそのようなことをすると、ときど
き（スタックオーバーフローなどの）痛い目に合う可能性があります。ですから、
再帰編集が不要になったら忘れずに脱出かアボートしてください。

一般に、GNU Emacsでは再帰編集レベルを最小限に抑えるように努めています。
というのは、再帰編集では特定の順、つまり、最内側レベルからトップレベルに
向かう順で戻るように強いられるからです。このため、別の作業は別のバッファ
でするようにして、ユーザーがそれらの間を自由に行き来できるようにしていま
す。たとえば、あるコマンドは新しいメジャーモードに切り替えますが、もとの
モードに戻るコマンドを用意しておきます。このようにしたほうが、やりかけの
作業に戻る順番を自由に選べ、柔軟性を提供できます。



File: emacs-ja.info, Node: Emulation, Next: Dissociated Press, Prev: Recursive Edit, Up: Top

エミュレーション
================

GNU Emacsは、他のほとんどのエディタの（程度の差はありますが）エミュレー
ト（真似を）するようにプログラムできます。標準の機能では、以下のものをエ
ミュレートできます。

EDT（DECのVMSエディタ）
     `M-x edt-emulation-on'でEDTエミュレーションに入る。`M-x
     edt-emulation-off'で通常のEmacsのバインディングに戻る。

     EDTエミュレーションコマンドの大部分はキーパッドのキーであり、大部分
     のEmacsのキーバインディングはそのまま使える。EDTエミュレーションの
     バインディング変更はグローバルキーマップに対して行われ、EDTエミュレー
     ションの状態でバッファやメジャーモードを切り替えても問題ない。

vi （バークレー エディタ）
     viperは最新のviエミュレータである。viperでは複数レベルのエミュレー
     ションを実装している。レベル1がもっともviに近く、レベル5はviといく
     らか違うところもあるが、そのかわりEmacsの機能も活かせるようになって
     いる。viperを起動するには、`M-x viper-mode'と打つ。すると、使い方の
     ガイドを表示し、どのレベルのエミュレーションにするかを尋ねてくる。
     *Note Viper: (viper)Top。

vi （もう1つのエミュレータ）
     `M-x vi-mode'はそれまでのメジャーモードにかわってviメジャーモードに
     入る。viの『入力』モードに入るコマンドはすべて、それまでのメジャー
     モードに戻る動作になっている。つまり、viの『入力』モードとして普通
     のEmacsが使えるのである。

     viエミュレーションはメジャーモードとして動くので、エミュレーション
     中にバッファを切り替えることはできない。バッファを切り替えたければ、
     まず通常のEmacsに戻る。

     viエミュレーションを多用するつもりなら、`vi-mode'コマンドにキーをバ
     インドしたほうがよいだろう。

vi （また別のエミュレータ）
     `M-x vip-mode'は、`M-x vi-mode'よりもっとviに酷似しているといわれる
     別のviエミュレータを起動する。このエミュレータでは『入力』モードも
     通常のEmacsとは変わっていて、ESCでviコマンドモードに戻る。viコマン
     ドモードのエミュレーションから通常のEmacsに戻るには`C-z'と打つ。

     このエミュレータはメジャーモードとして動くのではないので、エミュレー
     タを動かしたままさまざまな方法でバッファを切り替えることができる。
     `vi-mode'のようにコマンド`vi-mode'で入力モードを終了するのではない
     ので、`vip-mode'にキーを割り当てる必要はない。

     より詳しくは*Note VIP: (vip)Top。



File: emacs-ja.info, Node: Dissociated Press, Next: Amusements, Prev: Emulation, Up: Top

まぜこぜ新聞（Dissociated Press）
=================================

`M-x dissociated-press'はテキストを、単語単位、または、文字単位で混ぜ合
わせるコマンドです。普通の英語をバッファに入れた状態でこれを実行すると、
きわめておもしろい結果が生成されます。入力はカレントバッファから取り、出
力は`*Dissociation*'というバッファに書き込みます（およそ2、3行生成するご
とにバッファが再表示されるので、生成内容を順次読めます）。

`M-x dissociated-press'は定期的にもっと出力を続けるかどうか聞いてきます。
`n'と答えると生成をやめます。また、`C-g'を打てばいつでも止められます。出
力はバッファ`*Dissociation*'に残っていますから、必要ならどこへでもコピー
できます。

`M-x dissociated-press'はバッファ中のある箇所からランダムに別の箇所にジャ
ンプすることを繰り返していきます。ただのゴミではなくおもしろい出力が得ら
れるように、ある一連の単語列からつぎの一連の単語列に移る際に、それらのあ
いだに一定の重複があるようにします。つまり、たとえばpresidentと出力した
ところで別の場所にジャンプすることに決めたら、最後にあったentと同じ文字
列のある単語、たとえばpentagonのところに飛んでそこから続けるので、結果と
してpregidentagon (1) (*Note Dissociated Press-Footnotes::) というのが生
成されるわけです。元テキストが長いとたいへんおもしろい結果を得られます。


`M-x dissociated-press'に正の数引数を渡すと文字単位で動作し、その数値は
重複する文字数を指定します。また、負の数引数を渡すと単語単位で動作し、そ
の数値（の絶対値）で重複する単語数を指定します。引数を指定しないと「2」
を指定したのと同じになります。繰り返しますが、出力はつねにバッファ
`*Dissociation*'に現れます。もとのバッファは変更されません。

`M-x dissociated-press'は、入力テキストから頻度表を作ってマルコフ連鎖を
適用したのに近い結果をもたらしますが、それ自体はきわめてオリジナルな発明
です。というのは、マルコフ連鎖では単に乱数に基づいて文字や語を選ぶだけな
のに対し、このコマンドでは乱数に基づいて連続した文字や語をコピーしてくる
からです。このため、より高速な実行が可能ですし、読んでおもしろい結果が得
られます。

`M-x dissociated-press'の使いすぎは仕事に差し支え、場合によっては重大な
障碍となりますから注意しましょう。また、ユーザーに受け入れてもらうために
も、マニュアルにこのコマンドの出力を利用するのはやめたほうがよいです。で
も、せいぜい楽しんで、よかったらバグの提案もよろしく。 (2) (*Note
Dissociated Press-Footnotes::)


File: emacs-ja.info  Node: Dissociated Press-Footnotes, Up: Dissociated Press

(1) この合成語は、ベトナム戦争中にまさにそれにぴったりの意味で実際に使わ
れたことがある。

(2) 【訳注】 この段落自体、`M-x dissociated-press'で生成したようなも
のなので、原文を掲載しておく。 
 It is a mustatement that too much use
of Dissociated Press can be a developediment to your real work.
Sometimes to the point of outragedy.  And keep dissociwords out of your
documentation, if you want it to be well userenced and properbose.  Have
fun.  Your buggestions are welcome.



File: emacs-ja.info, Node: Amusements, Next: Customization, Prev: Dissociated Press, Up: Top

その他の娯楽
============

退屈なときは、`M-x hanoi'を試してください。ひどく退屈なら、数引数を指定
してください。ものすごく、ひどく退屈なら、「9」を指定するとよいでしょう。
まあやってみてください。

もう少し積極的に何かしたいなら、`M-x gomoku'を試してください。これは五目
並べのプログラムです。

`M-x blackbox'と`M-x mpuz'は2種類のパズルです。`blackbox'は箱の中の物の
位置を当てるゲームです。`mpuz'は掛け算の覆面算で、英字に対応している数字
を当てるゲームです。英字を打ってからその英字に対応していると思う数字を打
ち込みます。

`M-x dunnet'はアドベンチャー風の探検ゲームで、大きなパズルだと思えばよい
でしょう。

いらいらするときは、有名なElizaプログラムを試してみてください。`M-x
doctor'と打つだけです。1つの入力の終りにはRETを2回打ちます。

奇妙な感じがするときは、`M-x yow'と打ってみてください。


File: emacs-ja.info, Node: Customization, Next: Quitting, Prev: Amusements, Up: Top

カスタマイズ
************

本章では、Emacsの動作を（あまり大幅でなく）カスタマイズする方法について
説明します。もっと大幅な変更を行いたい場合には`The Emacs Lisp Reference
Manual'を参照してください。

カスタマイズは、Emacsの1つのセッションの中だけで効果を持ちます。Emacsを
終了するとカスタマイズの効果は失われますし、同時にあるいはあとで別の
Emacsを立ち上げた場合にも何の影響も及ぼしません。あるEmacsのセッションが
セッションを超えて影響するためには、ファイルに書くしかありません。特に、
カスタマイズを『恒久化』したい場合には、個人の`.emacs'ファイルやその他の
関連するファイルに適切な内容を書き込んでおき、セッションごとにカスタマイ
ズが行われるようにします。*Note Init File::。

* Menu:

* Minor Modes::		Each minor mode is one feature you can turn on
			  independently of any others.
* Variables::		Many Emacs commands examine Emacs variables
			  to decide what to do; by setting variables,
			  you can control their functioning.
* Keyboard Macros::	A keyboard macro records a sequence of
			  keystrokes to be replayed with a single
			  command. 
* Key Bindings::	The keymaps say what command each key runs.
			  By changing them, you can "redefine keys".
* Keyboard Translations::
                        If your keyboard passes an undesired code
			   for a key, you can tell Emacs to
			   substitute another code. 
* Syntax::		The syntax table controls how words and
			   expressions are parsed.
* Init File::		How to write common customizations in the
			  `.emacs' file. 



File: emacs-ja.info, Node: Minor Modes, Next: Variables, Up: Customization

マイナモード（minor mode）
==========================

マイナモードは、個別にオン／オフ可能な機能です。たとえば、マイナモードで
ある自動詰め込み（auto-fill）モードをオンにすると、SPCで自動的に（単語の
切れ目で）行分けします。すべてのマイナモードは互いに独立ですし、どのメ
ジャーモードとも独立です。ほとんどのマイナモードは、それがオンであること
をモード行に表示します。たとえば、モード行に`Fill'と表示されていれば、自
動詰め込み（auto-fill）モードがオンであることを意味します。

マイナモード名のうしろに`-mode'を付け加えると、そのモードをオン／オフす
るコマンド関数の名前になります。したがって、自動詰め込み（auto-fill）モー
ドをオン／オフするコマンドは`M-x auto-fill-mode'ということになります。こ
れらのコマンドは通常`M-x'を使って起動しますが、どれかのキーにバインドす
ることもできます。引数を指定しないと、これらのコマンドはモードがオフのと
きはオンに、オンのときはオフに切り替えます。これを"トグルする"と呼びます。
これに対し、正の引数を指定するとつねにモードをオンにしますし、明示的に0
の引数を指定するか、または負の引数を指定するとつねにモードをオフにします。

いくつかのマイナモードのオン／オフは、カレントバッファに対してのみ適用さ
れ、他のバッファには影響しません。つまり、あるバッファであるモードをオン
にし、別のバッファではそのモードをオフにできるわけです。このような、バッ
ファごとにオン／オフできるマイナモードとしては、略語（abbrev）モード、自
動詰め込み（auto-fill）モード、自動保存（auto-save）モード、フォントロッ
ク（font-lock）モード、ISOアクセント（iso-sccents）モード、アウトライン
（outline）マイナモード、上書き（overwrite）モード、バイナリ上書き
（binary-overwrite）モードがあります。

略語（abbrev）モードでは、略語を打ち込むと自動的に展開されるような略語を
定義できます。たとえば、`amd'を`abbrev mode'と展開させます。詳しくは、
*Note Abbrevs::。

自動詰め込み（auto-fill）モードでは、いちいち改行で行分けしなくてもテキ
ストを詰め込んで入力できます。行が長くなりすぎないようにEmacsが適宜改行
を挿入します。*Note Filling::。

自動保存（auto-save）モードはバッファの内容を定期的に保存することで、シ
ステムクラッシュが起きたとき紛失してしまう作業の量を少なくします。*Note
Auto Save::。

エンリッチ（enriched）モードは、整形済みテキストの編集を可能にします。
*Note Formatted Text::。

フライスペル（flyspell）モードは、綴りに誤りのある単語を自動的に強調表示
します。

フォントロック（font-lock）モードは、コメント、文字列、定義中の関数名な
どのプログラム中の決まった単位を自動的に強調表示します。これには、複数の
フォントを表示できるウィンドウシステムが必要です。*Note Faces::。

水平スクロール（hscroll）モードは、ポイントが画面内に留まるように、自動
的に水平スクロールを行います。*Note Horizontal Scrolling::。

ISOアクセント（iso-accents）モードは、``'、`''、 `"'、`^'、`/'、`~'とこ
れらに続くつぎの文字を結合して、ISO Latin-1文字集合のアクセント付き文字
を作り出します。*Note Single-Byte European Support::。

アウトラインマイナ（outline-minor）モードは、メジャーモードであるアウト
ライン（outline）モードと同じ機能を提供します。しかし、マイナモードなの
で任意のメジャーモードと一緒に使えます。*Note Outline Mode::。

上書き（overwrite）モードでは、入力された図形文字は既存の文字を右に押し
やるかわりにその文字を置き換えます。たとえば、ポイントが`FOOBAR'の`B'の
まえにあるときに`G'を打つと`FOOGAR'となります。通常のモードであれば
`FOOGBAR'となります。上書き（overwrite）モードでコマンド`C-q'を打つと、
そのつぎの文字が何であっても（数字であっても）その文字を挿入します。つま
り、上書き（overwrite）モードの中で文字を挿入するにはこの方法を使います。

バイナリ上書き（binary-overwrite）モードは上書き（overwrite）モードの変
形で、バイナリファイル編集用です。このモードでは、改行やタブも他の文字と
同じに扱われるので、他の文字をこれらの文字で上書きすることも、これらの文
字を他の文字で上書きすることもできます。

以下で説明するマイナモードは、すべてのバッファに一斉に適用されます。ただ
し、これらは変数の値に応じてオン／オフされますから、その変数をバッファに
ローカルな変数にすれば、バッファごとに独立にオン／オフすることも可能です。
*Note Locals::。

補完示唆（icomplete）モードは、ミニバッファで入力中に補完機能が働いてい
るとき、どのような補完候補があるかを表示します。*Note Completion
Options::。

行番号（line-number）モードは、ポイントのある行の行番号を絶えずモード行
に表示します。*Note Mode Line::。

ミニバッファリサイズ（resize-minibuffer）モードは、打ち込んだテキスト量
に応じて自動的にミニバッファを広げます。*Note Minibuffer Edit::。

スクロールバー（scroll-bar）モードは、各ウィンドウにスクロールバーを付け
ます（*Note Scroll Bars::）。メニューバー（menu-bar）モードは、各フレー
ムにメニューバーを付けます（*Note Menu Bars::）。どちらのモードも、Xウィ
ンドウシステムを使っているときはデフォルトでオンになっています。

暫定マーク（transient-mark）モードでは、バッファの内容を変更するとマーク
は『不活性』になるので、そのあとでリージョンを対象とするコマンドを使うと
エラーになります。つまり、リージョンを対象とするコマンドを使うまえに、改
めてマークを設定するか、不活性になったマークを『再度活性』にします。暫定
マーク（transient-mark）モードの利点は、（今のところXウィンドウシステム
を使っているときのみ）Emacsがリージョンを強調表示することです。*Note
Setting Mark::。

ほとんどのマイナモードには、コマンド名と同じ名前の変数があり、その変数で
モードを直接制御しています。つまり、その変数の値が`nil'以外ならモードは
オンであり、各マイナモードコマンドは変数の値を設定する動作をします。たと
えば、コマンド`outline-minor-mode'は、変数`outline-minor-mode'の値を設定
する動作を行います。つまり、この変数が、直接、上書き（overwrite）モード
をオン／オフしているのです。あるマイナモードがこのように動作するかどうか
は、`C-h v'を使ってその変数の説明文字列を参照してください。

これらのマイナモード変数は、Lispプログラムからモードをオン／オフするのに
有用です。また、ファイルのローカル変数リストとして指定するのも便利です。
ただし、ローカル変数リストで設定する場合には、よく考えてください。という
のは、ほとんどのマイナモードはユーザーの好みの問題であり、同じファイルを
編集する別のユーザーは好みが違うかもしれません。



